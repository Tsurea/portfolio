/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["src_components_form_map_tsx"],{

/***/ "./node_modules/@mapbox/search-js-core/dist/index-esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-core/dist/index-esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressAutofillCore: function() { return /* binding */ AddressAutofillCore; },\n/* harmony export */   Evented: function() { return /* binding */ Evented; },\n/* harmony export */   GeocodingCore: function() { return /* binding */ GeocodingCore; },\n/* harmony export */   LngLat: function() { return /* binding */ LngLat; },\n/* harmony export */   LngLatBounds: function() { return /* binding */ LngLatBounds; },\n/* harmony export */   MapboxAutofill: function() { return /* binding */ AddressAutofillCore; },\n/* harmony export */   MapboxError: function() { return /* binding */ MapboxError; },\n/* harmony export */   MapboxGeocode: function() { return /* binding */ GeocodingCore; },\n/* harmony export */   MapboxValidate: function() { return /* binding */ ValidationCore; },\n/* harmony export */   MatchCodeConfidence: function() { return /* binding */ MatchCodeConfidence; },\n/* harmony export */   MatchCodeType: function() { return /* binding */ MatchCodeType; },\n/* harmony export */   SearchBoxCore: function() { return /* binding */ SearchBoxCore; },\n/* harmony export */   SearchSession: function() { return /* binding */ SearchSession; },\n/* harmony export */   SessionToken: function() { return /* binding */ SessionToken; },\n/* harmony export */   ValidationCore: function() { return /* binding */ ValidationCore; },\n/* harmony export */   debounce: function() { return /* binding */ debounce; },\n/* harmony export */   featureToSuggestion: function() { return /* binding */ featureToSuggestion; },\n/* harmony export */   polyfillFetch: function() { return /* binding */ polyfillFetch; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/autofill/constants.ts\nvar SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_SUGGEST = \"suggest\";\nvar ENDPOINT_RETRIEVE = \"retrieve\";\nvar SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nvar RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n\n// src/LngLat.ts\nvar LngLat = class {\n  constructor(lng, lat) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\"Invalid LngLat longitude value: must be between -180 and 180\");\n    }\n  }\n  toArray() {\n    return [this.lng, this.lat];\n  }\n  toString() {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n  static convert(input) {\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n    if (!Array.isArray(input) && typeof input == \"object\" && input !== null && (\"lng\" in input || \"lon\" in input) && \"lat\" in input) {\n      return new LngLat(Number(\"lng\" in input ? input.lng : input.lon), Number(input.lat));\n    }\n    throw new Error(\"`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n  }\n};\n\n// src/LngLatBounds.ts\nvar LngLatBounds = class {\n  constructor(sw, ne) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n  getSouthWest() {\n    return this._sw;\n  }\n  getNorthEast() {\n    return this._ne;\n  }\n  getNorthWest() {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n  getSouthEast() {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n  getWest() {\n    return this._sw.lng;\n  }\n  getSouth() {\n    return this._sw.lat;\n  }\n  getEast() {\n    return this._ne.lng;\n  }\n  getNorth() {\n    return this._ne.lat;\n  }\n  toArray() {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n  toFlatArray() {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n  toString() {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n  static convert(input) {\n    if (!input) {\n      throw new Error(\"Invalid LngLatBounds convert value: falsy\");\n    }\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));\n    }\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(LngLat.convert([input[0], input[1]]), LngLat.convert([input[2], input[3]]));\n    }\n    throw new Error(\"`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]\");\n  }\n};\n\n// src/utils/uuid.ts\nfunction generateUUID() {\n  const randomString = Math.random().toString(16) + Date.now().toString(16) + Math.random().toString(16);\n  const uuidString = randomString.replace(/\\./g, \"\");\n  const uuid = [\n    uuidString.slice(0, 8),\n    uuidString.slice(8, 12),\n    \"4\" + uuidString.slice(12, 15) + \"-8\" + uuidString.slice(15, 18),\n    uuidString.slice(18, 30)\n  ].join(\"-\");\n  return uuid;\n}\n\n// src/SessionToken.ts\nvar SessionToken = class {\n  constructor(id) {\n    this.id = id != null ? id : generateUUID();\n  }\n  toString() {\n    return this.id;\n  }\n  static convert(token) {\n    return new SessionToken(token instanceof SessionToken ? token.id : token.toString());\n  }\n};\n\n// src/MapboxError.ts\nvar UNKNOWN_ERROR = \"Unknown error\";\nvar MapboxError = class extends Error {\n  constructor(json, statusCode) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = \"MapboxError\";\n    this.statusCode = statusCode;\n  }\n  toString() {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n};\nfunction handleNonOkRes(res) {\n  return __async(this, null, function* () {\n    if (!res.ok) {\n      const json = yield res.json();\n      throw new MapboxError(json, res.status);\n    }\n  });\n}\n\n// src/fetch.ts\nvar _fetchImpl = globalThis.fetch;\nvar _abortControllerImpl = globalThis.AbortController;\nfunction polyfillFetch({ fetch, AbortController }, force = false) {\n  if (!fetch) {\n    throw new Error(\"Fetch implementation must include implementations of `fetch`.\");\n  }\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\nfunction getFetch() {\n  if (!_fetchImpl) {\n    throw new Error(\"Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.\");\n  }\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n\n// src/utils/queryParams.ts\nfunction queryParams(...objects) {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj)\n      continue;\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null)\n        continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n  return params.join(\"&\");\n}\n\n// src/autofill/AddressAutofillCore.ts\nvar _getQueryParams, getQueryParams_fn;\nvar _AddressAutofillCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _AddressAutofillCore.defaults), defaults);\n  }\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n      const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return __spreadProps(__spreadValues({}, json), {\n        suggestions: json.suggestions.map((suggestion) => {\n          return __spreadProps(__spreadValues({}, suggestion), {\n            original_search_text: searchText\n          });\n        }),\n        url: url.toString()\n      });\n    });\n  }\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n      if (!this.canRetrieve(suggestion)) {\n        throw new Error(\"suggestion cannot be retrieved\");\n      }\n      const { sessionToken: sessionTokenLike, signal } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(`${RETRIEVE_URL}/${suggestion.action.id}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), { signal });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  canRetrieve(suggestion) {\n    const action = suggestion.action;\n    return typeof (action == null ? void 0 : action.id) === \"string\";\n  }\n};\nvar AddressAutofillCore = _AddressAutofillCore;\n_getQueryParams = new WeakSet();\ngetQueryParams_fn = function(options) {\n  return queryParams({\n    types: \"address\",\n    access_token: this.accessToken,\n    streets: options.streets,\n    language: options.language,\n    country: options.country,\n    limit: options.limit\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\nAddressAutofillCore.defaults = {\n  language: \"en\",\n  proximity: \"ip\",\n  streets: true\n};\n\n// src/searchbox/constants.ts\nvar SEARCH_URL2 = `https://api.mapbox.com/search/searchbox/v1`;\nvar ENDPOINT_SUGGEST2 = \"suggest\";\nvar ENDPOINT_RETRIEVE2 = \"retrieve\";\nvar ENDPOINT_CATEGORY = \"category\";\nvar ENDPOINT_REVERSE = \"reverse\";\nvar SUGGEST_URL2 = `${SEARCH_URL2}/${ENDPOINT_SUGGEST2}`;\nvar RETRIEVE_URL2 = `${SEARCH_URL2}/${ENDPOINT_RETRIEVE2}`;\nvar CATEGORY_URL = `${SEARCH_URL2}/${ENDPOINT_CATEGORY}`;\nvar REVERSE_URL = `${SEARCH_URL2}/${ENDPOINT_REVERSE}`;\n\n// src/searchbox/SearchBoxCore.ts\nvar _getQueryParams2, getQueryParams_fn2;\nvar _SearchBoxCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams2);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _SearchBoxCore.defaults), defaults);\n  }\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        q: searchText,\n        sessionToken\n      });\n      if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n        throw new Error(\"to provide eta estimate: eta, navigation_profile, and origin are required\");\n      }\n      if (options.origin && !options.navigation_profile) {\n        throw new Error(\"to provide distance estimate: both navigation_profile and origin are required\");\n      }\n      const url = new URL(SUGGEST_URL2);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n      const { sessionToken: sessionTokenLike, signal } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(`${RETRIEVE_URL2}/${encodeURIComponent(suggestion.mapbox_id)}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  category(_0) {\n    return __async(this, arguments, function* (category, optionsArg = {}) {\n      if (!category) {\n        throw new Error(\"category is required\");\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const url = new URL(`${CATEGORY_URL}/${encodeURIComponent(category)}`);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  reverse(_0) {\n    return __async(this, arguments, function* (lngLat, optionsArg = {}) {\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n      const [lng, lat] = typeof lngLat === \"string\" ? lngLat.split(\",\").map((x) => parseFloat(x)) : LngLat.convert(lngLat).toArray();\n      if (isNaN(lng) || isNaN(lat)) {\n        throw new Error(\"lngLat is required\");\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const url = new URL(REVERSE_URL);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit,\n        longitude: lng,\n        latitude: lat\n      }, options.types && {\n        types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n};\nvar SearchBoxCore = _SearchBoxCore;\n_getQueryParams2 = new WeakSet();\ngetQueryParams_fn2 = function(options) {\n  return queryParams({\n    q: options.q,\n    access_token: this.accessToken,\n    language: options.language,\n    limit: options.limit,\n    navigation_profile: options.navigation_profile,\n    route: options.route,\n    route_geometry: options.route_geometry,\n    sar_type: options.sar_type,\n    time_deviation: options.time_deviation,\n    eta_type: options.eta_type,\n    country: options.country,\n    poi_category: options.poi_category,\n    radius: options.radius,\n    user_id: options.user_id,\n    rich_metadata_provider: options.rich_metadata_provider,\n    poi_category_exclusions: options.poi_category_exclusions\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.origin && {\n    origin: typeof options.origin === \"string\" ? options.origin : LngLat.convert(options.origin).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n};\nSearchBoxCore.defaults = {\n  language: \"en\"\n};\n\n// src/validate/constants.ts\nvar SEARCH_URL3 = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_VALIDATE = \"retrieve\";\nvar VALIDATE_URL = `${SEARCH_URL3}/${ENDPOINT_VALIDATE}`;\n\n// src/validate/ValidationCore.ts\nvar _getQueryParams3, getQueryParams_fn3;\nvar _ValidationCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams3);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _ValidationCore.defaults), defaults);\n  }\n  validate(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n      const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams3, getQueryParams_fn3).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      if (json.features.length > 0) {\n        json.features = [json.features[0]];\n      }\n      return json;\n    });\n  }\n};\nvar ValidationCore = _ValidationCore;\n_getQueryParams3 = new WeakSet();\ngetQueryParams_fn3 = function(options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\nValidationCore.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n};\n\n// src/geocode/constants.ts\nvar BASE_URL = `https://api.mapbox.com/search/geocode/v6`;\nvar FORWARD_URL = `${BASE_URL}/forward`;\nvar REVERSE_URL2 = `${BASE_URL}/reverse`;\nvar BATCH_URL = `${BASE_URL}/batch`;\n\n// src/geocode/GeocodingCore.ts\nvar REVERSE_GEOCODE_COORD_REGEX = /^[ ]*(-?\\d{1,3}(\\.\\d{0,256})?)[, ]+(-?\\d{1,3}(\\.\\d{0,256})?)[ ]*$/;\nvar SPACES_OR_COMMA_REGEX = /[\\s,]+/;\nvar _getQueryParams4, getQueryParams_fn4;\nvar GeocodingCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams4);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues({}, defaults);\n  }\n  forward(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      let signal;\n      if (optionsArg) {\n        ({ signal } = optionsArg);\n      }\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        q: searchText\n      });\n      const url = new URL(`${FORWARD_URL}`);\n      url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options);\n      const { fetch } = getFetch();\n      const fetchInit = signal ? { signal } : {};\n      const res = yield fetch(url.toString(), fetchInit);\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  reverse(lngLat, optionsArg) {\n    return __async(this, null, function* () {\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n      let signal;\n      if (optionsArg) {\n        ({ signal } = optionsArg);\n      }\n      let lngLatObj;\n      if (typeof lngLat === \"string\") {\n        const [lng, lat] = lngLat.split(\",\");\n        lngLatObj = new LngLat(Number(lng), Number(lat));\n      } else {\n        lngLatObj = LngLat.convert(lngLat);\n      }\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        longitude: lngLatObj.lng,\n        latitude: lngLatObj.lat\n      });\n      const url = new URL(`${REVERSE_URL2}`);\n      url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options, true);\n      const { fetch } = getFetch();\n      const fetchInit = signal ? { signal } : {};\n      const res = yield fetch(url.toString(), fetchInit);\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      const isReverseQuery = REVERSE_GEOCODE_COORD_REGEX.test(searchText);\n      if (isReverseQuery) {\n        const coordinates = searchText.trim().split(SPACES_OR_COMMA_REGEX).map((part) => part.trim()).join(\",\");\n        return this.reverse(coordinates, optionsArg);\n      } else {\n        return this.forward(searchText, optionsArg);\n      }\n    });\n  }\n  retrieve(suggestion) {\n    return __async(this, null, function* () {\n      return suggestion;\n    });\n  }\n};\n_getQueryParams4 = new WeakSet();\ngetQueryParams_fn4 = function(options, isReverse = false) {\n  if (isReverse) {\n    [\"proximity\", \"autocomplete\", \"bbox\"].forEach((key) => {\n      if (key in options) {\n        delete options[key];\n      }\n    });\n  }\n  return queryParams({\n    q: options.q,\n    longitude: options.longitude,\n    latitude: options.latitude,\n    access_token: this.accessToken,\n    permanent: options.permanent,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    autocomplete: options.autocomplete,\n    worldview: options.worldview\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n};\n\n// src/types.ts\nvar MatchCodeType = /* @__PURE__ */ ((MatchCodeType2) => {\n  MatchCodeType2[\"matched\"] = \"matched\";\n  MatchCodeType2[\"unmatched\"] = \"unmatched\";\n  MatchCodeType2[\"plausible\"] = \"plausible\";\n  MatchCodeType2[\"not_applicable\"] = \"not_applicable\";\n  MatchCodeType2[\"inferred\"] = \"inferred\";\n  return MatchCodeType2;\n})(MatchCodeType || {});\nvar MatchCodeConfidence = /* @__PURE__ */ ((MatchCodeConfidence2) => {\n  MatchCodeConfidence2[\"exact\"] = \"exact\";\n  MatchCodeConfidence2[\"high\"] = \"high\";\n  MatchCodeConfidence2[\"medium\"] = \"medium\";\n  MatchCodeConfidence2[\"low\"] = \"low\";\n  return MatchCodeConfidence2;\n})(MatchCodeConfidence || {});\n\n// src/utils/Evented.ts\nvar _listeners;\nvar Evented = class {\n  constructor() {\n    __privateAdd(this, _listeners, {});\n  }\n  addEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n    listenersArr[type].push(listener);\n  }\n  removeEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      return;\n    }\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n  fire(type, arg0) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      return;\n    }\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n};\n_listeners = new WeakMap();\n\n// src/utils/debounce.ts\nfunction debounce(func, wait, signalFn) {\n  let timeout = null;\n  return (...args) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal == null ? void 0 : signal.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  };\n}\n\n// src/SearchSession.ts\nfunction createAbortController() {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\nvar _suggestions, _abort, _suggestDebounce;\nvar SearchSession = class extends Evented {\n  constructor(search, wait = 0) {\n    super();\n    this.sessionToken = new SessionToken();\n    __privateAdd(this, _suggestions, void 0);\n    __privateAdd(this, _abort, createAbortController());\n    __privateAdd(this, _suggestDebounce, void 0);\n    __privateSet(this, _suggestDebounce, debounce((_0, ..._1) => __async(this, [_0, ..._1], function* (searchText, options = {}) {\n      __privateGet(this, _abort).abort();\n      __privateSet(this, _abort, createAbortController());\n      if (!searchText) {\n        __privateSet(this, _suggestions, null);\n        this.fire(\"suggest\", __privateGet(this, _suggestions));\n        return;\n      }\n      try {\n        const res = yield this.search.suggest(searchText, __spreadProps(__spreadValues({\n          sessionToken: this.sessionToken\n        }, options), {\n          signal: __privateGet(this, _abort).signal\n        }));\n        __privateSet(this, _suggestions, res);\n        this.fire(\"suggest\", res);\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          return;\n        }\n        this.fire(\"suggesterror\", err);\n      }\n    }), wait, () => __privateGet(this, _abort).signal));\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n  get suggestions() {\n    return __privateGet(this, _suggestions);\n  }\n  suggest(searchText, options) {\n    __privateGet(this, _suggestDebounce).call(this, searchText, options);\n    return new Promise((resolve, reject) => {\n      let suggestFn;\n      let suggestErrorFn;\n      suggestFn = (res) => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        reject(err);\n      };\n      this.addEventListener(\"suggest\", suggestFn);\n      this.addEventListener(\"suggesterror\", suggestErrorFn);\n    });\n  }\n  clear() {\n    this.suggest(\"\");\n  }\n  retrieve(suggestion, options) {\n    return __async(this, null, function* () {\n      const res = yield this.search.retrieve(suggestion, __spreadValues({\n        sessionToken: this.sessionToken\n      }, options));\n      this.fire(\"retrieve\", res);\n      return res;\n    });\n  }\n  canRetrieve(suggestion) {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n    return this.search.canRetrieve(suggestion);\n  }\n  canSuggest(suggestion) {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n    return this.search.canSuggest(suggestion);\n  }\n  abort() {\n    __privateGet(this, _abort).abort();\n    __privateSet(this, _abort, createAbortController());\n  }\n};\n_suggestions = new WeakMap();\n_abort = new WeakMap();\n_suggestDebounce = new WeakMap();\n\n// src/featureToSuggestion.ts\nfunction featureToSuggestion(feature) {\n  const { properties } = feature;\n  return __spreadValues({}, properties);\n}\n\n//# sourceMappingURL=index-esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtY29yZS9kaXN0L2luZGV4LWVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVcsR0FBRyxpQkFBaUI7QUFDcEQsc0JBQXNCLFdBQVcsR0FBRyxrQkFBa0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUksSUFBSSxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxJQUFJLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx1QkFBdUIsYUFBYSx1QkFBdUI7QUFDdEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0IsSUFBSSxvQkFBb0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxHQUFHLGdCQUFnQixLQUFLLGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLEdBQUcsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLG9FQUFvRTtBQUNwRTtBQUNBLE9BQU87QUFDUCw2QkFBNkIsWUFBWSxHQUFHLCtCQUErQjtBQUMzRTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlDQUF5QztBQUN2RDtBQUNBLDZCQUE2QixhQUFhLEdBQUcscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxjQUFjLFFBQVE7QUFDdEIsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZLEdBQUcsa0JBQWtCO0FBQ3ZELHVCQUF1QixZQUFZLEdBQUcsbUJBQW1CO0FBQ3pELHNCQUFzQixZQUFZLEdBQUcsa0JBQWtCO0FBQ3ZELHFCQUFxQixZQUFZLEdBQUcsaUJBQWlCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQSw2QkFBNkIsY0FBYyxHQUFHLHlDQUF5QztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsNkJBQTZCLGFBQWEsR0FBRyw2QkFBNkI7QUFDMUU7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZLEdBQUcsa0JBQWtCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxvRUFBb0U7QUFDcEU7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLGFBQWEsR0FBRywrQkFBK0I7QUFDNUU7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUIsc0JBQXNCLFNBQVM7QUFDL0IsbUJBQW1CLFNBQVM7O0FBRTVCO0FBQ0EsOENBQThDLElBQUksTUFBTSxNQUFNLGNBQWMsSUFBSSxNQUFNLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLE9BQU87QUFDUCw2QkFBNkIsWUFBWTtBQUN6QztBQUNBLGNBQWMsUUFBUTtBQUN0QixtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQSxjQUFjLFFBQVE7QUFDdEIsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStIO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQW9CRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWFwYm94L3NlYXJjaC1qcy1jb3JlL2Rpc3QvaW5kZXgtZXNtLmpzPzk1NGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpO1xuICByZXR1cm4gbWV0aG9kO1xufTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9hdXRvZmlsbC9jb25zdGFudHMudHNcbnZhciBTRUFSQ0hfVVJMID0gYGh0dHBzOi8vYXBpLm1hcGJveC5jb20vYXV0b2ZpbGwvdjFgO1xudmFyIEVORFBPSU5UX1NVR0dFU1QgPSBcInN1Z2dlc3RcIjtcbnZhciBFTkRQT0lOVF9SRVRSSUVWRSA9IFwicmV0cmlldmVcIjtcbnZhciBTVUdHRVNUX1VSTCA9IGAke1NFQVJDSF9VUkx9LyR7RU5EUE9JTlRfU1VHR0VTVH1gO1xudmFyIFJFVFJJRVZFX1VSTCA9IGAke1NFQVJDSF9VUkx9LyR7RU5EUE9JTlRfUkVUUklFVkV9YDtcblxuLy8gc3JjL0xuZ0xhdC50c1xudmFyIExuZ0xhdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobG5nLCBsYXQpIHtcbiAgICBpZiAoaXNOYU4obG5nKSB8fCBpc05hTihsYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG5nTGF0IG9iamVjdDogKCR7bG5nfSwgJHtsYXR9KWApO1xuICAgIH1cbiAgICB0aGlzLmxuZyA9ICtsbmc7XG4gICAgdGhpcy5sYXQgPSArbGF0O1xuICAgIGlmICh0aGlzLmxhdCA+IDkwIHx8IHRoaXMubGF0IDwgLTkwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExuZ0xhdCBsYXRpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC05MCBhbmQgOTBcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmxuZyA+IDE4MCB8fCB0aGlzLmxuZyA8IC0xODApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTG5nTGF0IGxvbmdpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC0xODAgYW5kIDE4MFwiKTtcbiAgICB9XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMubG5nLCB0aGlzLmxhdF07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBMbmdMYXQoJHt0aGlzLmxuZ30sICR7dGhpcy5sYXR9KWA7XG4gIH1cbiAgc3RhdGljIGNvbnZlcnQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBMbmdMYXQpIHtcbiAgICAgIHJldHVybiBuZXcgTG5nTGF0KGlucHV0LmxuZywgaW5wdXQubGF0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoTnVtYmVyKGlucHV0WzBdKSwgTnVtYmVyKGlucHV0WzFdKSk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgdHlwZW9mIGlucHV0ID09IFwib2JqZWN0XCIgJiYgaW5wdXQgIT09IG51bGwgJiYgKFwibG5nXCIgaW4gaW5wdXQgfHwgXCJsb25cIiBpbiBpbnB1dCkgJiYgXCJsYXRcIiBpbiBpbnB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoTnVtYmVyKFwibG5nXCIgaW4gaW5wdXQgPyBpbnB1dC5sbmcgOiBpbnB1dC5sb24pLCBOdW1iZXIoaW5wdXQubGF0KSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImBMbmdMYXRMaWtlYCBhcmd1bWVudCBtdXN0IGJlIHNwZWNpZmllZCBhcyBhbiBvYmplY3Qge2xuZzogPGxuZz4sIGxhdDogPGxhdD59LCBhbiBvYmplY3Qge2xvbjogPGxuZz4sIGxhdDogPGxhdD59LCBvciBhbiBhcnJheSBvZiBbPGxuZz4sIDxsYXQ+XVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL0xuZ0xhdEJvdW5kcy50c1xudmFyIExuZ0xhdEJvdW5kcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3csIG5lKSB7XG4gICAgdGhpcy5fc3cgPSBMbmdMYXQuY29udmVydChzdyk7XG4gICAgdGhpcy5fbmUgPSBMbmdMYXQuY29udmVydChuZSk7XG4gIH1cbiAgZ2V0U291dGhXZXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9zdztcbiAgfVxuICBnZXROb3J0aEVhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25lO1xuICB9XG4gIGdldE5vcnRoV2VzdCgpIHtcbiAgICByZXR1cm4gbmV3IExuZ0xhdCh0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXROb3J0aCgpKTtcbiAgfVxuICBnZXRTb3V0aEVhc3QoKSB7XG4gICAgcmV0dXJuIG5ldyBMbmdMYXQodGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0U291dGgoKSk7XG4gIH1cbiAgZ2V0V2VzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3cubG5nO1xuICB9XG4gIGdldFNvdXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdy5sYXQ7XG4gIH1cbiAgZ2V0RWFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmUubG5nO1xuICB9XG4gIGdldE5vcnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9uZS5sYXQ7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMuX3N3LnRvQXJyYXkoKSwgdGhpcy5fbmUudG9BcnJheSgpXTtcbiAgfVxuICB0b0ZsYXRBcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMuX3N3LmxuZywgdGhpcy5fc3cubGF0LCB0aGlzLl9uZS5sbmcsIHRoaXMuX25lLmxhdF07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBMbmdMYXRCb3VuZHMoJHt0aGlzLl9zdy50b1N0cmluZygpfSwgJHt0aGlzLl9uZS50b1N0cmluZygpfSlgO1xuICB9XG4gIHN0YXRpYyBjb252ZXJ0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMbmdMYXRCb3VuZHMgY29udmVydCB2YWx1ZTogZmFsc3lcIik7XG4gICAgfVxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIExuZ0xhdEJvdW5kcykge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXRCb3VuZHMoaW5wdXQuZ2V0U291dGhXZXN0KCksIGlucHV0LmdldE5vcnRoRWFzdCgpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXRCb3VuZHMoTG5nTGF0LmNvbnZlcnQoaW5wdXRbMF0pLCBMbmdMYXQuY29udmVydChpbnB1dFsxXSkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IExuZ0xhdEJvdW5kcyhMbmdMYXQuY29udmVydChbaW5wdXRbMF0sIGlucHV0WzFdXSksIExuZ0xhdC5jb252ZXJ0KFtpbnB1dFsyXSwgaW5wdXRbM11dKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImBMbmdMYXRCb3VuZHNMaWtlYCBhcmd1bWVudCBtdXN0IGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheSBbPExuZ0xhdExpa2U+LCA8TG5nTGF0TGlrZT5dIG9yIGFuIGFycmF5IFs8d2VzdD4sIDxzb3V0aD4sIDxlYXN0PiwgPG5vcnRoPl1cIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91dWlkLnRzXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gIGNvbnN0IHJhbmRvbVN0cmluZyA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpICsgRGF0ZS5ub3coKS50b1N0cmluZygxNikgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KTtcbiAgY29uc3QgdXVpZFN0cmluZyA9IHJhbmRvbVN0cmluZy5yZXBsYWNlKC9cXC4vZywgXCJcIik7XG4gIGNvbnN0IHV1aWQgPSBbXG4gICAgdXVpZFN0cmluZy5zbGljZSgwLCA4KSxcbiAgICB1dWlkU3RyaW5nLnNsaWNlKDgsIDEyKSxcbiAgICBcIjRcIiArIHV1aWRTdHJpbmcuc2xpY2UoMTIsIDE1KSArIFwiLThcIiArIHV1aWRTdHJpbmcuc2xpY2UoMTUsIDE4KSxcbiAgICB1dWlkU3RyaW5nLnNsaWNlKDE4LCAzMClcbiAgXS5qb2luKFwiLVwiKTtcbiAgcmV0dXJuIHV1aWQ7XG59XG5cbi8vIHNyYy9TZXNzaW9uVG9rZW4udHNcbnZhciBTZXNzaW9uVG9rZW4gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkICE9IG51bGwgPyBpZCA6IGdlbmVyYXRlVVVJRCgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIHN0YXRpYyBjb252ZXJ0KHRva2VuKSB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uVG9rZW4odG9rZW4gaW5zdGFuY2VvZiBTZXNzaW9uVG9rZW4gPyB0b2tlbi5pZCA6IHRva2VuLnRvU3RyaW5nKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvTWFwYm94RXJyb3IudHNcbnZhciBVTktOT1dOX0VSUk9SID0gXCJVbmtub3duIGVycm9yXCI7XG52YXIgTWFwYm94RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoanNvbiwgc3RhdHVzQ29kZSkge1xuICAgIHN1cGVyKFN0cmluZyhqc29uLm1lc3NhZ2UgfHwganNvbi5lcnJvciB8fCBVTktOT1dOX0VSUk9SKSk7XG4gICAgdGhpcy5uYW1lID0gXCJNYXBib3hFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubmFtZX0gKCR7dGhpcy5zdGF0dXNDb2RlfSk6ICR7dGhpcy5tZXNzYWdlfWA7XG4gIH1cbn07XG5mdW5jdGlvbiBoYW5kbGVOb25Pa1JlcyhyZXMpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QganNvbiA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICB0aHJvdyBuZXcgTWFwYm94RXJyb3IoanNvbiwgcmVzLnN0YXR1cyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2ZldGNoLnRzXG52YXIgX2ZldGNoSW1wbCA9IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgX2Fib3J0Q29udHJvbGxlckltcGwgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcjtcbmZ1bmN0aW9uIHBvbHlmaWxsRmV0Y2goeyBmZXRjaCwgQWJvcnRDb250cm9sbGVyIH0sIGZvcmNlID0gZmFsc2UpIHtcbiAgaWYgKCFmZXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZldGNoIGltcGxlbWVudGF0aW9uIG11c3QgaW5jbHVkZSBpbXBsZW1lbnRhdGlvbnMgb2YgYGZldGNoYC5cIik7XG4gIH1cbiAgaWYgKF9mZXRjaEltcGwgJiYgIWZvcmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9mZXRjaEltcGwgPSBmZXRjaDtcbiAgX2Fib3J0Q29udHJvbGxlckltcGwgPSBBYm9ydENvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgaWYgKCFfZmV0Y2hJbXBsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmV0Y2ggaW1wbGVtZW50YXRpb24gbm90IGZvdW5kLiBQbGVhc2UgaW5jbHVkZSBhIGZldGNoIHBvbHlmaWxsIGluIHlvdXIgYXBwbGljYXRpb24gb3IgdXNlIGBwb2x5ZmlsbEZldGNoYCBmcm9tIGBAbWFwYm94L3NlYXJjaC1qcy1jb3JlYCB0byBmaXggdGhpcyBpc3N1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmZXRjaDogX2ZldGNoSW1wbCxcbiAgICBBYm9ydENvbnRyb2xsZXI6IF9hYm9ydENvbnRyb2xsZXJJbXBsXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9xdWVyeVBhcmFtcy50c1xuZnVuY3Rpb24gcXVlcnlQYXJhbXMoLi4ub2JqZWN0cykge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGlmICghb2JqKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iaik7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcGFyYW1zLnB1c2goYCR7a2V5fT0ke2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcy5qb2luKFwiJlwiKTtcbn1cblxuLy8gc3JjL2F1dG9maWxsL0FkZHJlc3NBdXRvZmlsbENvcmUudHNcbnZhciBfZ2V0UXVlcnlQYXJhbXMsIGdldFF1ZXJ5UGFyYW1zX2ZuO1xudmFyIF9BZGRyZXNzQXV0b2ZpbGxDb3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldFF1ZXJ5UGFyYW1zKTtcbiAgICBjb25zdCBfYSA9IG9wdGlvbnMsIHsgYWNjZXNzVG9rZW4gfSA9IF9hLCBkZWZhdWx0cyA9IF9fb2JqUmVzdChfYSwgW1wiYWNjZXNzVG9rZW5cIl0pO1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICB0aGlzLmRlZmF1bHRzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIF9BZGRyZXNzQXV0b2ZpbGxDb3JlLmRlZmF1bHRzKSwgZGVmYXVsdHMpO1xuICB9XG4gIHN1Z2dlc3Qoc2VhcmNoVGV4dCwgb3B0aW9uc0FyZykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXNlYXJjaFRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VhcmNoVGV4dCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc2Vzc2lvblRva2VuLCBzaWduYWwgfSA9IG9wdGlvbnNBcmc7XG4gICAgICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5kZWZhdWx0cyksIG9wdGlvbnNBcmcpLCB7XG4gICAgICAgIHNlc3Npb25Ub2tlblxuICAgICAgfSk7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke1NVR0dFU1RfVVJMfS8ke2VuY29kZVVSSUNvbXBvbmVudChzZWFyY2hUZXh0KX1gKTtcbiAgICAgIHVybC5zZWFyY2ggPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFF1ZXJ5UGFyYW1zLCBnZXRRdWVyeVBhcmFtc19mbikuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgZmV0Y2ggfSA9IGdldEZldGNoKCk7XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgeWllbGQgaGFuZGxlTm9uT2tSZXMocmVzKTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGpzb24pLCB7XG4gICAgICAgIHN1Z2dlc3Rpb25zOiBqc29uLnN1Z2dlc3Rpb25zLm1hcCgoc3VnZ2VzdGlvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdWdnZXN0aW9uKSwge1xuICAgICAgICAgICAgb3JpZ2luYWxfc2VhcmNoX3RleHQ6IHNlYXJjaFRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIHVybDogdXJsLnRvU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHJpZXZlKHN1Z2dlc3Rpb24sIG9wdGlvbnNBcmcpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFzdWdnZXN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Z2dlc3Rpb24gaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FuUmV0cmlldmUoc3VnZ2VzdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3VnZ2VzdGlvbiBjYW5ub3QgYmUgcmV0cmlldmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBzZXNzaW9uVG9rZW46IHNlc3Npb25Ub2tlbkxpa2UsIHNpZ25hbCB9ID0gb3B0aW9uc0FyZztcbiAgICAgIGNvbnN0IHNlc3Npb25Ub2tlbiA9IFNlc3Npb25Ub2tlbi5jb252ZXJ0KHNlc3Npb25Ub2tlbkxpa2UpO1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtSRVRSSUVWRV9VUkx9LyR7c3VnZ2VzdGlvbi5hY3Rpb24uaWR9YCk7XG4gICAgICB1cmwuc2VhcmNoID0gcXVlcnlQYXJhbXMoe1xuICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICAgIHNlc3Npb25fdG9rZW46IHNlc3Npb25Ub2tlbi5pZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHsgc2lnbmFsIH0pO1xuICAgICAgeWllbGQgaGFuZGxlTm9uT2tSZXMocmVzKTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAganNvbi51cmwgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG4gIGNhblJldHJpZXZlKHN1Z2dlc3Rpb24pIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzdWdnZXN0aW9uLmFjdGlvbjtcbiAgICByZXR1cm4gdHlwZW9mIChhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbi5pZCkgPT09IFwic3RyaW5nXCI7XG4gIH1cbn07XG52YXIgQWRkcmVzc0F1dG9maWxsQ29yZSA9IF9BZGRyZXNzQXV0b2ZpbGxDb3JlO1xuX2dldFF1ZXJ5UGFyYW1zID0gbmV3IFdlYWtTZXQoKTtcbmdldFF1ZXJ5UGFyYW1zX2ZuID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gcXVlcnlQYXJhbXMoe1xuICAgIHR5cGVzOiBcImFkZHJlc3NcIixcbiAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgc3RyZWV0czogb3B0aW9ucy5zdHJlZXRzLFxuICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlLFxuICAgIGNvdW50cnk6IG9wdGlvbnMuY291bnRyeSxcbiAgICBsaW1pdDogb3B0aW9ucy5saW1pdFxuICB9LCBvcHRpb25zLnNlc3Npb25Ub2tlbiAmJiB7XG4gICAgc2Vzc2lvbl90b2tlbjogU2Vzc2lvblRva2VuLmNvbnZlcnQob3B0aW9ucy5zZXNzaW9uVG9rZW4pLmlkXG4gIH0sIG9wdGlvbnMucHJveGltaXR5ICYmIHtcbiAgICBwcm94aW1pdHk6IHR5cGVvZiBvcHRpb25zLnByb3hpbWl0eSA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMucHJveGltaXR5IDogTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5wcm94aW1pdHkpLnRvQXJyYXkoKS5qb2luKFwiLFwiKVxuICB9LCBvcHRpb25zLmJib3ggJiYge1xuICAgIGJib3g6IHR5cGVvZiBvcHRpb25zLmJib3ggPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmJib3ggOiBMbmdMYXRCb3VuZHMuY29udmVydChvcHRpb25zLmJib3gpLnRvRmxhdEFycmF5KCkuam9pbihcIixcIilcbiAgfSk7XG59O1xuQWRkcmVzc0F1dG9maWxsQ29yZS5kZWZhdWx0cyA9IHtcbiAgbGFuZ3VhZ2U6IFwiZW5cIixcbiAgcHJveGltaXR5OiBcImlwXCIsXG4gIHN0cmVldHM6IHRydWVcbn07XG5cbi8vIHNyYy9zZWFyY2hib3gvY29uc3RhbnRzLnRzXG52YXIgU0VBUkNIX1VSTDIgPSBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zZWFyY2gvc2VhcmNoYm94L3YxYDtcbnZhciBFTkRQT0lOVF9TVUdHRVNUMiA9IFwic3VnZ2VzdFwiO1xudmFyIEVORFBPSU5UX1JFVFJJRVZFMiA9IFwicmV0cmlldmVcIjtcbnZhciBFTkRQT0lOVF9DQVRFR09SWSA9IFwiY2F0ZWdvcnlcIjtcbnZhciBFTkRQT0lOVF9SRVZFUlNFID0gXCJyZXZlcnNlXCI7XG52YXIgU1VHR0VTVF9VUkwyID0gYCR7U0VBUkNIX1VSTDJ9LyR7RU5EUE9JTlRfU1VHR0VTVDJ9YDtcbnZhciBSRVRSSUVWRV9VUkwyID0gYCR7U0VBUkNIX1VSTDJ9LyR7RU5EUE9JTlRfUkVUUklFVkUyfWA7XG52YXIgQ0FURUdPUllfVVJMID0gYCR7U0VBUkNIX1VSTDJ9LyR7RU5EUE9JTlRfQ0FURUdPUll9YDtcbnZhciBSRVZFUlNFX1VSTCA9IGAke1NFQVJDSF9VUkwyfS8ke0VORFBPSU5UX1JFVkVSU0V9YDtcblxuLy8gc3JjL3NlYXJjaGJveC9TZWFyY2hCb3hDb3JlLnRzXG52YXIgX2dldFF1ZXJ5UGFyYW1zMiwgZ2V0UXVlcnlQYXJhbXNfZm4yO1xudmFyIF9TZWFyY2hCb3hDb3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldFF1ZXJ5UGFyYW1zMik7XG4gICAgY29uc3QgX2EgPSBvcHRpb25zLCB7IGFjY2Vzc1Rva2VuIH0gPSBfYSwgZGVmYXVsdHMgPSBfX29ialJlc3QoX2EsIFtcImFjY2Vzc1Rva2VuXCJdKTtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgdGhpcy5kZWZhdWx0cyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfU2VhcmNoQm94Q29yZS5kZWZhdWx0cyksIGRlZmF1bHRzKTtcbiAgfVxuICBzdWdnZXN0KHNlYXJjaFRleHQsIG9wdGlvbnNBcmcpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFzZWFyY2hUZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlYXJjaFRleHQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHNlc3Npb25Ub2tlbiwgc2lnbmFsIH0gPSBvcHRpb25zQXJnO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZGVmYXVsdHMpLCBvcHRpb25zQXJnKSwge1xuICAgICAgICBxOiBzZWFyY2hUZXh0LFxuICAgICAgICBzZXNzaW9uVG9rZW5cbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuZXRhX3R5cGUgJiYgKCFvcHRpb25zLm9yaWdpbiB8fCAhb3B0aW9ucy5uYXZpZ2F0aW9uX3Byb2ZpbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvIHByb3ZpZGUgZXRhIGVzdGltYXRlOiBldGEsIG5hdmlnYXRpb25fcHJvZmlsZSwgYW5kIG9yaWdpbiBhcmUgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW4gJiYgIW9wdGlvbnMubmF2aWdhdGlvbl9wcm9maWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvIHByb3ZpZGUgZGlzdGFuY2UgZXN0aW1hdGU6IGJvdGggbmF2aWdhdGlvbl9wcm9maWxlIGFuZCBvcmlnaW4gYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChTVUdHRVNUX1VSTDIpO1xuICAgICAgdXJsLnNlYXJjaCA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UXVlcnlQYXJhbXMyLCBnZXRRdWVyeVBhcmFtc19mbjIpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIGhhbmRsZU5vbk9rUmVzKHJlcyk7XG4gICAgICBjb25zdCBqc29uID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgIGpzb24udXJsID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9KTtcbiAgfVxuICByZXRyaWV2ZShzdWdnZXN0aW9uLCBvcHRpb25zQXJnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghc3VnZ2VzdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWdnZXN0aW9uIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBzZXNzaW9uVG9rZW46IHNlc3Npb25Ub2tlbkxpa2UsIHNpZ25hbCB9ID0gb3B0aW9uc0FyZztcbiAgICAgIGNvbnN0IHNlc3Npb25Ub2tlbiA9IFNlc3Npb25Ub2tlbi5jb252ZXJ0KHNlc3Npb25Ub2tlbkxpa2UpO1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtSRVRSSUVWRV9VUkwyfS8ke2VuY29kZVVSSUNvbXBvbmVudChzdWdnZXN0aW9uLm1hcGJveF9pZCl9YCk7XG4gICAgICB1cmwuc2VhcmNoID0gcXVlcnlQYXJhbXMoe1xuICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICAgIHNlc3Npb25fdG9rZW46IHNlc3Npb25Ub2tlbi5pZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIGhhbmRsZU5vbk9rUmVzKHJlcyk7XG4gICAgICBjb25zdCBqc29uID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgIGpzb24udXJsID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9KTtcbiAgfVxuICBjYXRlZ29yeShfMCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIChjYXRlZ29yeSwgb3B0aW9uc0FyZyA9IHt9KSB7XG4gICAgICBpZiAoIWNhdGVnb3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhdGVnb3J5IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmRlZmF1bHRzKSwgb3B0aW9uc0FyZyk7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke0NBVEVHT1JZX1VSTH0vJHtlbmNvZGVVUklDb21wb25lbnQoY2F0ZWdvcnkpfWApO1xuICAgICAgdXJsLnNlYXJjaCA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UXVlcnlQYXJhbXMyLCBnZXRRdWVyeVBhcmFtc19mbjIpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICB5aWVsZCBoYW5kbGVOb25Pa1JlcyhyZXMpO1xuICAgICAgY29uc3QganNvbiA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICBqc29uLnVybCA9IHVybC50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSk7XG4gIH1cbiAgcmV2ZXJzZShfMCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIChsbmdMYXQsIG9wdGlvbnNBcmcgPSB7fSkge1xuICAgICAgaWYgKCFsbmdMYXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG5nTGF0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgW2xuZywgbGF0XSA9IHR5cGVvZiBsbmdMYXQgPT09IFwic3RyaW5nXCIgPyBsbmdMYXQuc3BsaXQoXCIsXCIpLm1hcCgoeCkgPT4gcGFyc2VGbG9hdCh4KSkgOiBMbmdMYXQuY29udmVydChsbmdMYXQpLnRvQXJyYXkoKTtcbiAgICAgIGlmIChpc05hTihsbmcpIHx8IGlzTmFOKGxhdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG5nTGF0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmRlZmF1bHRzKSwgb3B0aW9uc0FyZyk7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFJFVkVSU0VfVVJMKTtcbiAgICAgIHVybC5zZWFyY2ggPSBxdWVyeVBhcmFtcyh7XG4gICAgICAgIGFjY2Vzc190b2tlbjogdGhpcy5hY2Nlc3NUb2tlbixcbiAgICAgICAgbGFuZ3VhZ2U6IG9wdGlvbnMubGFuZ3VhZ2UsXG4gICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgICAgICBsb25naXR1ZGU6IGxuZyxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdFxuICAgICAgfSwgb3B0aW9ucy50eXBlcyAmJiB7XG4gICAgICAgIHR5cGVzOiB0eXBlb2Ygb3B0aW9ucy50eXBlcyA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMudHlwZXMgOiBbLi4ub3B0aW9ucy50eXBlc10uam9pbihcIixcIilcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBmZXRjaCB9ID0gZ2V0RmV0Y2goKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgeWllbGQgaGFuZGxlTm9uT2tSZXMocmVzKTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAganNvbi51cmwgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG59O1xudmFyIFNlYXJjaEJveENvcmUgPSBfU2VhcmNoQm94Q29yZTtcbl9nZXRRdWVyeVBhcmFtczIgPSBuZXcgV2Vha1NldCgpO1xuZ2V0UXVlcnlQYXJhbXNfZm4yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gcXVlcnlQYXJhbXMoe1xuICAgIHE6IG9wdGlvbnMucSxcbiAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgbGFuZ3VhZ2U6IG9wdGlvbnMubGFuZ3VhZ2UsXG4gICAgbGltaXQ6IG9wdGlvbnMubGltaXQsXG4gICAgbmF2aWdhdGlvbl9wcm9maWxlOiBvcHRpb25zLm5hdmlnYXRpb25fcHJvZmlsZSxcbiAgICByb3V0ZTogb3B0aW9ucy5yb3V0ZSxcbiAgICByb3V0ZV9nZW9tZXRyeTogb3B0aW9ucy5yb3V0ZV9nZW9tZXRyeSxcbiAgICBzYXJfdHlwZTogb3B0aW9ucy5zYXJfdHlwZSxcbiAgICB0aW1lX2RldmlhdGlvbjogb3B0aW9ucy50aW1lX2RldmlhdGlvbixcbiAgICBldGFfdHlwZTogb3B0aW9ucy5ldGFfdHlwZSxcbiAgICBjb3VudHJ5OiBvcHRpb25zLmNvdW50cnksXG4gICAgcG9pX2NhdGVnb3J5OiBvcHRpb25zLnBvaV9jYXRlZ29yeSxcbiAgICByYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuICAgIHVzZXJfaWQ6IG9wdGlvbnMudXNlcl9pZCxcbiAgICByaWNoX21ldGFkYXRhX3Byb3ZpZGVyOiBvcHRpb25zLnJpY2hfbWV0YWRhdGFfcHJvdmlkZXIsXG4gICAgcG9pX2NhdGVnb3J5X2V4Y2x1c2lvbnM6IG9wdGlvbnMucG9pX2NhdGVnb3J5X2V4Y2x1c2lvbnNcbiAgfSwgb3B0aW9ucy5zZXNzaW9uVG9rZW4gJiYge1xuICAgIHNlc3Npb25fdG9rZW46IFNlc3Npb25Ub2tlbi5jb252ZXJ0KG9wdGlvbnMuc2Vzc2lvblRva2VuKS5pZFxuICB9LCBvcHRpb25zLnByb3hpbWl0eSAmJiB7XG4gICAgcHJveGltaXR5OiB0eXBlb2Ygb3B0aW9ucy5wcm94aW1pdHkgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLnByb3hpbWl0eSA6IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMucHJveGltaXR5KS50b0FycmF5KCkuam9pbihcIixcIilcbiAgfSwgb3B0aW9ucy5vcmlnaW4gJiYge1xuICAgIG9yaWdpbjogdHlwZW9mIG9wdGlvbnMub3JpZ2luID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5vcmlnaW4gOiBMbmdMYXQuY29udmVydChvcHRpb25zLm9yaWdpbikudG9BcnJheSgpLmpvaW4oXCIsXCIpXG4gIH0sIG9wdGlvbnMuYmJveCAmJiB7XG4gICAgYmJveDogdHlwZW9mIG9wdGlvbnMuYmJveCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuYmJveCA6IExuZ0xhdEJvdW5kcy5jb252ZXJ0KG9wdGlvbnMuYmJveCkudG9GbGF0QXJyYXkoKS5qb2luKFwiLFwiKVxuICB9LCBvcHRpb25zLnR5cGVzICYmIHtcbiAgICB0eXBlczogdHlwZW9mIG9wdGlvbnMudHlwZXMgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLnR5cGVzIDogWy4uLm9wdGlvbnMudHlwZXNdLmpvaW4oXCIsXCIpXG4gIH0pO1xufTtcblNlYXJjaEJveENvcmUuZGVmYXVsdHMgPSB7XG4gIGxhbmd1YWdlOiBcImVuXCJcbn07XG5cbi8vIHNyYy92YWxpZGF0ZS9jb25zdGFudHMudHNcbnZhciBTRUFSQ0hfVVJMMyA9IGBodHRwczovL2FwaS5tYXBib3guY29tL2F1dG9maWxsL3YxYDtcbnZhciBFTkRQT0lOVF9WQUxJREFURSA9IFwicmV0cmlldmVcIjtcbnZhciBWQUxJREFURV9VUkwgPSBgJHtTRUFSQ0hfVVJMM30vJHtFTkRQT0lOVF9WQUxJREFURX1gO1xuXG4vLyBzcmMvdmFsaWRhdGUvVmFsaWRhdGlvbkNvcmUudHNcbnZhciBfZ2V0UXVlcnlQYXJhbXMzLCBnZXRRdWVyeVBhcmFtc19mbjM7XG52YXIgX1ZhbGlkYXRpb25Db3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldFF1ZXJ5UGFyYW1zMyk7XG4gICAgY29uc3QgX2EgPSBvcHRpb25zLCB7IGFjY2Vzc1Rva2VuIH0gPSBfYSwgZGVmYXVsdHMgPSBfX29ialJlc3QoX2EsIFtcImFjY2Vzc1Rva2VuXCJdKTtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgdGhpcy5kZWZhdWx0cyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfVmFsaWRhdGlvbkNvcmUuZGVmYXVsdHMpLCBkZWZhdWx0cyk7XG4gIH1cbiAgdmFsaWRhdGUoc2VhcmNoVGV4dCwgb3B0aW9uc0FyZykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXNlYXJjaFRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VhcmNoVGV4dCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc2Vzc2lvblRva2VuLCBzaWduYWwgfSA9IG9wdGlvbnNBcmc7XG4gICAgICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5kZWZhdWx0cyksIG9wdGlvbnNBcmcpLCB7XG4gICAgICAgIHNlc3Npb25Ub2tlblxuICAgICAgfSk7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke1ZBTElEQVRFX1VSTH0vJHtlbmNvZGVVUklDb21wb25lbnQoc2VhcmNoVGV4dCl9YCk7XG4gICAgICB1cmwuc2VhcmNoID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRRdWVyeVBhcmFtczMsIGdldFF1ZXJ5UGFyYW1zX2ZuMykuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgZmV0Y2ggfSA9IGdldEZldGNoKCk7XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgeWllbGQgaGFuZGxlTm9uT2tSZXMocmVzKTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAganNvbi51cmwgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIGlmIChqc29uLmZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAganNvbi5mZWF0dXJlcyA9IFtqc29uLmZlYXR1cmVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG59O1xudmFyIFZhbGlkYXRpb25Db3JlID0gX1ZhbGlkYXRpb25Db3JlO1xuX2dldFF1ZXJ5UGFyYW1zMyA9IG5ldyBXZWFrU2V0KCk7XG5nZXRRdWVyeVBhcmFtc19mbjMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBxdWVyeVBhcmFtcyh7XG4gICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlLFxuICAgIGNvdW50cnk6IG9wdGlvbnMuY291bnRyeVxuICB9LCBvcHRpb25zLnNlc3Npb25Ub2tlbiAmJiB7XG4gICAgc2Vzc2lvbl90b2tlbjogU2Vzc2lvblRva2VuLmNvbnZlcnQob3B0aW9ucy5zZXNzaW9uVG9rZW4pLmlkXG4gIH0sIG9wdGlvbnMucHJveGltaXR5ICYmIHtcbiAgICBwcm94aW1pdHk6IHR5cGVvZiBvcHRpb25zLnByb3hpbWl0eSA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMucHJveGltaXR5IDogTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5wcm94aW1pdHkpLnRvQXJyYXkoKS5qb2luKFwiLFwiKVxuICB9LCBvcHRpb25zLmJib3ggJiYge1xuICAgIGJib3g6IHR5cGVvZiBvcHRpb25zLmJib3ggPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmJib3ggOiBMbmdMYXRCb3VuZHMuY29udmVydChvcHRpb25zLmJib3gpLnRvRmxhdEFycmF5KCkuam9pbihcIixcIilcbiAgfSk7XG59O1xuVmFsaWRhdGlvbkNvcmUuZGVmYXVsdHMgPSB7XG4gIGxhbmd1YWdlOiBcImVuXCIsXG4gIHByb3hpbWl0eTogXCJpcFwiXG59O1xuXG4vLyBzcmMvZ2VvY29kZS9jb25zdGFudHMudHNcbnZhciBCQVNFX1VSTCA9IGBodHRwczovL2FwaS5tYXBib3guY29tL3NlYXJjaC9nZW9jb2RlL3Y2YDtcbnZhciBGT1JXQVJEX1VSTCA9IGAke0JBU0VfVVJMfS9mb3J3YXJkYDtcbnZhciBSRVZFUlNFX1VSTDIgPSBgJHtCQVNFX1VSTH0vcmV2ZXJzZWA7XG52YXIgQkFUQ0hfVVJMID0gYCR7QkFTRV9VUkx9L2JhdGNoYDtcblxuLy8gc3JjL2dlb2NvZGUvR2VvY29kaW5nQ29yZS50c1xudmFyIFJFVkVSU0VfR0VPQ09ERV9DT09SRF9SRUdFWCA9IC9eWyBdKigtP1xcZHsxLDN9KFxcLlxcZHswLDI1Nn0pPylbLCBdKygtP1xcZHsxLDN9KFxcLlxcZHswLDI1Nn0pPylbIF0qJC87XG52YXIgU1BBQ0VTX09SX0NPTU1BX1JFR0VYID0gL1tcXHMsXSsvO1xudmFyIF9nZXRRdWVyeVBhcmFtczQsIGdldFF1ZXJ5UGFyYW1zX2ZuNDtcbnZhciBHZW9jb2RpbmdDb3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldFF1ZXJ5UGFyYW1zNCk7XG4gICAgY29uc3QgX2EgPSBvcHRpb25zLCB7IGFjY2Vzc1Rva2VuIH0gPSBfYSwgZGVmYXVsdHMgPSBfX29ialJlc3QoX2EsIFtcImFjY2Vzc1Rva2VuXCJdKTtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgdGhpcy5kZWZhdWx0cyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0cyk7XG4gIH1cbiAgZm9yd2FyZChzZWFyY2hUZXh0LCBvcHRpb25zQXJnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghc2VhcmNoVGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWFyY2hUZXh0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHNpZ25hbDtcbiAgICAgIGlmIChvcHRpb25zQXJnKSB7XG4gICAgICAgICh7IHNpZ25hbCB9ID0gb3B0aW9uc0FyZyk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5kZWZhdWx0cyksIG9wdGlvbnNBcmcpLCB7XG4gICAgICAgIHE6IHNlYXJjaFRleHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtGT1JXQVJEX1VSTH1gKTtcbiAgICAgIHVybC5zZWFyY2ggPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFF1ZXJ5UGFyYW1zNCwgZ2V0UXVlcnlQYXJhbXNfZm40KS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgeyBmZXRjaCB9ID0gZ2V0RmV0Y2goKTtcbiAgICAgIGNvbnN0IGZldGNoSW5pdCA9IHNpZ25hbCA/IHsgc2lnbmFsIH0gOiB7fTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCBmZXRjaEluaXQpO1xuICAgICAgeWllbGQgaGFuZGxlTm9uT2tSZXMocmVzKTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAganNvbi51cmwgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG4gIHJldmVyc2UobG5nTGF0LCBvcHRpb25zQXJnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghbG5nTGF0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImxuZ0xhdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBzaWduYWw7XG4gICAgICBpZiAob3B0aW9uc0FyZykge1xuICAgICAgICAoeyBzaWduYWwgfSA9IG9wdGlvbnNBcmcpO1xuICAgICAgfVxuICAgICAgbGV0IGxuZ0xhdE9iajtcbiAgICAgIGlmICh0eXBlb2YgbG5nTGF0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IFtsbmcsIGxhdF0gPSBsbmdMYXQuc3BsaXQoXCIsXCIpO1xuICAgICAgICBsbmdMYXRPYmogPSBuZXcgTG5nTGF0KE51bWJlcihsbmcpLCBOdW1iZXIobGF0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbmdMYXRPYmogPSBMbmdMYXQuY29udmVydChsbmdMYXQpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZGVmYXVsdHMpLCBvcHRpb25zQXJnKSwge1xuICAgICAgICBsb25naXR1ZGU6IGxuZ0xhdE9iai5sbmcsXG4gICAgICAgIGxhdGl0dWRlOiBsbmdMYXRPYmoubGF0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7UkVWRVJTRV9VUkwyfWApO1xuICAgICAgdXJsLnNlYXJjaCA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UXVlcnlQYXJhbXM0LCBnZXRRdWVyeVBhcmFtc19mbjQpLmNhbGwodGhpcywgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgZmV0Y2hJbml0ID0gc2lnbmFsID8geyBzaWduYWwgfSA6IHt9O1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIGZldGNoSW5pdCk7XG4gICAgICB5aWVsZCBoYW5kbGVOb25Pa1JlcyhyZXMpO1xuICAgICAgY29uc3QganNvbiA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICBqc29uLnVybCA9IHVybC50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSk7XG4gIH1cbiAgc3VnZ2VzdChzZWFyY2hUZXh0LCBvcHRpb25zQXJnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGlzUmV2ZXJzZVF1ZXJ5ID0gUkVWRVJTRV9HRU9DT0RFX0NPT1JEX1JFR0VYLnRlc3Qoc2VhcmNoVGV4dCk7XG4gICAgICBpZiAoaXNSZXZlcnNlUXVlcnkpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBzZWFyY2hUZXh0LnRyaW0oKS5zcGxpdChTUEFDRVNfT1JfQ09NTUFfUkVHRVgpLm1hcCgocGFydCkgPT4gcGFydC50cmltKCkpLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKGNvb3JkaW5hdGVzLCBvcHRpb25zQXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcndhcmQoc2VhcmNoVGV4dCwgb3B0aW9uc0FyZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0cmlldmUoc3VnZ2VzdGlvbikge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gc3VnZ2VzdGlvbjtcbiAgICB9KTtcbiAgfVxufTtcbl9nZXRRdWVyeVBhcmFtczQgPSBuZXcgV2Vha1NldCgpO1xuZ2V0UXVlcnlQYXJhbXNfZm40ID0gZnVuY3Rpb24ob3B0aW9ucywgaXNSZXZlcnNlID0gZmFsc2UpIHtcbiAgaWYgKGlzUmV2ZXJzZSkge1xuICAgIFtcInByb3hpbWl0eVwiLCBcImF1dG9jb21wbGV0ZVwiLCBcImJib3hcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcXVlcnlQYXJhbXMoe1xuICAgIHE6IG9wdGlvbnMucSxcbiAgICBsb25naXR1ZGU6IG9wdGlvbnMubG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlOiBvcHRpb25zLmxhdGl0dWRlLFxuICAgIGFjY2Vzc190b2tlbjogdGhpcy5hY2Nlc3NUb2tlbixcbiAgICBwZXJtYW5lbnQ6IG9wdGlvbnMucGVybWFuZW50LFxuICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlLFxuICAgIGNvdW50cnk6IG9wdGlvbnMuY291bnRyeSxcbiAgICBsaW1pdDogb3B0aW9ucy5saW1pdCxcbiAgICBhdXRvY29tcGxldGU6IG9wdGlvbnMuYXV0b2NvbXBsZXRlLFxuICAgIHdvcmxkdmlldzogb3B0aW9ucy53b3JsZHZpZXdcbiAgfSwgb3B0aW9ucy5wcm94aW1pdHkgJiYge1xuICAgIHByb3hpbWl0eTogdHlwZW9mIG9wdGlvbnMucHJveGltaXR5ID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5wcm94aW1pdHkgOiBMbmdMYXQuY29udmVydChvcHRpb25zLnByb3hpbWl0eSkudG9BcnJheSgpLmpvaW4oXCIsXCIpXG4gIH0sIG9wdGlvbnMuYmJveCAmJiB7XG4gICAgYmJveDogdHlwZW9mIG9wdGlvbnMuYmJveCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuYmJveCA6IExuZ0xhdEJvdW5kcy5jb252ZXJ0KG9wdGlvbnMuYmJveCkudG9GbGF0QXJyYXkoKS5qb2luKFwiLFwiKVxuICB9LCBvcHRpb25zLnR5cGVzICYmIHtcbiAgICB0eXBlczogdHlwZW9mIG9wdGlvbnMudHlwZXMgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLnR5cGVzIDogWy4uLm9wdGlvbnMudHlwZXNdLmpvaW4oXCIsXCIpXG4gIH0pO1xufTtcblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgTWF0Y2hDb2RlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE1hdGNoQ29kZVR5cGUyKSA9PiB7XG4gIE1hdGNoQ29kZVR5cGUyW1wibWF0Y2hlZFwiXSA9IFwibWF0Y2hlZFwiO1xuICBNYXRjaENvZGVUeXBlMltcInVubWF0Y2hlZFwiXSA9IFwidW5tYXRjaGVkXCI7XG4gIE1hdGNoQ29kZVR5cGUyW1wicGxhdXNpYmxlXCJdID0gXCJwbGF1c2libGVcIjtcbiAgTWF0Y2hDb2RlVHlwZTJbXCJub3RfYXBwbGljYWJsZVwiXSA9IFwibm90X2FwcGxpY2FibGVcIjtcbiAgTWF0Y2hDb2RlVHlwZTJbXCJpbmZlcnJlZFwiXSA9IFwiaW5mZXJyZWRcIjtcbiAgcmV0dXJuIE1hdGNoQ29kZVR5cGUyO1xufSkoTWF0Y2hDb2RlVHlwZSB8fCB7fSk7XG52YXIgTWF0Y2hDb2RlQ29uZmlkZW5jZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE1hdGNoQ29kZUNvbmZpZGVuY2UyKSA9PiB7XG4gIE1hdGNoQ29kZUNvbmZpZGVuY2UyW1wiZXhhY3RcIl0gPSBcImV4YWN0XCI7XG4gIE1hdGNoQ29kZUNvbmZpZGVuY2UyW1wiaGlnaFwiXSA9IFwiaGlnaFwiO1xuICBNYXRjaENvZGVDb25maWRlbmNlMltcIm1lZGl1bVwiXSA9IFwibWVkaXVtXCI7XG4gIE1hdGNoQ29kZUNvbmZpZGVuY2UyW1wibG93XCJdID0gXCJsb3dcIjtcbiAgcmV0dXJuIE1hdGNoQ29kZUNvbmZpZGVuY2UyO1xufSkoTWF0Y2hDb2RlQ29uZmlkZW5jZSB8fCB7fSk7XG5cbi8vIHNyYy91dGlscy9FdmVudGVkLnRzXG52YXIgX2xpc3RlbmVycztcbnZhciBFdmVudGVkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2xpc3RlbmVycywge30pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnNBcnIgPSBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3RlbmVycyk7XG4gICAgaWYgKCFsaXN0ZW5lcnNBcnJbdHlwZV0pIHtcbiAgICAgIGxpc3RlbmVyc0Fyclt0eXBlXSA9IFtdO1xuICAgIH1cbiAgICBsaXN0ZW5lcnNBcnJbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyc0FyciA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGVuZXJzKTtcbiAgICBpZiAoIWxpc3RlbmVyc0Fyclt0eXBlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNBcnJbdHlwZV07XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIGZpcmUodHlwZSwgYXJnMCkge1xuICAgIGNvbnN0IGxpc3RlbmVyc0FyciA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGVuZXJzKTtcbiAgICBpZiAoIWxpc3RlbmVyc0Fyclt0eXBlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNBcnJbdHlwZV07XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGFyZzApO1xuICAgIH1cbiAgfVxufTtcbl9saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBzcmMvdXRpbHMvZGVib3VuY2UudHNcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHNpZ25hbEZuKSB7XG4gIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gc2lnbmFsRm4gJiYgc2lnbmFsRm4oKTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG59XG5cbi8vIHNyYy9TZWFyY2hTZXNzaW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKSB7XG4gIGNvbnN0IHsgQWJvcnRDb250cm9sbGVyIH0gPSBnZXRGZXRjaCgpO1xuICByZXR1cm4gbmV3IEFib3J0Q29udHJvbGxlcigpO1xufVxudmFyIF9zdWdnZXN0aW9ucywgX2Fib3J0LCBfc3VnZ2VzdERlYm91bmNlO1xudmFyIFNlYXJjaFNlc3Npb24gPSBjbGFzcyBleHRlbmRzIEV2ZW50ZWQge1xuICBjb25zdHJ1Y3RvcihzZWFyY2gsIHdhaXQgPSAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IG5ldyBTZXNzaW9uVG9rZW4oKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N1Z2dlc3Rpb25zLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWJvcnQsIGNyZWF0ZUFib3J0Q29udHJvbGxlcigpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N1Z2dlc3REZWJvdW5jZSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3N1Z2dlc3REZWJvdW5jZSwgZGVib3VuY2UoKF8wLCAuLi5fMSkgPT4gX19hc3luYyh0aGlzLCBbXzAsIC4uLl8xXSwgZnVuY3Rpb24qIChzZWFyY2hUZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWJvcnQpLmFib3J0KCk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Fib3J0LCBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKSk7XG4gICAgICBpZiAoIXNlYXJjaFRleHQpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9zdWdnZXN0aW9ucywgbnVsbCk7XG4gICAgICAgIHRoaXMuZmlyZShcInN1Z2dlc3RcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9zdWdnZXN0aW9ucykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLnNlYXJjaC5zdWdnZXN0KHNlYXJjaFRleHQsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIHNlc3Npb25Ub2tlbjogdGhpcy5zZXNzaW9uVG9rZW5cbiAgICAgICAgfSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBzaWduYWw6IF9fcHJpdmF0ZUdldCh0aGlzLCBfYWJvcnQpLnNpZ25hbFxuICAgICAgICB9KSk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc3VnZ2VzdGlvbnMsIHJlcyk7XG4gICAgICAgIHRoaXMuZmlyZShcInN1Z2dlc3RcIiwgcmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZShcInN1Z2dlc3RlcnJvclwiLCBlcnIpO1xuICAgICAgfVxuICAgIH0pLCB3YWl0LCAoKSA9PiBfX3ByaXZhdGVHZXQodGhpcywgX2Fib3J0KS5zaWduYWwpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBzZWFyY2g6IHtcbiAgICAgICAgdmFsdWU6IHNlYXJjaCxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZGVib3VuY2U6IHtcbiAgICAgICAgdmFsdWU6IHdhaXQsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBzdWdnZXN0aW9ucygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zdWdnZXN0aW9ucyk7XG4gIH1cbiAgc3VnZ2VzdChzZWFyY2hUZXh0LCBvcHRpb25zKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdWdnZXN0RGVib3VuY2UpLmNhbGwodGhpcywgc2VhcmNoVGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdWdnZXN0Rm47XG4gICAgICBsZXQgc3VnZ2VzdEVycm9yRm47XG4gICAgICBzdWdnZXN0Rm4gPSAocmVzKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RcIiwgc3VnZ2VzdEZuKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIHN1Z2dlc3RFcnJvckZuKTtcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfTtcbiAgICAgIHN1Z2dlc3RFcnJvckZuID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIHN1Z2dlc3RGbik7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBzdWdnZXN0RXJyb3JGbik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RcIiwgc3VnZ2VzdEZuKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBzdWdnZXN0RXJyb3JGbik7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zdWdnZXN0KFwiXCIpO1xuICB9XG4gIHJldHJpZXZlKHN1Z2dlc3Rpb24sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5zZWFyY2gucmV0cmlldmUoc3VnZ2VzdGlvbiwgX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBzZXNzaW9uVG9rZW46IHRoaXMuc2Vzc2lvblRva2VuXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgICB0aGlzLmZpcmUoXCJyZXRyaWV2ZVwiLCByZXMpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxuICBjYW5SZXRyaWV2ZShzdWdnZXN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLnNlYXJjaC5jYW5SZXRyaWV2ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlYXJjaC5jYW5SZXRyaWV2ZShzdWdnZXN0aW9uKTtcbiAgfVxuICBjYW5TdWdnZXN0KHN1Z2dlc3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuc2VhcmNoLmNhblN1Z2dlc3QpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZWFyY2guY2FuU3VnZ2VzdChzdWdnZXN0aW9uKTtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2Fib3J0KS5hYm9ydCgpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYWJvcnQsIGNyZWF0ZUFib3J0Q29udHJvbGxlcigpKTtcbiAgfVxufTtcbl9zdWdnZXN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5fYWJvcnQgPSBuZXcgV2Vha01hcCgpO1xuX3N1Z2dlc3REZWJvdW5jZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIHNyYy9mZWF0dXJlVG9TdWdnZXN0aW9uLnRzXG5mdW5jdGlvbiBmZWF0dXJlVG9TdWdnZXN0aW9uKGZlYXR1cmUpIHtcbiAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBmZWF0dXJlO1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe30sIHByb3BlcnRpZXMpO1xufVxuZXhwb3J0IHtcbiAgQWRkcmVzc0F1dG9maWxsQ29yZSxcbiAgRXZlbnRlZCxcbiAgR2VvY29kaW5nQ29yZSxcbiAgTG5nTGF0LFxuICBMbmdMYXRCb3VuZHMsXG4gIEFkZHJlc3NBdXRvZmlsbENvcmUgYXMgTWFwYm94QXV0b2ZpbGwsXG4gIE1hcGJveEVycm9yLFxuICBHZW9jb2RpbmdDb3JlIGFzIE1hcGJveEdlb2NvZGUsXG4gIFZhbGlkYXRpb25Db3JlIGFzIE1hcGJveFZhbGlkYXRlLFxuICBNYXRjaENvZGVDb25maWRlbmNlLFxuICBNYXRjaENvZGVUeXBlLFxuICBTZWFyY2hCb3hDb3JlLFxuICBTZWFyY2hTZXNzaW9uLFxuICBTZXNzaW9uVG9rZW4sXG4gIFZhbGlkYXRpb25Db3JlLFxuICBkZWJvdW5jZSxcbiAgZmVhdHVyZVRvU3VnZ2VzdGlvbixcbiAgcG9seWZpbGxGZXRjaFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LWVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-core/dist/index-esm.js\n"));

/***/ }),

/***/ "./node_modules/@mapbox/search-js-react/dist/index-esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-react/dist/index-esm.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressAutofill: function() { return /* binding */ AddressAutofill; },\n/* harmony export */   AddressMinimap: function() { return /* binding */ AddressMinimap; },\n/* harmony export */   Geocoder: function() { return /* binding */ Geocoder; },\n/* harmony export */   SearchBox: function() { return /* binding */ SearchBox; },\n/* harmony export */   config: function() { return /* reexport safe */ _mapbox_search_js_web__WEBPACK_IMPORTED_MODULE_0__.config; },\n/* harmony export */   useAddressAutofillCore: function() { return /* binding */ useAddressAutofillCore; },\n/* harmony export */   useConfirmAddress: function() { return /* binding */ useConfirmAddress; },\n/* harmony export */   useEvented: function() { return /* binding */ useEvented; },\n/* harmony export */   useGeocodingCore: function() { return /* binding */ useGeocodingCore; },\n/* harmony export */   useMapboxAutofill: function() { return /* binding */ useAddressAutofillCore; },\n/* harmony export */   useSearchBoxCore: function() { return /* binding */ useSearchBoxCore; },\n/* harmony export */   useSearchSession: function() { return /* binding */ useSearchSession; }\n/* harmony export */ });\n/* harmony import */ var _mapbox_search_js_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/search-js-web */ \"./node_modules/@mapbox/search-js-web/dist/index-esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mapbox/search-js-core */ \"./node_modules/@mapbox/search-js-core/dist/index-esm.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/index.ts\n\n\n\n// src/components/AddressAutofill.tsx\n\nvar AddressAutofill = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, refProp) => {\n  const {\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    confirmOnBrowserAutofill,\n    browserAutofillEnabled,\n    children,\n    onChange,\n    onSuggest,\n    onSuggestError,\n    onRetrieve,\n    interceptSearch\n  } = props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(refProp, () => ({\n    focus: () => {\n      if (ref.current)\n        return ref.current.focus();\n      throw new Error(\"AddressAutofill is not mounted\");\n    }\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.options = options;\n  }, [ref.current, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.interceptSearch = interceptSearch;\n  }, [ref.current, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.theme = theme;\n  }, [ref.current, theme]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.popoverOptions = popoverOptions;\n  }, [ref.current, popoverOptions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.confirmOnBrowserAutofill = confirmOnBrowserAutofill;\n  }, [ref.current, confirmOnBrowserAutofill]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.browserAutofillEnabled = browserAutofillEnabled;\n  }, [ref.current, browserAutofillEnabled]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggest)\n      return;\n    const fn = (e) => onSuggest(e.detail);\n    node.addEventListener(\"suggest\", fn);\n    return () => {\n      node.removeEventListener(\"suggest\", fn);\n    };\n  }, [ref.current, onSuggest]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggestError)\n      return;\n    const fn = (e) => onSuggestError(e.detail);\n    node.addEventListener(\"suggesterror\", fn);\n    return () => {\n      node.removeEventListener(\"suggesterror\", fn);\n    };\n  }, [ref.current, onSuggestError]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onRetrieve)\n      return;\n    const fn = (e) => onRetrieve(e.detail);\n    node.addEventListener(\"retrieve\", fn);\n    return () => {\n      node.removeEventListener(\"retrieve\", fn);\n    };\n  }, [ref.current, onRetrieve]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onChange)\n      return;\n    const fn = (e) => {\n      if (e.target !== e.currentTarget)\n        return;\n      onChange(e.detail);\n    };\n    node.addEventListener(\"input\", fn);\n    return () => {\n      node.removeEventListener(\"input\", fn);\n    };\n  }, [ref.current, onChange]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"mapbox-address-autofill\", {\n    ref\n  }, children);\n});\n\n// src/components/SearchBox.tsx\n\nvar SearchBox = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, refProp) => {\n  const {\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    placeholder,\n    map,\n    marker,\n    mapboxgl,\n    value,\n    onChange,\n    onSuggest,\n    onSuggestError,\n    onRetrieve,\n    interceptSearch\n  } = props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(refProp, () => ({\n    focus: () => {\n      if (ref.current)\n        return ref.current.focus();\n      throw new Error(\"SearchBox is not mounted\");\n    },\n    search: (text) => {\n      if (ref.current)\n        return ref.current.search(text);\n      throw new Error(\"SearchBox is not mounted\");\n    }\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.options = options || {};\n  }, [ref.current, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.interceptSearch = interceptSearch;\n  }, [ref.current, interceptSearch]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.theme = theme;\n  }, [ref.current, theme]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.popoverOptions = popoverOptions;\n  }, [ref.current, popoverOptions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.placeholder = placeholder;\n  }, [ref.current, placeholder]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.value = value;\n  }, [ref.current, value]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    node.bindMap(map);\n    return () => {\n      node.unbindMap();\n    };\n  }, [ref.current, map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.marker = marker;\n  }, [ref.current, marker]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.mapboxgl = mapboxgl;\n  }, [ref.current, mapboxgl]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggest)\n      return;\n    const fn = (e) => onSuggest(e.detail);\n    node.addEventListener(\"suggest\", fn);\n    return () => {\n      node.removeEventListener(\"suggest\", fn);\n    };\n  }, [ref.current, onSuggest]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggestError)\n      return;\n    const fn = (e) => onSuggestError(e.detail);\n    node.addEventListener(\"suggesterror\", fn);\n    return () => {\n      node.removeEventListener(\"suggesterror\", fn);\n    };\n  }, [ref.current, onSuggestError]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onRetrieve)\n      return;\n    const fn = (e) => onRetrieve(e.detail);\n    node.addEventListener(\"retrieve\", fn);\n    return () => {\n      node.removeEventListener(\"retrieve\", fn);\n    };\n  }, [ref.current, onRetrieve]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onChange)\n      return;\n    const fn = (e) => {\n      if (e.target !== e.currentTarget)\n        return;\n      onChange(e.detail);\n    };\n    node.addEventListener(\"input\", fn);\n    return () => {\n      node.removeEventListener(\"input\", fn);\n    };\n  }, [ref.current, onChange]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"mapbox-search-box\", {\n    ref\n  });\n});\n\n// src/components/Geocoder.tsx\n\nvar Geocoder = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, refProp) => {\n  const {\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    placeholder,\n    map,\n    marker,\n    mapboxgl,\n    value,\n    onChange,\n    onSuggest,\n    onSuggestError,\n    onRetrieve,\n    interceptSearch\n  } = props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(refProp, () => ({\n    focus: () => {\n      if (ref.current)\n        return ref.current.focus();\n      throw new Error(\"Geocoder is not mounted\");\n    },\n    search: (text) => {\n      if (ref.current)\n        return ref.current.search(text);\n      throw new Error(\"Geocoder is not mounted\");\n    }\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.options = options || {};\n  }, [ref.current, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.interceptSearch = interceptSearch;\n  }, [ref.current, interceptSearch]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.theme = theme;\n  }, [ref.current, theme]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.popoverOptions = popoverOptions;\n  }, [ref.current, popoverOptions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.placeholder = placeholder;\n  }, [ref.current, placeholder]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.value = value;\n  }, [ref.current, value]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    node.bindMap(map);\n    return () => {\n      node.unbindMap();\n    };\n  }, [ref.current, map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.marker = marker;\n  }, [ref.current, marker]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.mapboxgl = mapboxgl;\n  }, [ref.current, mapboxgl]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggest)\n      return;\n    const fn = (e) => onSuggest(e.detail);\n    node.addEventListener(\"suggest\", fn);\n    return () => {\n      node.removeEventListener(\"suggest\", fn);\n    };\n  }, [ref.current, onSuggest]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggestError)\n      return;\n    const fn = (e) => onSuggestError(e.detail);\n    node.addEventListener(\"suggesterror\", fn);\n    return () => {\n      node.removeEventListener(\"suggesterror\", fn);\n    };\n  }, [ref.current, onSuggestError]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onRetrieve)\n      return;\n    const fn = (e) => onRetrieve(e.detail);\n    node.addEventListener(\"retrieve\", fn);\n    return () => {\n      node.removeEventListener(\"retrieve\", fn);\n    };\n  }, [ref.current, onRetrieve]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onChange)\n      return;\n    const fn = (e) => {\n      if (e.target !== e.currentTarget)\n        return;\n      onChange(e.detail);\n    };\n    node.addEventListener(\"input\", fn);\n    return () => {\n      node.removeEventListener(\"input\", fn);\n    };\n  }, [ref.current, onChange]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"mapbox-geocoder\", {\n    ref\n  });\n});\n\n// src/components/AddressMinimap.tsx\n\nfunction AddressMinimap(props) {\n  const {\n    canAdjustMarker = false,\n    keepMarkerCentered = false,\n    markerAnchor = \"bottom\",\n    onSaveMarkerLocation,\n    show = false,\n    accessToken,\n    feature = null,\n    adjustBtnText,\n    saveBtnText,\n    cancelBtnText,\n    satelliteToggle = false,\n    theme,\n    mapStyleMode = \"default\",\n    defaultMapStyle = [\"mapbox\", \"streets-v11\"],\n    footer\n  } = props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!ref.current)\n      return;\n    if (show) {\n      ref.current.show();\n    } else {\n      ref.current.hide();\n    }\n  }, [ref.current, show]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.theme = theme;\n  }, [ref.current, theme]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.feature = show ? feature : null;\n  }, [ref.current, feature, show]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.mapStyleMode = mapStyleMode;\n  }, [ref.current, mapStyleMode]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (adjustBtnText === void 0)\n      return;\n    if (ref.current)\n      ref.current.adjustBtnText = adjustBtnText;\n  }, [ref.current, adjustBtnText]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (saveBtnText === void 0)\n      return;\n    if (ref.current)\n      ref.current.saveBtnText = saveBtnText;\n  }, [ref.current, saveBtnText]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (cancelBtnText === void 0)\n      return;\n    if (ref.current)\n      ref.current.cancelBtnText = cancelBtnText;\n  }, [ref.current, cancelBtnText]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.defaultMapStyle = defaultMapStyle;\n  }, [ref.current, defaultMapStyle]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (footer === void 0)\n      return;\n    if (ref.current)\n      ref.current.footer = footer;\n  }, [ref.current, footer]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.onSaveMarkerLocation = onSaveMarkerLocation;\n  }, [ref.current, onSaveMarkerLocation]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"mapbox-address-minimap\", {\n    ref,\n    \"can-adjust-marker\": canAdjustMarker,\n    \"keep-marker-centered\": keepMarkerCentered,\n    \"marker-anchor\": markerAnchor,\n    \"satellite-toggle\": satelliteToggle\n  });\n}\n\n// src/hooks/useEvented.tsx\n\nfunction useEvented(evented, eventName, cb) {\n  const cbRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(cb);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    cbRef.current = cb;\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!evented)\n      return;\n    const fn = (object) => cbRef.current(object);\n    evented.addEventListener(eventName, fn);\n    return () => {\n      evented.removeEventListener(eventName, fn);\n    };\n  }, [evented, eventName, cbRef]);\n}\n\n// src/hooks/useAddressAutofillCore.tsx\n\n\nvar DEFAULTS = _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.AddressAutofillCore.defaults;\nfunction useAddressAutofillCore(options) {\n  const autofill = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.AddressAutofillCore();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [\"accessToken\"]);\n    autofill.accessToken = accessToken;\n    autofill.defaults = __spreadValues(__spreadValues({}, DEFAULTS), restOptions);\n  }, [options]);\n  return autofill;\n}\n\n// src/hooks/useSearchBoxCore.tsx\n\n\nvar DEFAULTS2 = _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.SearchBoxCore.defaults;\nfunction useSearchBoxCore(options) {\n  const search = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.SearchBoxCore();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [\"accessToken\"]);\n    search.accessToken = accessToken;\n    search.defaults = __spreadValues(__spreadValues({}, DEFAULTS2), restOptions);\n  }, [options]);\n  return search;\n}\n\n// src/hooks/useGeocodingCore.tsx\n\n\nfunction useGeocodingCore(options) {\n  const search = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.GeocodingCore();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [\"accessToken\"]);\n    search.accessToken = accessToken;\n    search.defaults = __spreadValues({}, restOptions);\n  }, [options]);\n  return search;\n}\n\n// src/hooks/useSearchSession.tsx\n\n\nfunction useSearchSession(search) {\n  const searchSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.SearchSession(search);\n  }, [search]);\n  if (search instanceof _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.SearchBoxCore) {\n    return searchSession;\n  } else if (search instanceof _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.GeocodingCore) {\n    return searchSession;\n  } else {\n    return searchSession;\n  }\n}\n\n// src/hooks/useConfirmAddress.tsx\n\n\nfunction useConfirmAddress(optionsArg = {}) {\n  const formRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return {\n      formRef,\n      showConfirm: () => (0,_mapbox_search_js_web__WEBPACK_IMPORTED_MODULE_0__.confirmAddress)(formRef.current, optionsArg)\n    };\n  }, [formRef, optionsArg]);\n}\n\n//# sourceMappingURL=index-esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtcmVhY3QvZGlzdC9pbmRleC1lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDZ0I7O0FBRS9DO0FBQ3NFO0FBQ3RFLHNCQUFzQix1REFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyw2Q0FBTTtBQUNwQixFQUFFLDBEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QiwwREFBbUI7QUFDNUM7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUN3SDtBQUN4SCxnQkFBZ0IsdURBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDZDQUFPO0FBQ3JCLEVBQUUsMERBQW9CO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QiwwREFBb0I7QUFDN0M7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUN3SDtBQUN4SCxlQUFlLHVEQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyw2Q0FBTztBQUNyQixFQUFFLDBEQUFvQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsMERBQW9CO0FBQzdDO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDZDQUFPO0FBQ3JCLEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsMERBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDbUU7QUFDbkU7QUFDQSxnQkFBZ0IsNkNBQU87QUFDdkIsRUFBRSxnREFBVTtBQUNaO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUN5RDtBQUd6QjtBQUNoQyxlQUFlLHVFQUFtQjtBQUNsQztBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQixlQUFlLHVFQUFtQjtBQUNsQyxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0Esd0RBQXdEO0FBQ3hELEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ3FFO0FBQ2Q7QUFDdkQsZ0JBQWdCLGlFQUFhO0FBQzdCO0FBQ0EsaUJBQWlCLDhDQUFRO0FBQ3pCLGVBQWUsaUVBQWE7QUFDNUIsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWiwwQkFBMEIsY0FBYztBQUN4QztBQUNBLHNEQUFzRDtBQUN0RCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNxRTtBQUNkO0FBQ3ZEO0FBQ0EsaUJBQWlCLDhDQUFRO0FBQ3pCLGVBQWUsaUVBQWE7QUFDNUIsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWiwwQkFBMEIsY0FBYztBQUN4QztBQUNBLHVDQUF1QztBQUN2QyxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUtnQztBQUNZO0FBQzVDO0FBQ0Esd0JBQXdCLDhDQUFRO0FBQ2hDLGVBQWUsaUVBQWE7QUFDNUIsR0FBRztBQUNILHdCQUF3QixpRUFBYztBQUN0QztBQUNBLElBQUksMkJBQTJCLGlFQUFjO0FBQzdDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUMrRDtBQUdoQztBQUMvQiwwQ0FBMEM7QUFDMUMsa0JBQWtCLDZDQUFPO0FBQ3pCLFNBQVMsOENBQVE7QUFDakI7QUFDQTtBQUNBLHlCQUF5QixxRUFBYztBQUN2QztBQUNBLEdBQUc7QUFDSDtBQWNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvc2VhcmNoLWpzLXJlYWN0L2Rpc3QvaW5kZXgtZXNtLmpzPzQ5MjgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IFwiQG1hcGJveC9zZWFyY2gtanMtd2ViXCI7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tIFwiQG1hcGJveC9zZWFyY2gtanMtd2ViXCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL0FkZHJlc3NBdXRvZmlsbC50c3hcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIEFkZHJlc3NBdXRvZmlsbCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWZQcm9wKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBhY2Nlc3NUb2tlbixcbiAgICBvcHRpb25zLFxuICAgIHRoZW1lLFxuICAgIHBvcG92ZXJPcHRpb25zLFxuICAgIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbCxcbiAgICBicm93c2VyQXV0b2ZpbGxFbmFibGVkLFxuICAgIGNoaWxkcmVuLFxuICAgIG9uQ2hhbmdlLFxuICAgIG9uU3VnZ2VzdCxcbiAgICBvblN1Z2dlc3RFcnJvcixcbiAgICBvblJldHJpZXZlLFxuICAgIGludGVyY2VwdFNlYXJjaFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZigpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZlByb3AsICgpID0+ICh7XG4gICAgZm9jdXM6ICgpID0+IHtcbiAgICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzQXV0b2ZpbGwgaXMgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICB9KSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sIFtyZWYuY3VycmVudCwgb3B0aW9uc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LmludGVyY2VwdFNlYXJjaCA9IGludGVyY2VwdFNlYXJjaDtcbiAgfSwgW3JlZi5jdXJyZW50LCBvcHRpb25zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQudGhlbWUgPSB0aGVtZTtcbiAgfSwgW3JlZi5jdXJyZW50LCB0aGVtZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LnBvcG92ZXJPcHRpb25zID0gcG9wb3Zlck9wdGlvbnM7XG4gIH0sIFtyZWYuY3VycmVudCwgcG9wb3Zlck9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPSBjb25maXJtT25Ccm93c2VyQXV0b2ZpbGw7XG4gIH0sIFtyZWYuY3VycmVudCwgY29uZmlybU9uQnJvd3NlckF1dG9maWxsXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuYnJvd3NlckF1dG9maWxsRW5hYmxlZCA9IGJyb3dzZXJBdXRvZmlsbEVuYWJsZWQ7XG4gIH0sIFtyZWYuY3VycmVudCwgYnJvd3NlckF1dG9maWxsRW5hYmxlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvblN1Z2dlc3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25TdWdnZXN0KGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblN1Z2dlc3RdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghb25TdWdnZXN0RXJyb3IpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25TdWdnZXN0RXJyb3IoZS5kZXRhaWwpO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBmbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblN1Z2dlc3RFcnJvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvblJldHJpZXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZuID0gKGUpID0+IG9uUmV0cmlldmUoZS5kZXRhaWwpO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInJldHJpZXZlXCIsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgZm4pO1xuICAgIH07XG4gIH0sIFtyZWYuY3VycmVudCwgb25SZXRyaWV2ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvbkNoYW5nZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgb25DaGFuZ2UoZS5kZXRhaWwpO1xuICAgIH07XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvbkNoYW5nZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gIH0sIFtyZWYuY3VycmVudCwgYWNjZXNzVG9rZW5dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwibWFwYm94LWFkZHJlc3MtYXV0b2ZpbGxcIiwge1xuICAgIHJlZlxuICB9LCBjaGlsZHJlbik7XG59KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvU2VhcmNoQm94LnRzeFxuaW1wb3J0IFJlYWN0MiwgeyB1c2VSZWYgYXMgdXNlUmVmMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBTZWFyY2hCb3ggPSBSZWFjdDIuZm9yd2FyZFJlZigocHJvcHMsIHJlZlByb3ApID0+IHtcbiAgY29uc3Qge1xuICAgIGFjY2Vzc1Rva2VuLFxuICAgIG9wdGlvbnMsXG4gICAgdGhlbWUsXG4gICAgcG9wb3Zlck9wdGlvbnMsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgbWFwLFxuICAgIG1hcmtlcixcbiAgICBtYXBib3hnbCxcbiAgICB2YWx1ZSxcbiAgICBvbkNoYW5nZSxcbiAgICBvblN1Z2dlc3QsXG4gICAgb25TdWdnZXN0RXJyb3IsXG4gICAgb25SZXRyaWV2ZSxcbiAgICBpbnRlcmNlcHRTZWFyY2hcbiAgfSA9IHByb3BzO1xuICBjb25zdCByZWYgPSB1c2VSZWYyKCk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUyKHJlZlByb3AsICgpID0+ICh7XG4gICAgZm9jdXM6ICgpID0+IHtcbiAgICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWFyY2hCb3ggaXMgbm90IG1vdW50ZWRcIik7XG4gICAgfSxcbiAgICBzZWFyY2g6ICh0ZXh0KSA9PiB7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICAgIHJldHVybiByZWYuY3VycmVudC5zZWFyY2godGV4dCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWFyY2hCb3ggaXMgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICB9KSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50Lm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9LCBbcmVmLmN1cnJlbnQsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuaW50ZXJjZXB0U2VhcmNoID0gaW50ZXJjZXB0U2VhcmNoO1xuICB9LCBbcmVmLmN1cnJlbnQsIGludGVyY2VwdFNlYXJjaF0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC50aGVtZSA9IHRoZW1lO1xuICB9LCBbcmVmLmN1cnJlbnQsIHRoZW1lXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LnBvcG92ZXJPcHRpb25zID0gcG9wb3Zlck9wdGlvbnM7XG4gIH0sIFtyZWYuY3VycmVudCwgcG9wb3Zlck9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgfSwgW3JlZi5jdXJyZW50LCBwbGFjZWhvbGRlcl0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbcmVmLmN1cnJlbnQsIHZhbHVlXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgbm9kZS5iaW5kTWFwKG1hcCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5vZGUudW5iaW5kTWFwKCk7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBtYXBdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQubWFya2VyID0gbWFya2VyO1xuICB9LCBbcmVmLmN1cnJlbnQsIG1hcmtlcl0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5tYXBib3hnbCA9IG1hcGJveGdsO1xuICB9LCBbcmVmLmN1cnJlbnQsIG1hcGJveGdsXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvblN1Z2dlc3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25TdWdnZXN0KGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblN1Z2dlc3RdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIW9uU3VnZ2VzdEVycm9yKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZuID0gKGUpID0+IG9uU3VnZ2VzdEVycm9yKGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgZm4pO1xuICAgIH07XG4gIH0sIFtyZWYuY3VycmVudCwgb25TdWdnZXN0RXJyb3JdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIW9uUmV0cmlldmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25SZXRyaWV2ZShlLmRldGFpbCk7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblJldHJpZXZlXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvbkNoYW5nZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgb25DaGFuZ2UoZS5kZXRhaWwpO1xuICAgIH07XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvbkNoYW5nZV0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9LCBbcmVmLmN1cnJlbnQsIGFjY2Vzc1Rva2VuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJtYXBib3gtc2VhcmNoLWJveFwiLCB7XG4gICAgcmVmXG4gIH0pO1xufSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL0dlb2NvZGVyLnRzeFxuaW1wb3J0IFJlYWN0MywgeyB1c2VSZWYgYXMgdXNlUmVmMywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBHZW9jb2RlciA9IFJlYWN0My5mb3J3YXJkUmVmKChwcm9wcywgcmVmUHJvcCkgPT4ge1xuICBjb25zdCB7XG4gICAgYWNjZXNzVG9rZW4sXG4gICAgb3B0aW9ucyxcbiAgICB0aGVtZSxcbiAgICBwb3BvdmVyT3B0aW9ucyxcbiAgICBwbGFjZWhvbGRlcixcbiAgICBtYXAsXG4gICAgbWFya2VyLFxuICAgIG1hcGJveGdsLFxuICAgIHZhbHVlLFxuICAgIG9uQ2hhbmdlLFxuICAgIG9uU3VnZ2VzdCxcbiAgICBvblN1Z2dlc3RFcnJvcixcbiAgICBvblJldHJpZXZlLFxuICAgIGludGVyY2VwdFNlYXJjaFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjMoKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTMocmVmUHJvcCwgKCkgPT4gKHtcbiAgICBmb2N1czogKCkgPT4ge1xuICAgICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlb2NvZGVyIGlzIG5vdCBtb3VudGVkXCIpO1xuICAgIH0sXG4gICAgc2VhcmNoOiAodGV4dCkgPT4ge1xuICAgICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQuc2VhcmNoKHRleHQpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VvY29kZXIgaXMgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICB9KSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50Lm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9LCBbcmVmLmN1cnJlbnQsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuaW50ZXJjZXB0U2VhcmNoID0gaW50ZXJjZXB0U2VhcmNoO1xuICB9LCBbcmVmLmN1cnJlbnQsIGludGVyY2VwdFNlYXJjaF0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC50aGVtZSA9IHRoZW1lO1xuICB9LCBbcmVmLmN1cnJlbnQsIHRoZW1lXSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LnBvcG92ZXJPcHRpb25zID0gcG9wb3Zlck9wdGlvbnM7XG4gIH0sIFtyZWYuY3VycmVudCwgcG9wb3Zlck9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgfSwgW3JlZi5jdXJyZW50LCBwbGFjZWhvbGRlcl0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbcmVmLmN1cnJlbnQsIHZhbHVlXSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgbm9kZS5iaW5kTWFwKG1hcCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5vZGUudW5iaW5kTWFwKCk7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBtYXBdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQubWFya2VyID0gbWFya2VyO1xuICB9LCBbcmVmLmN1cnJlbnQsIG1hcmtlcl0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5tYXBib3hnbCA9IG1hcGJveGdsO1xuICB9LCBbcmVmLmN1cnJlbnQsIG1hcGJveGdsXSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvblN1Z2dlc3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25TdWdnZXN0KGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblN1Z2dlc3RdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIW9uU3VnZ2VzdEVycm9yKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZuID0gKGUpID0+IG9uU3VnZ2VzdEVycm9yKGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgZm4pO1xuICAgIH07XG4gIH0sIFtyZWYuY3VycmVudCwgb25TdWdnZXN0RXJyb3JdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIW9uUmV0cmlldmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25SZXRyaWV2ZShlLmRldGFpbCk7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblJldHJpZXZlXSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvbkNoYW5nZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgb25DaGFuZ2UoZS5kZXRhaWwpO1xuICAgIH07XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvbkNoYW5nZV0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9LCBbcmVmLmN1cnJlbnQsIGFjY2Vzc1Rva2VuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXCJtYXBib3gtZ2VvY29kZXJcIiwge1xuICAgIHJlZlxuICB9KTtcbn0pO1xuXG4vLyBzcmMvY29tcG9uZW50cy9BZGRyZXNzTWluaW1hcC50c3hcbmltcG9ydCBSZWFjdDQsIHsgdXNlUmVmIGFzIHVzZVJlZjQsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBBZGRyZXNzTWluaW1hcChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2FuQWRqdXN0TWFya2VyID0gZmFsc2UsXG4gICAga2VlcE1hcmtlckNlbnRlcmVkID0gZmFsc2UsXG4gICAgbWFya2VyQW5jaG9yID0gXCJib3R0b21cIixcbiAgICBvblNhdmVNYXJrZXJMb2NhdGlvbixcbiAgICBzaG93ID0gZmFsc2UsXG4gICAgYWNjZXNzVG9rZW4sXG4gICAgZmVhdHVyZSA9IG51bGwsXG4gICAgYWRqdXN0QnRuVGV4dCxcbiAgICBzYXZlQnRuVGV4dCxcbiAgICBjYW5jZWxCdG5UZXh0LFxuICAgIHNhdGVsbGl0ZVRvZ2dsZSA9IGZhbHNlLFxuICAgIHRoZW1lLFxuICAgIG1hcFN0eWxlTW9kZSA9IFwiZGVmYXVsdFwiLFxuICAgIGRlZmF1bHRNYXBTdHlsZSA9IFtcIm1hcGJveFwiLCBcInN0cmVldHMtdjExXCJdLFxuICAgIGZvb3RlclxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjQoKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgaWYgKCFyZWYuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc2hvdykge1xuICAgICAgcmVmLmN1cnJlbnQuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudC5oaWRlKCk7XG4gICAgfVxuICB9LCBbcmVmLmN1cnJlbnQsIHNob3ddKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQudGhlbWUgPSB0aGVtZTtcbiAgfSwgW3JlZi5jdXJyZW50LCB0aGVtZV0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5mZWF0dXJlID0gc2hvdyA/IGZlYXR1cmUgOiBudWxsO1xuICB9LCBbcmVmLmN1cnJlbnQsIGZlYXR1cmUsIHNob3ddKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQubWFwU3R5bGVNb2RlID0gbWFwU3R5bGVNb2RlO1xuICB9LCBbcmVmLmN1cnJlbnQsIG1hcFN0eWxlTW9kZV0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAoYWRqdXN0QnRuVGV4dCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LmFkanVzdEJ0blRleHQgPSBhZGp1c3RCdG5UZXh0O1xuICB9LCBbcmVmLmN1cnJlbnQsIGFkanVzdEJ0blRleHRdKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgaWYgKHNhdmVCdG5UZXh0ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuc2F2ZUJ0blRleHQgPSBzYXZlQnRuVGV4dDtcbiAgfSwgW3JlZi5jdXJyZW50LCBzYXZlQnRuVGV4dF0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAoY2FuY2VsQnRuVGV4dCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LmNhbmNlbEJ0blRleHQgPSBjYW5jZWxCdG5UZXh0O1xuICB9LCBbcmVmLmN1cnJlbnQsIGNhbmNlbEJ0blRleHRdKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuZGVmYXVsdE1hcFN0eWxlID0gZGVmYXVsdE1hcFN0eWxlO1xuICB9LCBbcmVmLmN1cnJlbnQsIGRlZmF1bHRNYXBTdHlsZV0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAoZm9vdGVyID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuZm9vdGVyID0gZm9vdGVyO1xuICB9LCBbcmVmLmN1cnJlbnQsIGZvb3Rlcl0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9LCBbcmVmLmN1cnJlbnQsIGFjY2Vzc1Rva2VuXSk7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50Lm9uU2F2ZU1hcmtlckxvY2F0aW9uID0gb25TYXZlTWFya2VyTG9jYXRpb247XG4gIH0sIFtyZWYuY3VycmVudCwgb25TYXZlTWFya2VyTG9jYXRpb25dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcIm1hcGJveC1hZGRyZXNzLW1pbmltYXBcIiwge1xuICAgIHJlZixcbiAgICBcImNhbi1hZGp1c3QtbWFya2VyXCI6IGNhbkFkanVzdE1hcmtlcixcbiAgICBcImtlZXAtbWFya2VyLWNlbnRlcmVkXCI6IGtlZXBNYXJrZXJDZW50ZXJlZCxcbiAgICBcIm1hcmtlci1hbmNob3JcIjogbWFya2VyQW5jaG9yLFxuICAgIFwic2F0ZWxsaXRlLXRvZ2dsZVwiOiBzYXRlbGxpdGVUb2dnbGVcbiAgfSk7XG59XG5cbi8vIHNyYy9ob29rcy91c2VFdmVudGVkLnRzeFxuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDUsIHVzZVJlZiBhcyB1c2VSZWY1IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VFdmVudGVkKGV2ZW50ZWQsIGV2ZW50TmFtZSwgY2IpIHtcbiAgY29uc3QgY2JSZWYgPSB1c2VSZWY1KGNiKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgY2JSZWYuY3VycmVudCA9IGNiO1xuICB9KTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKCFldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZuID0gKG9iamVjdCkgPT4gY2JSZWYuY3VycmVudChvYmplY3QpO1xuICAgIGV2ZW50ZWQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xuICAgIH07XG4gIH0sIFtldmVudGVkLCBldmVudE5hbWUsIGNiUmVmXSk7XG59XG5cbi8vIHNyYy9ob29rcy91c2VBZGRyZXNzQXV0b2ZpbGxDb3JlLnRzeFxuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEFkZHJlc3NBdXRvZmlsbENvcmVcbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbnZhciBERUZBVUxUUyA9IEFkZHJlc3NBdXRvZmlsbENvcmUuZGVmYXVsdHM7XG5mdW5jdGlvbiB1c2VBZGRyZXNzQXV0b2ZpbGxDb3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgYXV0b2ZpbGwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gbmV3IEFkZHJlc3NBdXRvZmlsbENvcmUoKTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBjb25zdCBfYSA9IG9wdGlvbnMsIHsgYWNjZXNzVG9rZW4gfSA9IF9hLCByZXN0T3B0aW9ucyA9IF9fb2JqUmVzdChfYSwgW1wiYWNjZXNzVG9rZW5cIl0pO1xuICAgIGF1dG9maWxsLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgYXV0b2ZpbGwuZGVmYXVsdHMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgREVGQVVMVFMpLCByZXN0T3B0aW9ucyk7XG4gIH0sIFtvcHRpb25zXSk7XG4gIHJldHVybiBhdXRvZmlsbDtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZVNlYXJjaEJveENvcmUudHN4XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NywgdXNlTWVtbyBhcyB1c2VNZW1vMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgU2VhcmNoQm94Q29yZSB9IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG52YXIgREVGQVVMVFMyID0gU2VhcmNoQm94Q29yZS5kZWZhdWx0cztcbmZ1bmN0aW9uIHVzZVNlYXJjaEJveENvcmUob3B0aW9ucykge1xuICBjb25zdCBzZWFyY2ggPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hCb3hDb3JlKCk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgY29uc3QgX2EgPSBvcHRpb25zLCB7IGFjY2Vzc1Rva2VuIH0gPSBfYSwgcmVzdE9wdGlvbnMgPSBfX29ialJlc3QoX2EsIFtcImFjY2Vzc1Rva2VuXCJdKTtcbiAgICBzZWFyY2guYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICBzZWFyY2guZGVmYXVsdHMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgREVGQVVMVFMyKSwgcmVzdE9wdGlvbnMpO1xuICB9LCBbb3B0aW9uc10pO1xuICByZXR1cm4gc2VhcmNoO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlR2VvY29kaW5nQ29yZS50c3hcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q4LCB1c2VNZW1vIGFzIHVzZU1lbW8zIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBHZW9jb2RpbmdDb3JlIH0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbmZ1bmN0aW9uIHVzZUdlb2NvZGluZ0NvcmUob3B0aW9ucykge1xuICBjb25zdCBzZWFyY2ggPSB1c2VNZW1vMygoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBHZW9jb2RpbmdDb3JlKCk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgY29uc3QgX2EgPSBvcHRpb25zLCB7IGFjY2Vzc1Rva2VuIH0gPSBfYSwgcmVzdE9wdGlvbnMgPSBfX29ialJlc3QoX2EsIFtcImFjY2Vzc1Rva2VuXCJdKTtcbiAgICBzZWFyY2guYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICBzZWFyY2guZGVmYXVsdHMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdE9wdGlvbnMpO1xuICB9LCBbb3B0aW9uc10pO1xuICByZXR1cm4gc2VhcmNoO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlU2VhcmNoU2Vzc2lvbi50c3hcbmltcG9ydCB7XG4gIFNlYXJjaEJveENvcmUgYXMgU2VhcmNoQm94Q29yZTIsXG4gIEdlb2NvZGluZ0NvcmUgYXMgR2VvY29kaW5nQ29yZTIsXG4gIFNlYXJjaFNlc3Npb25cbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzQgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVNlYXJjaFNlc3Npb24oc2VhcmNoKSB7XG4gIGNvbnN0IHNlYXJjaFNlc3Npb24gPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hTZXNzaW9uKHNlYXJjaCk7XG4gIH0sIFtzZWFyY2hdKTtcbiAgaWYgKHNlYXJjaCBpbnN0YW5jZW9mIFNlYXJjaEJveENvcmUyKSB7XG4gICAgcmV0dXJuIHNlYXJjaFNlc3Npb247XG4gIH0gZWxzZSBpZiAoc2VhcmNoIGluc3RhbmNlb2YgR2VvY29kaW5nQ29yZTIpIHtcbiAgICByZXR1cm4gc2VhcmNoU2Vzc2lvbjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VhcmNoU2Vzc2lvbjtcbiAgfVxufVxuXG4vLyBzcmMvaG9va3MvdXNlQ29uZmlybUFkZHJlc3MudHN4XG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW81LCB1c2VSZWYgYXMgdXNlUmVmNiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgY29uZmlybUFkZHJlc3Ncbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLXdlYlwiO1xuZnVuY3Rpb24gdXNlQ29uZmlybUFkZHJlc3Mob3B0aW9uc0FyZyA9IHt9KSB7XG4gIGNvbnN0IGZvcm1SZWYgPSB1c2VSZWY2KG51bGwpO1xuICByZXR1cm4gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtUmVmLFxuICAgICAgc2hvd0NvbmZpcm06ICgpID0+IGNvbmZpcm1BZGRyZXNzKGZvcm1SZWYuY3VycmVudCwgb3B0aW9uc0FyZylcbiAgICB9O1xuICB9LCBbZm9ybVJlZiwgb3B0aW9uc0FyZ10pO1xufVxuZXhwb3J0IHtcbiAgQWRkcmVzc0F1dG9maWxsLFxuICBBZGRyZXNzTWluaW1hcCxcbiAgR2VvY29kZXIsXG4gIFNlYXJjaEJveCxcbiAgY29uZmlnLFxuICB1c2VBZGRyZXNzQXV0b2ZpbGxDb3JlLFxuICB1c2VDb25maXJtQWRkcmVzcyxcbiAgdXNlRXZlbnRlZCxcbiAgdXNlR2VvY29kaW5nQ29yZSxcbiAgdXNlQWRkcmVzc0F1dG9maWxsQ29yZSBhcyB1c2VNYXBib3hBdXRvZmlsbCxcbiAgdXNlU2VhcmNoQm94Q29yZSxcbiAgdXNlU2VhcmNoU2Vzc2lvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LWVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-react/dist/index-esm.js\n"));

/***/ }),

/***/ "./node_modules/@mapbox/search-js-web/dist/index-esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-web/dist/index-esm.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapboxAddressAutofill: function() { return /* binding */ MapboxAddressAutofill; },\n/* harmony export */   MapboxAddressConfirmation: function() { return /* binding */ MapboxAddressConfirmation; },\n/* harmony export */   MapboxAddressMinimap: function() { return /* binding */ MapboxAddressMinimap; },\n/* harmony export */   MapboxGeocoder: function() { return /* binding */ MapboxGeocoder; },\n/* harmony export */   MapboxHTMLEvent: function() { return /* binding */ MapboxHTMLEvent; },\n/* harmony export */   MapboxSearchBox: function() { return /* binding */ MapboxSearchBox; },\n/* harmony export */   autofill: function() { return /* binding */ autofill; },\n/* harmony export */   config: function() { return /* binding */ config; },\n/* harmony export */   confirmAddress: function() { return /* binding */ confirmAddress; },\n/* harmony export */   getAutofillSearchText: function() { return /* binding */ getAutofillSearchText; },\n/* harmony export */   getFormAutofillValues: function() { return /* binding */ getFormAutofillValues; }\n/* harmony export */ });\n/* harmony import */ var _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/search-js-core */ \"./node_modules/@mapbox/search-js-core/dist/index-esm.js\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs\");\n/* harmony import */ var no_scroll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! no-scroll */ \"./node_modules/no-scroll/index.js\");\n/* harmony import */ var no_scroll__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(no_scroll__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! focus-trap */ \"./node_modules/focus-trap/dist/focus-trap.esm.js\");\n/* harmony import */ var subtag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! subtag */ \"./node_modules/subtag/subtag.js\");\n/* harmony import */ var subtag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(subtag__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mapbox/sphericalmercator */ \"./node_modules/@mapbox/sphericalmercator/sphericalmercator.js\");\n/* harmony import */ var _mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_5__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/utils/dom.ts\nvar subdoc = document.implementation.createHTMLDocument();\nfunction bindElements(root, elements) {\n  const binding = {};\n  for (const [key, selector] of Object.entries(elements)) {\n    binding[key] = root.querySelector(selector);\n  }\n  return binding;\n}\nfunction getChildElements(node) {\n  return Array.from(node.childNodes || []).filter((el) => el.nodeType === Node.ELEMENT_NODE);\n}\nfunction createElementFromString(innerHTML) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = innerHTML;\n  return template.content.firstElementChild;\n}\nfunction createCSSStyleSheet(text) {\n  const style = subdoc.createElement(\"style\");\n  style.textContent = text;\n  subdoc.head.appendChild(style);\n  return style.sheet;\n}\nfunction isVisible(element) {\n  const style = window.getComputedStyle(element);\n  return style.display !== \"none\";\n}\nfunction setValue(input, value) {\n  if (!input) {\n    return;\n  }\n  const set = Object.getOwnPropertyDescriptor(input.constructor.prototype, \"value\").set;\n  set.call(input, value);\n  const wrapperState = input;\n  if (wrapperState._valueTracker) {\n    wrapperState._valueTracker.setValue(\"\");\n  }\n  const onInputEvent = new Event(\"input\", {\n    bubbles: true\n  });\n  onInputEvent.simulated = true;\n  input.dispatchEvent(onInputEvent);\n  const onChangeEvent = new Event(\"change\", {\n    bubbles: true\n  });\n  onChangeEvent.simulated = true;\n  input.dispatchEvent(onChangeEvent);\n}\nfunction getElementSize(element, deep = false) {\n  let width;\n  let height;\n  const elementRect = element.getBoundingClientRect();\n  if (element.style.display === \"none\" || elementRect.height === 0 && elementRect.width === 0) {\n    const clone = element.cloneNode(deep);\n    element.parentElement.appendChild(clone);\n    clone.style.setProperty(\"display\", \"block\", \"important\");\n    const cloneRect = clone.getBoundingClientRect();\n    width = cloneRect.width;\n    height = cloneRect.height;\n    clone.style.setProperty(\"display\", \"none\");\n    clone.remove();\n  } else {\n    width = elementRect.width;\n    height = elementRect.height;\n  }\n  return {\n    height: Math.floor(height),\n    width: Math.floor(width)\n  };\n}\nfunction addDocumentStyle(css) {\n  const style = document.createElement(\"style\");\n  style.innerHTML = css;\n  document.head.appendChild(style);\n}\n\n// src/utils/class_name_transformers.ts\nvar IDENTIFIER_REGEX = new RegExp(\"[_a-zA-Z]+[_a-zA-Z0-9-]*\", \"g\");\nvar CLASS_NAME_REGEX = new RegExp(`\\\\.${IDENTIFIER_REGEX.source}`, \"g\");\nvar CONDITION_RULE_REGEX = new RegExp(`^\\\\s*(@(?:media|supports)[^{]*){(.*)}\\\\s*$`);\nfunction transformClassSelectors(css, transform) {\n  return css.replace(CLASS_NAME_REGEX, (className) => {\n    return \".\" + transform(className.slice(1));\n  });\n}\nfunction transformCSSClassRules(text, transform) {\n  const sheet = createCSSStyleSheet(text);\n  const rules = sheet.cssRules;\n  function transformCSSRule(rule) {\n    if (rule instanceof CSSStyleRule) {\n      const selector = transformClassSelectors(rule.selectorText, transform);\n      return `${selector} { ${rule.style.cssText} }`;\n    }\n    const atRule = CONDITION_RULE_REGEX.exec(rule.cssText.split(\"\\n\").join(\"\"));\n    if (atRule && atRule.length > 2) {\n      const rule2 = atRule[1];\n      const contents = atRule[2];\n      return `${rule2} { ${transformCSSClassRules(contents, transform)} }`;\n    }\n    return rule.cssText;\n  }\n  let style = \"\";\n  for (const rule of Array.from(rules)) {\n    style += transformCSSRule(rule) + \"\\n\\n\";\n  }\n  return style.trim();\n}\nfunction transformDOMClassAttributes(content, transform) {\n  const elements = Array.from(content.querySelectorAll(\"[class]\"));\n  elements.push(content);\n  for (const element of elements) {\n    const { classList } = element;\n    for (const className of Array.from(classList)) {\n      classList.remove(className);\n      classList.add(transform(className));\n    }\n  }\n  return content;\n}\n\n// src/utils/index.ts\n\n\n// src/utils/map.ts\nvar FLY_TO_SPEED = 1.4;\nfunction bboxViewport(map, bounds, delta = 0.5) {\n  const { center, zoom } = map.cameraForBounds(bounds);\n  const transformedZoom = Math.max(zoom - delta, 0);\n  return {\n    center,\n    zoom: transformedZoom,\n    speed: FLY_TO_SPEED\n  };\n}\nfunction getMaxZoom(placeType) {\n  switch (placeType) {\n    case \"street\":\n      return 15;\n    case \"neighborhood\":\n    case \"postcode\":\n    case \"locality\":\n    case \"oaza\":\n      return 14;\n    case \"place\":\n    case \"city\":\n      return 13;\n    case \"district\":\n      return 9;\n    case \"region\":\n    case \"prefecture\":\n      return 6;\n    case \"country\":\n      return 4;\n    default:\n      return 16;\n  }\n}\nfunction getStaticBaseUrl(username, styleId) {\n  return `https://api.mapbox.com/styles/v1/${username}/${styleId}/static/`;\n}\n\n// src/icons/close.svg\nvar close_default = '<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3.8 3.8a1 1 0 0 1 1.4 0L9 7.58l3.8-3.8a1 1 0 1 1 1.4 1.42L10.42 9l3.8 3.8a1 1 0 0 1-1.42 1.4L9 10.42l-3.8 3.8a1 1 0 0 1-1.4-1.42L7.58 9l-3.8-3.8a1 1 0 0 1 0-1.4Z\" fill=\"currentColor\"/></svg>';\n\n// src/icons/loading.svg\nvar loading_default = '<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"#333\" d=\"M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z\"/><path opacity=\".1\" d=\"M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z\"/></svg>';\n\n// src/constants.ts\nvar STATIC_BASE_URL_SATELLITE = getStaticBaseUrl(\"mapbox\", \"satellite-streets-v11\");\nvar AUTOFILL_SKU_TOKEN_PREFIX = \"20d01\";\nvar MAPBOX_DOMAINS = [\"mapbox.com\", \"mapbox.cn\", \"tilestream.net\"];\nvar LISTBOX_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MapboxSearch\">\n    <div class=\"Label\" role=\"label\" aria-live=\"polite\" aria-atomic=\"true\">\n    </div>\n    <div class=\"Results\" aria-hidden=\"true\">\n      <div class=\"ResultsList\" role=\"listbox\">\n      </div>\n      <div class=\"ResultsAttribution\" aria-hidden=\"true\">\n        <a href=\"https://www.mapbox.com/search-service\" target=\"_blank\" tabindex=\"-1\">\n          Powered by Mapbox\n        </a>\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar LISTBOX_SUGGESTION_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"Suggestion\" role=\"option\" tabindex=\"-1\">\n    <div class=\"SuggestionIcon\" aria-hidden=\"true\"></div>\n    <div class=\"SuggestionText\">\n      <div class=\"SuggestionName\"></div>\n      <div class=\"SuggestionDesc\"></div>\n    </div>\n  </div>\n</template>\n`);\nvar SEARCHBOX_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"SearchBox\">\n    <div class=\"SearchIcon\"></div>\n    <input class=\"Input\" type=\"text\" />\n    <div class=\"ActionIcon\">\n      <button aria-label=\"Clear\" class=\"ClearBtn\">${close_default}</button>\n      <div class=\"LoadingIcon\">${loading_default}</div>\n    </div>\n  </div>\n</template>\n`);\nvar GEOCODER_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"Geocoder\">\n    <div class=\"SearchIcon\"></div>\n    <input class=\"Input\" type=\"text\" />\n    <div class=\"ActionIcon\">\n      <button aria-label=\"Clear\" class=\"ClearBtn\">${close_default}</button>\n      <div class=\"LoadingIcon\">${loading_default}</div>\n    </div>\n  </div>\n</template>\n`);\n\n// src/utils/index.ts\nfunction randomValidID() {\n  return `mbx` + new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SessionToken().id.slice(0, 8);\n}\nfunction tryParseJSON(json) {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n}\nfunction deepEquals(a, b) {\n  if (a == null || b == null) {\n    return a === b;\n  }\n  if (typeof a !== \"object\" || typeof b !== \"object\") {\n    return a === b;\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  for (const key of aKeys) {\n    if (!deepEquals(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction round(num, decimalPlaces) {\n  const factorOfTen = Math.pow(10, decimalPlaces);\n  return Math.round(num * factorOfTen) / factorOfTen;\n}\nfunction isLocalServer(hostname) {\n  return Boolean(hostname.match(/localhost|[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|::1|\\.local|^$/gi));\n}\nfunction isMapboxDomain(hostname) {\n  return Boolean(MAPBOX_DOMAINS.some((domain) => hostname.includes(domain)));\n}\n\n// src/components/HTMLScopedElement.ts\nvar _seed, _templateUserStyleElement, _transform;\nvar HTMLScopedElement = class extends HTMLElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _seed, randomValidID());\n    __privateAdd(this, _templateUserStyleElement, void 0);\n    __privateAdd(this, _transform, (className) => {\n      return `${__privateGet(this, _seed)}--${className}`;\n    });\n  }\n  get template() {\n    return null;\n  }\n  get templateStyle() {\n    return null;\n  }\n  get templateUserStyle() {\n    return null;\n  }\n  clonedCallback(oldSeed, newSeed) {\n    const seedTransform = (className) => className.replace(oldSeed, newSeed);\n    transformDOMClassAttributes(this, seedTransform);\n    const styles = Array.from(this.querySelectorAll(\"style\"));\n    for (const style of styles) {\n      style.textContent = transformClassSelectors(style.textContent, seedTransform);\n    }\n    if (styles.length) {\n      __privateSet(this, _templateUserStyleElement, styles[styles.length - 1]);\n    }\n    const nodesWithId = Array.from(this.querySelectorAll(`[id^=\"${oldSeed}\"]`));\n    for (const node of nodesWithId) {\n      node.id = node.id.replace(oldSeed, newSeed);\n    }\n  }\n  connectedCallback() {\n    if (this.childElementCount > 0) {\n      const oldSeed = this.dataset.seed;\n      const newSeed = __privateGet(this, _seed);\n      if (oldSeed && oldSeed !== newSeed) {\n        this.clonedCallback(oldSeed, newSeed);\n        this.dataset.seed = newSeed;\n      }\n      return;\n    }\n    this.dataset.seed = __privateGet(this, _seed);\n    const template = this.template;\n    if (template) {\n      const element = this.prepareTemplate(template);\n      this.appendChild(element);\n    }\n    const templateStyle = this.templateStyle;\n    if (templateStyle) {\n      const style = document.createElement(\"style\");\n      style.textContent = this.prepareCSS(templateStyle);\n      this.appendChild(style);\n    }\n    const userStyle = document.createElement(\"style\");\n    if (this.templateUserStyle) {\n      userStyle.textContent = this.prepareCSS(this.templateUserStyle);\n    }\n    this.appendChild(userStyle);\n    __privateSet(this, _templateUserStyleElement, userStyle);\n  }\n  prepareTemplate(template) {\n    const element = template.content.firstElementChild;\n    return transformDOMClassAttributes(element.cloneNode(true), __privateGet(this, _transform));\n  }\n  prepareCSS(css) {\n    return transformCSSClassRules(css, __privateGet(this, _transform));\n  }\n  updateTemplateUserStyle(style) {\n    if (!__privateGet(this, _templateUserStyleElement)) {\n      return;\n    }\n    __privateGet(this, _templateUserStyleElement).textContent = this.prepareCSS(style);\n  }\n  querySelector(selectors) {\n    return super.querySelector(transformClassSelectors(selectors, __privateGet(this, _transform)));\n  }\n  querySelectorAll(selectors) {\n    return super.querySelectorAll(transformClassSelectors(selectors, __privateGet(this, _transform)));\n  }\n  addEventListener(type, listener, options) {\n    super.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    super.removeEventListener(type, listener, options);\n  }\n  dispatchEvent(event) {\n    return super.dispatchEvent(event);\n  }\n};\n_seed = new WeakMap();\n_templateUserStyleElement = new WeakMap();\n_transform = new WeakMap();\n\n// src/icons/question.svg\nvar question_default = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 16A7 7 0 1 0 9 2a7 7 0 0 0 0 14ZM6.88 4.88a2.58 2.58 0 0 1 1.83-.75h1.08a2.58 2.58 0 0 1 2.59 2.58v.16c0 1-.53 1.94-1.4 2.46l-.56.34c-.27.16-.45.42-.52.71-.03.14-.14.25-.28.25H8.38a.23.23 0 0 1-.24-.25c.08-.91.59-1.74 1.38-2.21l.56-.34c.34-.2.54-.57.54-.96V6.7a.83.83 0 0 0-.83-.83H8.71a.83.83 0 0 0-.84.83v.18a.87.87 0 1 1-1.75 0V6.7c0-.69.28-1.34.76-1.83ZM10 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z\" fill=\"currentColor\"/></svg>';\n\n// src/icons/marker.svg\nvar marker_default = '<svg width=\"48\" height=\"56\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><g filter=\"url(#a)\"><path d=\"m24 50.4 13.79-14.12a18.82 18.82 0 0 0 4.23-20.86 19.23 19.23 0 0 0-7.19-8.6 19.76 19.76 0 0 0-21.66 0c-3.21 2.11-5.71 5.1-7.19 8.6a18.82 18.82 0 0 0 4.23 20.86L24 50.4Z\" fill=\"currentColor\"/><path d=\"M37.26 35.75 24 49.34 10.75 35.76l-.01-.01A18.07 18.07 0 0 1 6.68 15.7a18.48 18.48 0 0 1 6.9-8.26 19 19 0 0 1 20.84 0 18.48 18.48 0 0 1 6.9 8.26 18.07 18.07 0 0 1-4.06 20.04Z\" stroke=\"#fff\" stroke-width=\"1.5\"/></g><circle cx=\"24\" cy=\"22.45\" fill=\"#fff\" r=\"5.85\"/><defs><filter id=\"a\" x=\".5\" y=\".6\" width=\"47\" height=\"54.8\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"/><feColorMatrix in=\"SourceAlpha\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\"/><feOffset dy=\"1\"/><feGaussianBlur stdDeviation=\"2\"/><feColorMatrix values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0\"/><feBlend in2=\"BackgroundImageFix\" result=\"effect1_dropShadow_17_871\"/><feBlend in=\"SourceGraphic\" in2=\"effect1_dropShadow_17_871\" result=\"shape\"/></filter></defs></svg>';\n\n// src/icons/street.svg\nvar street_default = '<svg width=\"24\" height=\"24\" viewBox=\"0 0 18 18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M1.08 14.94 5.625 3.06h1.17l-3.42 11.88H1.08Zm15.885 0L12.42 3.06h-1.17l3.42 11.88h2.295Zm-6.86-1.44H7.946l.128-2.61h1.912l.119 2.61Zm-.217-4.77H8.181l.088-1.8h1.537l.082 1.8ZM9.74 5.49h-1.4l.049-.99h1.306l.045.99Z\" fill=\"currentColor\" />\\n</svg>';\n\n// src/icons/addressMarker.svg\nvar addressMarker_default = `<!-- TODO: I'm not sure if the way I added the circle will \"scale\" properly, need to check that -->\n<svg width=\"24\" height=\"24\" viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.5\" d=\"M4 7a5 5 0 1 1 10 0c0 3.025-3.28 6.713-5 9-1.72-2.287-5-5.975-5-9z\"></path>\n    <circle cx=\"9\" cy=\"7\" r=\"2\" fill=\"currentColor\"></circle>\n</svg>`;\n\n// src/icons/search.svg\nvar search_default = '<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\\n  <path d=\"M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z\"/>\\n</svg>';\n\n// package.json\nvar version = \"1.0.0-beta.21\";\n\n// src/theme.ts\nvar styleToggleSatelliteImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-satellite.jpg`;\nvar styleToggleDefaultImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-default.jpg`;\nvar MOBILE_BREAKPOINT = 768 - 1;\nvar MOBILE_MEDIA_QUERY = `@media only screen and (max-width: ${MOBILE_BREAKPOINT}px)`;\nvar DEFAULT_THEME = {\n  variables: {\n    unit: [\"mobile\", \"16px\", \"14px\"],\n    unitHeader: [\"mobile\", \"24px\", \"18px\"],\n    minWidth: \"min(300px, 100vw)\",\n    spacing: \"0.75em\",\n    padding: \"0.5em 0.75em\",\n    paddingFooterLabel: \"0.5em 0.75em\",\n    paddingModal: \"1.25em\",\n    colorText: \"rgba(0, 0, 0, 0.75)\",\n    colorPrimary: \"#4264FB\",\n    colorSecondary: \"#667F91\",\n    colorBackground: \"#fff\",\n    colorBackgroundHover: \"#f5f5f5\",\n    colorBackgroundActive: \"#f0f0f0\",\n    colorBackdrop: \"rgba(102, 127, 145, 0.3)\",\n    border: \"none\",\n    borderRadius: \"4px\",\n    boxShadow: `\n      0 0 10px 2px rgba(0, 0, 0, 0.05),\n      0 0 6px 1px rgba(0, 0, 0, 0.1),\n      0 0 0 1px rgba(0, 0, 0, 0.1)\n    `,\n    lineHeight: \"1.2em\",\n    fontFamily: `\n      -apple-system, BlinkMacSystemFont,\n      avenir next, avenir,\n      segoe ui,\n      helvetica neue, helvetica,\n      Ubuntu, roboto, noto, arial, sans-serif\n    `,\n    fontWeight: \"normal\",\n    fontWeightSemibold: \"600\",\n    fontWeightBold: \"bold\",\n    duration: \"150ms\",\n    curve: \"ease-out\"\n  },\n  icons: {\n    close: close_default,\n    question: question_default,\n    marker: marker_default,\n    street: street_default,\n    addressMarker: addressMarker_default,\n    search: search_default\n  },\n  images: {\n    styleToggleDefault: styleToggleDefaultImg,\n    styleToggleSatellite: styleToggleSatelliteImg\n  }\n};\nfunction getThemeCSS(rootSelector, theme = {}) {\n  const variables = __spreadValues(__spreadValues({}, DEFAULT_THEME.variables), theme.variables || {});\n  let cssText = theme.cssText || \"\";\n  let rootVariables = \"\";\n  for (const [key, value] of Object.entries(variables)) {\n    if (!Array.isArray(value)) {\n      rootVariables += `--${key}: ${value};`;\n      continue;\n    }\n    if (value[0] !== \"mobile\") {\n      const valueStr = JSON.stringify(value);\n      throw new Error(`Unsupported expression in theme variables: ${key} ${valueStr}`);\n    }\n    const [, mobileValue, desktopValue] = value;\n    cssText += `${MOBILE_MEDIA_QUERY} { ${rootSelector} { --${key}: ${mobileValue} !important; } }`;\n    rootVariables += `--${key}: ${desktopValue};`;\n  }\n  return cssText + `${rootSelector} { ${rootVariables} }`;\n}\nfunction getIcon(iconName, theme = {}) {\n  const icons = __spreadValues(__spreadValues({}, DEFAULT_THEME.icons), theme.icons || {});\n  const svgString = icons[iconName];\n  return svgString;\n}\nfunction getImage(imageName, theme = {}) {\n  const images = __spreadValues(__spreadValues({}, DEFAULT_THEME.images), theme.images || {});\n  const imgString = images[imageName];\n  return imgString;\n}\n\n// src/utils/popover.ts\n\nvar _options, _defaultOptions;\nvar Popover = class {\n  constructor(referenceEl, floatingEl, options) {\n    __privateAdd(this, _options, void 0);\n    __privateAdd(this, _defaultOptions, {\n      placement: \"bottom-start\",\n      flip: false,\n      offset: 10\n    });\n    this.update = () => __async(this, null, function* () {\n      const config2 = {\n        placement: this.options.placement,\n        middleware: [\n          (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset)(this.options.offset),\n          this.options.flip && (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.flip)()\n        ].filter(Boolean)\n      };\n      const { x, y } = yield (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition)(this.referenceEl, this.floatingEl, config2);\n      Object.assign(this.floatingEl.style, {\n        left: `${x}px`,\n        top: `${y}px`\n      });\n    });\n    this.referenceEl = referenceEl;\n    this.floatingEl = floatingEl;\n    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _defaultOptions)), options));\n    this.destroy = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.autoUpdate)(this.referenceEl, this.floatingEl, this.update);\n  }\n  get options() {\n    return __privateGet(this, _options);\n  }\n  set options(newOptions) {\n    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _options)), newOptions));\n  }\n};\n_options = new WeakMap();\n_defaultOptions = new WeakMap();\n\n// src/style.css\nvar style_default = \"*{box-sizing:border-box!important}[role=button]{cursor:pointer}.MapboxSearch{--width:0;display:none}.Results{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);min-width:var(--minWidth);overflow-y:auto;position:absolute;transform:translateZ(0);transition:visibility var(--duration);width:var(--width);z-index:1000}.Results:not([aria-hidden=true]){visibility:visible}.Results[aria-hidden=true]{animation:fadein var(--duration) var(--curve) reverse forwards;visibility:hidden}.Suggestion{align-items:center;display:flex;padding:var(--padding)}.Suggestion:hover{cursor:pointer}.Suggestion[aria-selected=true]{background-color:var(--colorBackgroundHover)}.Suggestion:active{background-color:var(--colorBackgroundActive)}.SuggestionName{font-weight:var(--fontWeightBold)}.SuggestionIcon{margin-right:6px}.SuggestionIcon[aria-hidden=true]{display:none}.ResultsAttribution{padding:var(--paddingFooterLabel)}.ResultsAttribution a{color:var(--colorSecondary)}.ResultsAttribution a:not(:hover){text-decoration:none}.ResultsList{list-style:none;margin:0;padding:0}.Label{display:none}.Geocoder,.SearchBox{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--padding);padding-bottom:0;padding-top:0;position:relative;width:100%}.SearchIcon{fill:#757575;left:.5em}.ActionIcon,.SearchIcon{bottom:0;height:20px;margin:auto 0;position:absolute;top:0;width:20px}.ActionIcon{right:.5em}.ActionIcon>button{background:none;border:none;color:inherit;cursor:pointer;font:inherit;height:100%;outline:inherit;padding:0;width:100%}.ActionIcon>button:hover{background:none!important}.ClearBtn{display:none}.ClearBtn:hover{color:#909090}.LoadingIcon{-moz-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;-webkit-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;display:none;height:100%}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.Input{background-color:transparent;border:0;color:#404040;color:rgba(0,0,0,.75);font:inherit;height:36px;margin:0;overflow:hidden;padding:0 40px;text-overflow:ellipsis;white-space:nowrap;width:100%}.Input::-ms-clear{display:none}.Input:focus{border:thin dotted;border-radius:var(--borderRadius);box-shadow:none;color:#404040;color:rgba(0,0,0,.75);outline:0}mapbox-address-confirmation-feature[aria-hidden=true],mapbox-address-confirmation-no-feature[aria-hidden=true]{display:none}.MapboxAddressConfirmation{align-items:center;background-color:var(--colorBackdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;transform:translateZ(0);z-index:1000}.MapboxAddressConfirmation:not([aria-hidden=true]){animation:fadein var(--duration) var(--curve) forwards;visibility:visible}.MapboxAddressConfirmation[aria-hidden=true]{visibility:hidden}.ContentFeature,.ContentNoFeature{width:var(--minWidth)}.Modal{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--paddingModal);width:100%}@media screen and (max-width:480px){.MapboxAddressConfirmation{align-items:flex-end}.ContentFeature,.ContentNoFeature{width:100%}.Modal{border-bottom-left-radius:0;border-bottom-right-radius:0}}.ModalHeader{align-items:center;color:var(--colorPrimary);display:flex;font-size:var(--unitHeader);font-weight:var(--fontWeightBold);margin-bottom:var(--spacing);user-select:none;width:100%}.ModalMap{height:calc(var(--minWidth)*9/16);margin-left:calc(var(--paddingModal)*-1);width:calc(100% + var(--paddingModal)*2)}.ModalMap[aria-hidden=true]{display:none}.Icon{height:var(--unitHeader);width:var(--unitHeader)}.Icon.IconClose{color:var(--colorSecondary)}.ModalHeaderTitle{flex:1;margin-left:.25em}.ModalFooter{color:var(--colorSecondary);margin-top:var(--spacing);text-align:center}.ModalFooter[aria-hidden=true]{display:none}.ModalSubheader{font-weight:var(--fontWeightBold);user-select:none}.ModalDescription{color:var(--colorPrimary)}.ModalAddress,.ModalSubheader{margin-bottom:var(--spacing)}.ModalAddress.ModalAddressApprove{color:var(--colorPrimary)}.Button{border-radius:var(--borderRadius);cursor:pointer;font-weight:var(--fontWeightSemibold);margin-top:var(--spacing);padding:var(--padding);text-align:center;user-select:none;width:100%}.Button[aria-hidden=true]{display:none}.Button.ButtonPrimary{background-color:var(--colorPrimary);color:var(--colorBackground)}.Button.ButtonSecondary{border:1px solid var(--colorSecondary);color:var(--colorSecondary)}@keyframes fadein{0%{opacity:0}to{opacity:1}}.MapboxAddressMinimap{font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight)}.MapboxAddressMinimap[aria-hidden=true]{display:none}.MinimapImageContainer{border-radius:var(--borderRadius);overflow:hidden}.MinimapImage{height:unset;max-height:unset;max-width:unset;position:relative;width:unset}.MinimapInnerFrame{border:var(--border);border-radius:inherit;height:inherit;left:0;overflow:hidden;position:absolute;top:0;width:inherit}.MinimapMarker{left:50%;position:absolute;top:50%}.MinimapMarker>svg{color:var(--colorPrimary);display:block!important}.MinimapAttributionLogo{bottom:0;left:0;margin:0 0 6px 6px;position:absolute}.MinimapAttributionLogo a{cursor:pointer;display:block;height:23px;width:88px}.MinimapAttributionText{background-color:hsla(0,0%,100%,.65);bottom:0;font:11px/16px Helvetica Neue,Arial,Helvetica,sans-serif;padding:0 5px;position:absolute;right:0}.MinimapAttributionText a{color:rgba(0,0,0,.75);text-decoration:none}.MinimapAttributionText a:hover{color:inherit;text-decoration:underline}.MinimapAttributionText a:not(:first-child){margin-left:3px}.MinimapStyleToggle{background-position:0;background-repeat:no-repeat;background-size:contain;border:2px solid #fff;border-radius:3px;box-shadow:var(--boxShadow);cursor:pointer;height:2em;position:absolute;right:var(--spacing);top:var(--spacing);width:2em}.MinimapFooter{color:var(--colorSecondary);font-family:var(--fontFamily);font-size:var(--unit);margin-top:var(--spacing)}.MinimapFooter[aria-hidden=true]{display:none}.MinimapEditButtons{bottom:26px;display:flex;font-family:var(--fontFamily);position:absolute;right:var(--spacing)}.MinimapEditButtons .Button{box-shadow:var(--boxShadow)}.MinimapButtonCancel{background-color:var(--colorBackground);margin-left:var(--spacing)}.draggable{cursor:move;cursor:grab}.draggable:active{cursor:grabbing}\";\n\n// src/MapboxHTMLEvent.ts\nvar MapboxHTMLEvent = class extends CustomEvent {\n  constructor(type, detail) {\n    super(type, {\n      composed: true,\n      detail\n    });\n  }\n  clone(newTarget) {\n    const eventClone = new MapboxHTMLEvent(this.type, this.detail);\n    if (newTarget) {\n      Object.defineProperty(eventClone, \"target\", { value: newTarget });\n    }\n    return eventClone;\n  }\n};\n\n// src/utils/aria/messages.ts\nvar LENGTH_MESSAGE = \"Type in 2 or more characters for results.\";\nvar KEYBOARD_NAVIGATION_GUIDE_MESSAGE = \"When autocomplete results are available use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.\";\nvar NO_SEARCH_RESULTS_MESSAGE = \"No search results.\";\nvar getSuggestionSelectedMessage = (address, numberOfResults, currentIndex) => `${numberOfResults} ${numberOfResults === 1 ? \"result is\" : \"results are\"} available. ${address}. ${currentIndex} of ${numberOfResults} is selected.`;\nvar getSuggestionsReadyMessage = (numberOfResults) => `${numberOfResults} ${numberOfResults === 1 ? \"result is\" : \"results are\"} available. Use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.`;\n\n// src/utils/aria/index.ts\nfunction ariaButtonKeyDown(e) {\n  const el = e.currentTarget;\n  if (e.key === \" \" || e.key === \"Enter\") {\n    e.preventDefault();\n    e.stopPropagation();\n    el.dispatchEvent(new MouseEvent(\"click\", {\n      bubbles: true,\n      composed: true\n    }));\n  }\n}\nvar ARIA_DESCRIPTION_ID = \"search-listbox__description\";\nvar createAriaLiveElement = (seed) => {\n  const container = document.createElement(\"div\");\n  container.setAttribute(\"aria-live\", \"polite\");\n  container.setAttribute(\"aria-atomic\", \"true\");\n  container.setAttribute(\"role\", \"status\");\n  container.setAttribute(\"style\", \"border: 0px;clip: rect(0px, 0px, 0px, 0px);height: 1px;margin-bottom: -1px;margin-right: -1px;overflow: hidden;padding: 0px;position: absolute;white-space: nowrap;width: 1px;\");\n  const description = document.createElement(\"div\");\n  description.setAttribute(\"id\", `${seed}--${ARIA_DESCRIPTION_ID}`);\n  container.appendChild(description);\n  return container;\n};\nvar setLiveRegionMessage = (message, seed) => {\n  var _a;\n  const description = (_a = document.body.querySelector(`[id=\"${seed}--${ARIA_DESCRIPTION_ID}\"]`)) != null ? _a : null;\n  if (description) {\n    description.textContent = message;\n  }\n};\nvar suppressExtensionsAutocomplete = (input) => {\n  input.name = input.name + \" address-search\";\n  input.setAttribute(\"data-lpignore\", \"true\");\n};\nvar getAriaMessage = (searchValue, suggestions, selectedIndex) => {\n  let ariaMessage = null;\n  const noResults = !suggestions || suggestions.length === 0;\n  if ((searchValue == null ? void 0 : searchValue.length) < 2) {\n    ariaMessage = LENGTH_MESSAGE + \" \" + KEYBOARD_NAVIGATION_GUIDE_MESSAGE;\n  } else if (noResults) {\n    ariaMessage = NO_SEARCH_RESULTS_MESSAGE;\n  } else if (selectedIndex !== void 0) {\n    const suggestion = suggestions[selectedIndex];\n    const placeName = suggestion.name || suggestion.feature_name || suggestion.properties.name;\n    ariaMessage = getSuggestionSelectedMessage(placeName, suggestions.length, selectedIndex + 1);\n  } else {\n    ariaMessage = getSuggestionsReadyMessage(suggestions.length);\n  }\n  return ariaMessage;\n};\n\n// src/utils/listbox.ts\nvar getSuggestionTitle = (item, service) => {\n  switch (service) {\n    case 0 /* AddressAutofill */:\n      return item.matching_name || item.feature_name || item.address_line1;\n    case 2 /* SearchBox */:\n      return item.name;\n    case 1 /* Geocoding */:\n      return item.properties.name;\n    default:\n      return \"\";\n  }\n};\nvar buildSuggestionDescription = (item, service) => {\n  switch (service) {\n    case 0 /* AddressAutofill */:\n      return item.description;\n    case 2 /* SearchBox */:\n      if (item.feature_type === \"poi\") {\n        return item.full_address;\n      }\n      return item.place_formatted;\n    case 1 /* Geocoding */:\n      return item.properties.place_formatted;\n    default:\n      return \"\";\n  }\n};\n\n// src/components/MapboxSearchListbox.ts\nfunction getAriaIdForSuggestion(resultListId, i) {\n  return `${resultListId}-${i}`;\n}\nvar _popover, _binding, _labelID, _resultListID, _inputInternal, _searchService, _selectedIndexInternal, _showResults, showResults_fn, _renderResultsList, renderResultsList_fn, _themeInternal, _popoverOptions, _handleInput, _handleSelect, _handleFocus, _handleBlur, _handleKeyDown;\nvar MapboxSearchListbox = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _showResults);\n    __privateAdd(this, _renderResultsList);\n    this.suggestions = null;\n    __privateAdd(this, _popover, null);\n    __privateAdd(this, _binding, void 0);\n    __privateAdd(this, _labelID, void 0);\n    __privateAdd(this, _resultListID, void 0);\n    __privateAdd(this, _inputInternal, void 0);\n    __privateAdd(this, _searchService, null);\n    __privateAdd(this, _selectedIndexInternal, void 0);\n    __privateAdd(this, _themeInternal, {});\n    __privateAdd(this, _popoverOptions, {});\n    __privateAdd(this, _handleInput, (e) => {\n      const { Results } = __privateGet(this, _binding);\n      const input = e.target;\n      if (input.dataset[\"mapboxSuccess\"]) {\n        delete input.dataset[\"mapboxSuccess\"];\n        return;\n      }\n      const searchText = input.value;\n      this.renderAriaMessage();\n      Results.setAttribute(\"aria-busy\", \"true\");\n      this.dispatchEvent(new MapboxHTMLEvent(\"input\", searchText));\n    });\n    this.renderAriaMessage = () => {\n      var _a;\n      const message = getAriaMessage((_a = this.input) == null ? void 0 : _a.value, this.suggestions, this.selectedIndex);\n      setLiveRegionMessage(message, this.dataset.seed);\n    };\n    this.clearAriaMessage = () => {\n      setLiveRegionMessage(\"\", this.dataset.seed);\n    };\n    this.handleSuggest = (suggestions) => {\n      this.suggestions = suggestions;\n      if (!suggestions || suggestions.length === 0) {\n        this.renderAriaMessage();\n      }\n      if (!suggestions) {\n        this.hideResults();\n        return;\n      }\n      __privateMethod(this, _renderResultsList, renderResultsList_fn).call(this);\n      if (suggestions.length) {\n        __privateMethod(this, _showResults, showResults_fn).call(this);\n      }\n      const { Results } = __privateGet(this, _binding);\n      Results.setAttribute(\"aria-busy\", \"false\");\n    };\n    this.handleError = () => {\n      const { Results } = __privateGet(this, _binding);\n      Results.setAttribute(\"aria-busy\", \"false\");\n      this.hideResults();\n    };\n    __privateAdd(this, _handleSelect, (suggestion) => __async(this, null, function* () {\n      const input = this.input;\n      if (input) {\n        input.dataset[\"mapboxSuccess\"] = \"true\";\n      }\n      this.dispatchEvent(new MapboxHTMLEvent(\"select\", suggestion));\n      this.hideResults();\n    }));\n    __privateAdd(this, _handleFocus, () => {\n      const input = this.input;\n      delete input.dataset[\"mapboxSuccess\"];\n      this.dispatchEvent(new MapboxHTMLEvent(\"focus\"));\n      this.renderAriaMessage();\n      __privateMethod(this, _showResults, showResults_fn).call(this);\n    });\n    __privateAdd(this, _handleBlur, () => {\n      if (document.activeElement === this.input) {\n        return;\n      }\n      this.dispatchEvent(new MapboxHTMLEvent(\"blur\"));\n      this.clearAriaMessage();\n      this.hideResults();\n    });\n    this.handleArrowUp = () => {\n      if (this.selectedIndex === void 0) {\n        this.selectedIndex = this.suggestions.length - 1;\n      } else if (this.selectedIndex === 0) {\n        this.selectedIndex = void 0;\n      } else {\n        this.selectedIndex = Math.max(0, this.selectedIndex - 1);\n      }\n    };\n    this.handleArrowDown = () => {\n      if (this.selectedIndex === void 0) {\n        this.selectedIndex = 0;\n      } else if (this.selectedIndex === this.suggestions.length - 1) {\n        this.selectedIndex = void 0;\n      } else {\n        this.selectedIndex = Math.min(this.selectedIndex + 1, this.suggestions.length - 1);\n      }\n    };\n    __privateAdd(this, _handleKeyDown, (e) => {\n      var _a;\n      if (!((_a = this.suggestions) == null ? void 0 : _a.length))\n        return;\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        this.handleArrowDown();\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        this.handleArrowUp();\n        return;\n      }\n      if (e.key === \"Escape\") {\n        this.hideResults();\n        return;\n      }\n      if (this.selectedIndex === void 0) {\n        return;\n      }\n      if (e.key === \"Tab\") {\n        __privateGet(this, _handleSelect).call(this, this.suggestions[this.selectedIndex]);\n        return;\n      }\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n        __privateGet(this, _handleSelect).call(this, this.suggestions[this.selectedIndex]);\n        return;\n      }\n    });\n  }\n  get template() {\n    return LISTBOX_TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxSearch\", this.theme);\n  }\n  get input() {\n    return __privateGet(this, _inputInternal);\n  }\n  set input(newInput) {\n    const oldInput = __privateGet(this, _inputInternal);\n    if (oldInput) {\n      oldInput.removeEventListener(\"input\", __privateGet(this, _handleInput));\n      oldInput.removeEventListener(\"focus\", __privateGet(this, _handleFocus));\n      oldInput.removeEventListener(\"blur\", __privateGet(this, _handleBlur));\n      oldInput.removeEventListener(\"keydown\", __privateGet(this, _handleKeyDown));\n      if (__privateGet(this, _popover)) {\n        __privateGet(this, _popover).destroy();\n      }\n    }\n    if (newInput) {\n      newInput.addEventListener(\"input\", __privateGet(this, _handleInput));\n      newInput.addEventListener(\"focus\", __privateGet(this, _handleFocus));\n      newInput.addEventListener(\"blur\", __privateGet(this, _handleBlur));\n      newInput.addEventListener(\"keydown\", __privateGet(this, _handleKeyDown));\n      newInput.setAttribute(\"role\", \"combobox\");\n      newInput.setAttribute(\"aria-autocomplete\", \"list\");\n      newInput.setAttribute(\"aria-controls\", __privateGet(this, _resultListID));\n      if (this.isConnected) {\n        __privateSet(this, _popover, new Popover(newInput, __privateGet(this, _binding).Results, this.popoverOptions));\n      }\n    }\n    __privateSet(this, _inputInternal, newInput);\n  }\n  get searchService() {\n    return __privateGet(this, _searchService);\n  }\n  set searchService(service) {\n    __privateSet(this, _searchService, service);\n  }\n  get selectedIndex() {\n    return __privateGet(this, _selectedIndexInternal);\n  }\n  set selectedIndex(newIndex) {\n    const oldIndex = __privateGet(this, _selectedIndexInternal);\n    __privateSet(this, _selectedIndexInternal, newIndex);\n    const { ResultsList } = __privateGet(this, _binding);\n    const id = getAriaIdForSuggestion(__privateGet(this, _resultListID), newIndex);\n    if (newIndex !== void 0) {\n      this.input.setAttribute(\"aria-activedescendant\", id);\n      ResultsList.setAttribute(\"aria-activedescendant\", id);\n    } else {\n      this.input.removeAttribute(\"aria-activedescendant\");\n      ResultsList.removeAttribute(\"aria-activedescendant\");\n    }\n    if (oldIndex !== newIndex) {\n      const oldId = getAriaIdForSuggestion(__privateGet(this, _resultListID), oldIndex);\n      const oldEl = ResultsList.querySelector(`#${oldId}`);\n      oldEl == null ? void 0 : oldEl.removeAttribute(\"aria-selected\");\n      oldEl == null ? void 0 : oldEl.setAttribute(\"tabindex\", \"-1\");\n      if (newIndex !== void 0) {\n        const el = ResultsList.querySelector(`#${id}`);\n        el == null ? void 0 : el.setAttribute(\"aria-selected\", \"true\");\n        el == null ? void 0 : el.setAttribute(\"tabindex\", \"0\");\n      }\n    }\n    this.renderAriaMessage();\n  }\n  hideResults() {\n    const { Results, ResultsList } = __privateGet(this, _binding);\n    Results.setAttribute(\"aria-hidden\", \"true\");\n    this.input.setAttribute(\"aria-expanded\", \"false\");\n    ResultsList.removeAttribute(\"aria-activedescendant\");\n    this.input.removeAttribute(\"aria-activedescendant\");\n  }\n  renderItem(i) {\n    const element = this.prepareTemplate(LISTBOX_SUGGESTION_TEMPLATE);\n    element.id = getAriaIdForSuggestion(__privateGet(this, _resultListID), i);\n    return element;\n  }\n  fillItem(el, item, i, totalLength) {\n    const iconEl = el.querySelector('[class$=\"SuggestionIcon\"]');\n    const nameEl = el.querySelector('[class$=\"SuggestionName\"]');\n    const descriptionEl = el.querySelector('[class$=\"SuggestionDesc\"]');\n    if (this.searchService === 0 /* AddressAutofill */) {\n      iconEl.innerHTML = getIcon(item.accuracy === \"street\" ? \"street\" : \"addressMarker\", this.theme);\n      iconEl.removeAttribute(\"aria-hidden\");\n    } else {\n      iconEl.setAttribute(\"aria-hidden\", \"true\");\n    }\n    nameEl.textContent = descriptionEl.textContent = \"\";\n    nameEl.textContent = getSuggestionTitle(item, this.searchService);\n    descriptionEl.textContent = buildSuggestionDescription(item, this.searchService);\n    if (i === this.selectedIndex) {\n      el.setAttribute(\"aria-selected\", \"true\");\n    } else {\n      el.removeAttribute(\"aria-selected\");\n    }\n    el.setAttribute(\"aria-posinset\", (i + 1).toString());\n    el.setAttribute(\"aria-setsize\", totalLength.toString());\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal, theme);\n    if (!__privateGet(this, _binding) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxSearch\", theme));\n  }\n  get popoverOptions() {\n    return __privateGet(this, _popoverOptions);\n  }\n  set popoverOptions(newOptions) {\n    __privateSet(this, _popoverOptions, newOptions);\n    if (__privateGet(this, _popover)) {\n      __privateGet(this, _popover).options = newOptions;\n      __privateGet(this, _popover).update();\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.dataSeed = this.dataset.seed;\n    __privateSet(this, _labelID, this.dataset.seed + \"-Label\");\n    __privateSet(this, _resultListID, this.dataset.seed + \"-ResultsList\");\n    if (this.input) {\n      this.input.setAttribute(\"aria-controls\", __privateGet(this, _resultListID));\n    }\n    __privateSet(this, _binding, bindElements(this, {\n      MapboxSearch: \".MapboxSearch\",\n      Results: \".Results\",\n      ResultsList: \".ResultsList\",\n      Label: \".Label\"\n    }));\n    const { Results, ResultsList, Label } = __privateGet(this, _binding);\n    Label.id = __privateGet(this, _labelID);\n    ResultsList.id = __privateGet(this, _resultListID);\n    ResultsList.setAttribute(\"aria-labelledby\", __privateGet(this, _labelID));\n    Results.addEventListener(\"blur\", __privateGet(this, _handleBlur));\n    if (!__privateGet(this, _popover) && this.input) {\n      __privateSet(this, _popover, new Popover(this.input, __privateGet(this, _binding).Results, this.popoverOptions));\n    }\n    requestAnimationFrame(() => {\n      if (__privateGet(this, _popover)) {\n        __privateGet(this, _popover).update();\n      }\n    });\n  }\n  disconnectedCallback() {\n    this.input = null;\n    const { Results } = __privateGet(this, _binding);\n    Results.removeEventListener(\"blur\", __privateGet(this, _handleBlur));\n    if (__privateGet(this, _popover))\n      __privateGet(this, _popover).destroy();\n  }\n  focus() {\n    if (document.activeElement === this.input) {\n      __privateGet(this, _handleFocus).call(this);\n    } else {\n      this.input.focus();\n    }\n  }\n  blur() {\n    this.input.blur();\n  }\n  updatePopover() {\n    if (__privateGet(this, _popover)) {\n      __privateGet(this, _popover).update();\n    }\n  }\n};\n_popover = new WeakMap();\n_binding = new WeakMap();\n_labelID = new WeakMap();\n_resultListID = new WeakMap();\n_inputInternal = new WeakMap();\n_searchService = new WeakMap();\n_selectedIndexInternal = new WeakMap();\n_showResults = new WeakSet();\nshowResults_fn = function() {\n  if (!this.suggestions || !this.suggestions.length) {\n    return;\n  }\n  const { Results, MapboxSearch } = __privateGet(this, _binding);\n  const rect = this.input.getBoundingClientRect();\n  MapboxSearch.style.setProperty(\"--width\", `${rect.width}px`);\n  MapboxSearch.style.setProperty(\"display\", \"block\");\n  this.input.setAttribute(\"aria-expanded\", \"true\");\n  Results.removeAttribute(\"aria-hidden\");\n  this.selectedIndex = void 0;\n};\n_renderResultsList = new WeakSet();\nrenderResultsList_fn = function() {\n  const { ResultsList } = __privateGet(this, _binding);\n  if (!this.suggestions || !this.suggestions.length) {\n    ResultsList.innerHTML = \"\";\n    this.hideResults();\n    return;\n  }\n  const elements = getChildElements(ResultsList);\n  if (this.suggestions.length > elements.length) {\n    for (let i = elements.length; i < this.suggestions.length; i++) {\n      const item = this.renderItem(i);\n      elements.push(item);\n      item.onmouseenter = () => {\n        this.selectedIndex = i;\n      };\n      item.onmouseleave = () => {\n        this.selectedIndex = void 0;\n      };\n      ResultsList.appendChild(item);\n    }\n  }\n  if (this.suggestions.length < elements.length) {\n    for (let i = this.suggestions.length; i < elements.length; i++) {\n      elements[i].remove();\n    }\n  }\n  for (const suggestion of this.suggestions) {\n    const i = this.suggestions.indexOf(suggestion);\n    const element = elements[i];\n    this.fillItem(element, suggestion, i, this.suggestions.length);\n    element.onclick = () => {\n      __privateGet(this, _handleSelect).call(this, suggestion);\n    };\n  }\n};\n_themeInternal = new WeakMap();\n_popoverOptions = new WeakMap();\n_handleInput = new WeakMap();\n_handleSelect = new WeakMap();\n_handleFocus = new WeakMap();\n_handleBlur = new WeakMap();\n_handleKeyDown = new WeakMap();\nwindow.MapboxSearchListbox = MapboxSearchListbox;\nif (!window.customElements.get(\"mapbox-search-listbox\")) {\n  customElements.define(\"mapbox-search-listbox\", MapboxSearchListbox);\n}\n\n// src/utils/autofill.ts\n\nvar AUTOFILL_TOKENS = /* @__PURE__ */ new Set([\n  \"street-address\",\n  \"address-line1\",\n  \"address-line2\",\n  \"address-line3\",\n  \"address-level4\",\n  \"address-level3\",\n  \"address-level2\",\n  \"address-level1\",\n  \"country\",\n  \"country-name\",\n  \"postal-code\"\n]);\nvar AUTOFILL_SKIP_TOKENS = /* @__PURE__ */ new Set([\"off\", \"on\", \"true\", \"false\"]);\nfunction findParentForm(el) {\n  let node = el.parentNode;\n  while (node) {\n    if (node instanceof HTMLFormElement) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction findAddressInputs(form) {\n  const parent = form || document;\n  return Array.from(parent.querySelectorAll('input[autocomplete~=\"address-line1\"], input[autocomplete~=\"street-address\"]'));\n}\nvar SECTION = \"section-\";\nvar SECTION_DEFAULT = \"section-default\";\nvar SECTION_SHIPPING = \"section-shipping\";\nvar SECTION_BILLING = \"section-billing\";\nfunction parseFormStructure(form) {\n  const inputs = Array.from(form.querySelectorAll(\"[autocomplete]\")).filter((el) => {\n    const tagName = el.tagName.toLowerCase();\n    return tagName === \"input\" || tagName === \"select\" || tagName === \"textarea\";\n  });\n  const res = [];\n  for (const input of inputs) {\n    if (!isVisible(input)) {\n      continue;\n    }\n    const autocomplete = input.getAttribute(\"autocomplete\") || \"\";\n    if (!autocomplete || AUTOFILL_SKIP_TOKENS.has(autocomplete)) {\n      continue;\n    }\n    const tokens = autocomplete.toLowerCase().split(\" \");\n    if (tokens.length > 3) {\n      continue;\n    }\n    const field = tokens[tokens.length - 1];\n    if (!AUTOFILL_TOKENS.has(field)) {\n      continue;\n    }\n    tokens.pop();\n    let section = SECTION_DEFAULT;\n    if (tokens.length) {\n      const sectionToken = tokens[tokens.length - 1];\n      if (sectionToken === \"shipping\") {\n        section = SECTION_SHIPPING;\n        tokens.pop();\n      }\n      if (sectionToken === \"billing\") {\n        section = SECTION_BILLING;\n        tokens.pop();\n      }\n    }\n    if (tokens.length) {\n      const sectionToken = tokens[tokens.length - 1];\n      if (sectionToken.startsWith(SECTION)) {\n        section = sectionToken;\n      }\n    }\n    res.push({\n      input,\n      section,\n      field\n    });\n  }\n  return res;\n}\nfunction findAddressAutofillInputs(form, ref) {\n  const logicalSections = [];\n  const logicalSectionSections = [];\n  const formStructure = parseFormStructure(form);\n  let foundSection = null;\n  for (const { input, section, field } of formStructure) {\n    let lastIndex = logicalSections.length - 1;\n    let createNewSection = false;\n    if (!logicalSections.length) {\n      createNewSection = true;\n    } else if (logicalSectionSections[lastIndex] !== section) {\n      createNewSection = true;\n    } else if (logicalSections[lastIndex][field]) {\n      createNewSection = true;\n    }\n    if (createNewSection) {\n      if (foundSection) {\n        break;\n      }\n      logicalSections.push({\n        [field]: input\n      });\n      logicalSectionSections.push(section);\n      lastIndex++;\n    } else {\n      logicalSections[lastIndex][field] = input;\n    }\n    if (input === ref) {\n      foundSection = logicalSections[lastIndex];\n    }\n  }\n  return foundSection != null ? foundSection : {};\n}\nfunction setFormAutofillValues(form, ref, suggestion) {\n  var _a;\n  const map = findAddressAutofillInputs(form, ref);\n  const streetAddress = [\n    suggestion.address_line1,\n    suggestion.address_line2,\n    suggestion.address_line3\n  ].filter((part) => Boolean(part)).join(\", \");\n  setValue(map[\"street-address\"], map[\"address-line2\"] ? suggestion.address_line1 || \"\" : streetAddress);\n  setValue(map[\"address-line1\"], suggestion.address_line1 || \"\");\n  setValue(map[\"address-line2\"], suggestion.address_line2 || \"\");\n  setValue(map[\"address-level1\"], suggestion.address_level1 || \"\");\n  setValue(map[\"address-level2\"], suggestion.address_level2 || \"\");\n  setValue(map[\"address-level3\"], suggestion.address_level3 || \"\");\n  const countryCode = suggestion.country_code || ((_a = suggestion.metadata) == null ? void 0 : _a.iso_3166_1) || \"\";\n  if (map.country && map.country instanceof HTMLSelectElement) {\n    let firstOption = map.country.querySelector(`option`).value;\n    if (firstOption === \"\") {\n      firstOption = map.country.querySelectorAll(`option`)[1].value;\n    }\n    const isUpperCase = firstOption === firstOption.toUpperCase();\n    setValue(map[\"country\"], isUpperCase ? countryCode.toUpperCase() : countryCode);\n  } else {\n    setValue(map[\"country\"], countryCode);\n  }\n  setValue(map[\"country-name\"], suggestion.country || \"\");\n  setValue(map[\"postal-code\"], suggestion.postcode || \"\");\n}\nfunction getFormAutofillValues(form, ref) {\n  const map = findAddressAutofillInputs(form, ref);\n  const values = {};\n  for (const [key, input] of Object.entries(map)) {\n    if (input == null ? void 0 : input.value) {\n      values[key] = input.value;\n    }\n  }\n  return values;\n}\nfunction getAutofillSearchText(snapshot) {\n  const searchText = [];\n  if (snapshot[\"street-address\"]) {\n    searchText.push(snapshot[\"street-address\"]);\n  } else {\n    searchText.push(snapshot[\"address-line1\"] || \"\");\n  }\n  searchText.push(snapshot[\"address-line2\"] || \"\");\n  searchText.push(snapshot[\"address-line3\"] || \"\");\n  searchText.push(snapshot[\"address-level3\"] || \"\");\n  searchText.push(snapshot[\"address-level2\"] || \"\");\n  searchText.push(snapshot[\"address-level1\"] || \"\");\n  searchText.push(snapshot[\"postal-code\"] || \"\");\n  if (snapshot[\"country-name\"]) {\n    searchText.push(snapshot[\"country-name\"]);\n  } else {\n    searchText.push(snapshot[\"country\"] || \"\");\n  }\n  return searchText.filter((part) => Boolean(part)).map((part) => part.trim()).join(\", \");\n}\nfunction fillFormWithFeature(feature, input) {\n  const form = findParentForm(input);\n  if (!form) {\n    return;\n  }\n  const suggestion = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.featureToSuggestion)(feature);\n  setFormAutofillValues(form, input, suggestion);\n  const inputMap = findAddressAutofillInputs(form, input);\n  if (inputMap[\"address-line2\"] && !suggestion.address_line2) {\n    inputMap[\"address-line2\"].focus();\n  }\n}\nfunction featureToAutofillValueMap(feature) {\n  var _a;\n  const values = {};\n  const streetAddress = [\n    feature.properties.address_line1,\n    feature.properties.address_line2,\n    feature.properties.address_line3\n  ].filter((part) => Boolean(part)).join(\", \");\n  values[\"street-address\"] = streetAddress;\n  values[\"address-line1\"] = feature.properties.address_line1;\n  values[\"address-line2\"] = feature.properties.address_line2;\n  values[\"address-line3\"] = feature.properties.address_line3;\n  values[\"address-level1\"] = feature.properties.address_level1;\n  values[\"address-level2\"] = feature.properties.address_level2;\n  values[\"address-level3\"] = feature.properties.address_level3;\n  values[\"country\"] = (_a = feature.properties.metadata) == null ? void 0 : _a.iso_3166_1;\n  values[\"country-name\"] = feature.properties.country;\n  values[\"postal-code\"] = feature.properties.postcode;\n  return values;\n}\nfunction checkAutofillValuesChanged(targetMap, referenceMap) {\n  for (const [key, value] of Object.entries(targetMap)) {\n    if (referenceMap[key] !== value)\n      return true;\n  }\n  return false;\n}\nvar distinctExactStreetResults = (suggestions) => {\n  return suggestions.filter((item1, idx, arr) => {\n    const title = getSuggestionTitle(item1, 0 /* AddressAutofill */);\n    return item1.accuracy !== \"street\" || arr.findIndex((item2) => title === getSuggestionTitle(item2, 0 /* AddressAutofill */)) === idx;\n  });\n};\nvar toggleAutocompletion = (input, initialAutocompleteValue, enableBrowserAutocomplete) => {\n  const disableValue = \"new-password\";\n  const defaultFallbackValue = \"address-line1\";\n  const autocompleteValue = enableBrowserAutocomplete ? initialAutocompleteValue || defaultFallbackValue : disableValue;\n  if (input) {\n    input.autocomplete = autocompleteValue;\n  }\n};\nvar handleStreetSelection = (input, initialAutocompleteValue, suggestion) => {\n  if (!input || !suggestion) {\n    return;\n  }\n  toggleAutocompletion(input, initialAutocompleteValue, true);\n  const feature = {\n    properties: __spreadProps(__spreadValues({}, suggestion), {\n      address_line1: suggestion.address_line1 + \" \",\n      postcode: null\n    })\n  };\n  fillFormWithFeature(feature, input);\n  toggleAutocompletion(input, initialAutocompleteValue, false);\n  input == null ? void 0 : input.focus();\n};\n\n// src/confirmAddress.ts\n\n\n// src/components/MapboxAddressConfirmation.ts\n\n\n\n\n// src/config.ts\n\nvar Config = class {\n  constructor() {\n    this.feedbackEnabled = true;\n    this.autofillSessionToken = new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SessionToken();\n    this.autofillSessionEnabled = false;\n    this.detectBrowserAutofillEnabled = false;\n  }\n};\nvar config = new Config();\nObject.defineProperty(config, \"autofillSessionToken\", {\n  configurable: false,\n  writable: false\n});\n\n// src/components/MapboxAddressConfirmation.ts\nvar TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmation\" aria-hidden=\"true\">\n    <mapbox-address-confirmation-feature class=\"ContentFeature\"></mapbox-address-confirmation-feature>\n    <mapbox-address-confirmation-no-feature class=\"ContentNoFeature\"></mapbox-address-confirmation-no-feature>\n  </div>\n</template>\n`);\nvar _show, _binding2, _focusTrap, _themeInternal2;\nvar MapboxAddressConfirmation = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _show, false);\n    __privateAdd(this, _binding2, void 0);\n    __privateAdd(this, _focusTrap, void 0);\n    __privateAdd(this, _themeInternal2, {});\n  }\n  get template() {\n    return TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmation\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal2);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal2, theme);\n    if (!__privateGet(this, _binding2) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmation\", theme));\n    const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n    ContentFeature.theme = theme;\n    ContentNoFeature.theme = theme;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding2, bindElements(this, {\n      MapboxAddressConfirmation: \".MapboxAddressConfirmation\",\n      ContentFeature: \".ContentFeature\",\n      ContentNoFeature: \".ContentNoFeature\"\n    }));\n    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);\n    MapboxAddressConfirmation2.setAttribute(\"aria-hidden\", \"true\");\n    const theme = this.theme;\n    if (theme) {\n      const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n      ContentFeature.theme = theme;\n      ContentNoFeature.theme = theme;\n    }\n  }\n  disconnectedCallback() {\n    __privateSet(this, _focusTrap, null);\n  }\n  hide() {\n    var _a;\n    __privateSet(this, _show, false);\n    if (!__privateGet(this, _binding2)) {\n      return;\n    }\n    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);\n    MapboxAddressConfirmation2.setAttribute(\"aria-hidden\", \"true\");\n    (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.deactivate();\n    no_scroll__WEBPACK_IMPORTED_MODULE_2___default().off();\n  }\n  show(autofillValues, optionsArg, feature) {\n    return __async(this, null, function* () {\n      var _a;\n      if (!__privateGet(this, _binding2)) {\n        return { type: \"cancel\" };\n      }\n      const { MapboxAddressConfirmation: MapboxAddressConfirmation2, ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n      const { accessToken, minimap = false, theme, footer } = optionsArg;\n      this.theme = theme;\n      if (feature) {\n        ContentFeature.removeAttribute(\"aria-hidden\");\n        ContentNoFeature.setAttribute(\"aria-hidden\", \"true\");\n        ContentFeature.minimap = minimap;\n        ContentFeature.accessToken = accessToken;\n        ContentFeature.footer = footer;\n        ContentFeature.update(feature, autofillValues);\n      } else {\n        ContentFeature.setAttribute(\"aria-hidden\", \"true\");\n        ContentNoFeature.removeAttribute(\"aria-hidden\");\n        ContentNoFeature.update(autofillValues);\n      }\n      __privateSet(this, _show, true);\n      MapboxAddressConfirmation2.removeAttribute(\"aria-hidden\");\n      no_scroll__WEBPACK_IMPORTED_MODULE_2___default().on();\n      const activeContentElement = feature ? ContentFeature : ContentNoFeature;\n      __privateSet(this, _focusTrap, (0,focus_trap__WEBPACK_IMPORTED_MODULE_3__.createFocusTrap)(MapboxAddressConfirmation2, {\n        fallbackFocus: activeContentElement,\n        escapeDeactivates: () => {\n          this.hide();\n          return true;\n        }\n      }));\n      (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.activate();\n      return new Promise((resolve) => {\n        const eventHost = activeContentElement;\n        const fn = (e) => {\n          eventHost.removeEventListener(\"result\", fn);\n          const result = e.detail;\n          this.hide();\n          if (result === \"change\") {\n            resolve({\n              type: \"change\",\n              feature\n            });\n          } else {\n            resolve({\n              type: result\n            });\n          }\n        };\n        eventHost.addEventListener(\"result\", fn);\n      });\n    });\n  }\n  tryShow(autofillValues, optionsArg) {\n    return __async(this, null, function* () {\n      if (!__privateGet(this, _binding2)) {\n        return { type: \"cancel\" };\n      }\n      const { accessToken, options = {} } = optionsArg;\n      const validate = new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.ValidationCore(__spreadValues({\n        accessToken\n      }, options));\n      const searchText = getAutofillSearchText(autofillValues);\n      const featureCollection = yield validate.validate(searchText, {\n        sessionToken: config.autofillSessionToken\n      });\n      const feature = featureCollection.features[0];\n      if (feature) {\n        const defaultValidation = (feature2) => feature2.properties.match_code.confidence === _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.MatchCodeConfidence.exact;\n        const { skipConfirmModal = defaultValidation } = optionsArg;\n        if (skipConfirmModal(feature)) {\n          return { type: \"nochange\" };\n        }\n      }\n      return yield this.show(autofillValues, optionsArg, feature);\n    });\n  }\n};\n_show = new WeakMap();\n_binding2 = new WeakMap();\n_focusTrap = new WeakMap();\n_themeInternal2 = new WeakMap();\nwindow.MapboxAddressConfirmation = MapboxAddressConfirmation;\nif (!window.customElements.get(\"mapbox-address-confirmation\")) {\n  customElements.define(\"mapbox-address-confirmation\", MapboxAddressConfirmation);\n}\n\n// src/confirmAddress.ts\nvar confirmation = new MapboxAddressConfirmation();\nfunction confirmAddress(_0) {\n  return __async(this, arguments, function* (form, optionsArg = {}) {\n    var _a;\n    const { sections = [] } = optionsArg;\n    if (!confirmation.parentNode) {\n      document.body.appendChild(confirmation);\n    }\n    let collectedResult = { type: \"nochange\" };\n    const inputs = findAddressInputs(form);\n    const structure = parseFormStructure(form);\n    const listboxComponents = Array.from(document.querySelectorAll(\"mapbox-search-listbox\"));\n    for (const input of inputs) {\n      if (sections.length) {\n        const structureRef = structure.find((s) => s.input === input);\n        if (!structureRef) {\n          continue;\n        }\n        if (!sections.includes(structureRef.section)) {\n          continue;\n        }\n      }\n      const autofillValues = getFormAutofillValues(form, input);\n      const listbox = listboxComponents.find((lb) => lb.input === input);\n      const autofill2 = listbox == null ? void 0 : listbox.autofillHost;\n      if (autofill2) {\n        const lastRetrievedFeature = autofill2.retrieveFeature;\n        if (lastRetrievedFeature) {\n          const snapshot = featureToAutofillValueMap(lastRetrievedFeature);\n          if (!checkAutofillValuesChanged(autofillValues, snapshot)) {\n            continue;\n          }\n        }\n      }\n      const accessToken = optionsArg.accessToken || config.accessToken;\n      const result = yield confirmation.tryShow(autofillValues, __spreadProps(__spreadValues({}, optionsArg), {\n        accessToken\n      }));\n      if (result.type === \"change\") {\n        const inputMap = findAddressAutofillInputs(form, input);\n        if ((_a = inputMap[\"address-line2\"]) == null ? void 0 : _a.value) {\n          result.feature.properties.address_line2 = inputMap[\"address-line2\"].value;\n        }\n        if (listbox) {\n          autofill2.simulateRetrieve(result.feature);\n        } else {\n          input.dataset[\"mapboxSuccess\"] = \"true\";\n          const suggestion = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.featureToSuggestion)(result.feature);\n          setFormAutofillValues(form, input, suggestion);\n        }\n      }\n      if (result.type === \"change\" && collectedResult.type !== \"cancel\") {\n        collectedResult = result;\n      }\n      if (result.type === \"cancel\") {\n        collectedResult = result;\n      }\n    }\n    return collectedResult;\n  });\n}\n\n// src/utils/confirmation.ts\nfunction createAddressElement(autofillValues, baseAddress, featureName, featureDescription, isSecondary) {\n  if (baseAddress) {\n    const element = createElementFromString(`\n        <span>\n          <span></span>\n          <br />\n          <span></span>\n        </span>\n      `);\n    const [firstLine, lastLine] = Array.from(element.querySelectorAll(\"span > span\"));\n    if (featureName && featureDescription) {\n      firstLine.textContent = featureName;\n      lastLine.textContent = featureDescription;\n    } else {\n      const parts = baseAddress.split(\",\");\n      firstLine.textContent = parts[0].trim();\n      lastLine.textContent = parts.slice(1).join(\",\").trim();\n    }\n    if (!isSecondary) {\n      if (autofillValues[\"address-line2\"]) {\n        const span = document.createElement(\"span\");\n        span.textContent = autofillValues[\"address-line2\"];\n        element.insertBefore(span, lastLine);\n        element.insertBefore(document.createElement(\"br\"), lastLine);\n      }\n      if (autofillValues[\"address-line3\"]) {\n        const span = document.createElement(\"span\");\n        span.textContent = autofillValues[\"address-line3\"];\n        element.insertBefore(span, lastLine);\n        element.insertBefore(document.createElement(\"br\"), lastLine);\n      }\n    }\n    return element;\n  } else {\n    const firstLine = autofillValues[\"street-address\"] || autofillValues[\"address-line1\"] || \"\";\n    const line2 = autofillValues[\"address-line2\"];\n    const line3 = autofillValues[\"address-line3\"];\n    const lastLine = [\n      autofillValues[\"address-level4\"] || \"\",\n      autofillValues[\"address-level3\"] || \"\",\n      autofillValues[\"address-level2\"] || \"\",\n      `${autofillValues[\"address-level1\"] || \"\"} ${autofillValues[\"postal-code\"] || \"\"}`,\n      autofillValues.country || autofillValues[\"country-name\"] || \"\"\n    ].filter(Boolean).join(\", \");\n    const addressLines = [firstLine, line2, line3, lastLine].filter(Boolean);\n    const addressLinesHtml = addressLines.map((val) => `<span>${val}</span>`).join(\"<br />\");\n    const element = createElementFromString(`\n        <span>${addressLinesHtml}</span>\n      `);\n    return element;\n  }\n}\nfunction tryConfirmBrowserAutofill(input, event, confirmOnBrowserAutofill, accessToken) {\n  return __async(this, null, function* () {\n    if (!confirmOnBrowserAutofill)\n      return;\n    const parentForm = findParentForm(input);\n    const formElements = Object.values(findAddressAutofillInputs(parentForm, input));\n    if (!event.detail.elements.some((el) => formElements.includes(el))) {\n      return;\n    }\n    const structure = parseFormStructure(parentForm);\n    const structureRef = structure.find((s) => s.input === input);\n    const autofillInstanceSection = structureRef.section;\n    const browserAutofilledSections = Array.from(new Set(structure.filter((s) => event.detail.elements.includes(s.input)).map((s) => s.section)));\n    if (!browserAutofilledSections.includes(autofillInstanceSection)) {\n      return;\n    }\n    const optionsSections = typeof confirmOnBrowserAutofill === \"object\" && confirmOnBrowserAutofill.sections || [];\n    if (optionsSections.length && !optionsSections.some((section) => browserAutofilledSections.includes(section))) {\n      return;\n    }\n    let optionsArg = typeof confirmOnBrowserAutofill === \"object\" ? confirmOnBrowserAutofill : {};\n    optionsArg = __spreadProps(__spreadValues({}, optionsArg), {\n      accessToken,\n      sections: [autofillInstanceSection]\n    });\n    yield confirmAddress(parentForm, optionsArg);\n  });\n}\n\n// src/utils/contribute.ts\nvar CONTRIBUTE_API_BASE_URL = \"https://contribute-api.mapbox.com/v1\";\nvar CONTRIBUTE_API_STAGING_BASE_URL = \"https://contribute-api-staging.tilestream.net/v1\";\nvar EDIT_SUGGESTION_ENDPOINT = \"edit-suggestion\";\nfunction sendFeedback(accessToken, feedbackArgs) {\n  if (!config.feedbackEnabled)\n    return;\n  const hostname = window.location.hostname;\n  const BASE_URL = isLocalServer(hostname) || isMapboxDomain(hostname) ? CONTRIBUTE_API_STAGING_BASE_URL : CONTRIBUTE_API_BASE_URL;\n  const url = `${BASE_URL}/${EDIT_SUGGESTION_ENDPOINT}/address?access_token=${accessToken}`;\n  const { originalCoordinate, originalAddress, changes } = feedbackArgs;\n  const payload = {\n    action: \"update\",\n    reason: \"incorrect_address\",\n    location: {\n      longitude: originalCoordinate[0],\n      latitude: originalCoordinate[1]\n    },\n    userEmail: \"no-reply-autofill@mapbox.com\",\n    changes,\n    placeName: originalAddress\n  };\n  fetch(url, {\n    method: \"POST\",\n    headers: new Headers({\n      \"User-Agent\": `mapbox-search-js.${version}.${navigator.userAgent}`,\n      \"Content-Type\": \"application/json\"\n    }),\n    body: JSON.stringify(payload)\n  });\n}\n\n// src/components/MapboxAddressConfirmationFeature.ts\nvar TEMPLATE2 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmationFeature\">\n    <div class=\"Modal\" aria-modal=\"true\" role=\"dialog\">\n      <div class=\"ModalHeader\">\n        <svg viewBox=\"0 0 18 18\" class=\"Icon IconQuestion\"></svg>\n        <div class=\"ModalHeaderTitle\">Did you mean?</div>\n        <svg\n          viewBox=\"0 0 18 18\"\n          class=\"Icon IconClose\"\n          tabindex=\"0\"\n          role=\"button\"\n          title=\"Close\"\n          aria-label=\"Close\"\n          aria-expanded=\"true\"\n        ></svg>\n      </div>\n\n      <div class=\"ModalAddress ModalAddressApprove\"></div>\n            \n      <div class=\"ModalMap\">\n        <mapbox-address-minimap class=\"Minimap\"></mapbox-address-minimap>\n      </div>\n\n      <div\n        class=\"Button ButtonPrimary ButtonApprove\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Yes\"\n      >\n        Yes\n      </div>\n      \n      <div\n        class=\"Button ButtonSecondary ButtonReject\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"No, use the address I provided\"\n      >\n        No, use the address I provided\n      </div>\n\n      <div class=\"ModalFooter\">\n          Your confirmation helps improve address data accuracy.\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar _binding3, _themeInternal3, _feature, _formValues, _handleClose, _modalID, _modalHeaderTitleID, _modalAddressApproveID;\nvar MapboxAddressConfirmationFeature = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _binding3, void 0);\n    __privateAdd(this, _themeInternal3, {});\n    this.minimap = false;\n    __privateAdd(this, _feature, void 0);\n    __privateAdd(this, _formValues, void 0);\n    this.update = (feature, autofillValues) => {\n      var _a;\n      __privateSet(this, _feature, feature);\n      __privateSet(this, _formValues, autofillValues);\n      const { ModalMap, Minimap, ModalAddressApprove } = __privateGet(this, _binding3);\n      if (this.minimap) {\n        ModalMap.removeAttribute(\"aria-hidden\");\n        Minimap.accessToken = this.accessToken;\n        if (typeof this.minimap === \"object\") {\n          const { defaultMapStyle, theme, mapStyleMode, satelliteToggle } = this.minimap;\n          defaultMapStyle && (Minimap.defaultMapStyle = this.minimap.defaultMapStyle);\n          theme && (Minimap.theme = this.minimap.theme);\n          mapStyleMode && (Minimap.mapStyleMode = mapStyleMode);\n          satelliteToggle !== void 0 && (Minimap.satelliteToggle = satelliteToggle);\n        }\n        Minimap.feature = feature;\n      } else {\n        ModalMap.setAttribute(\"aria-hidden\", \"true\");\n      }\n      const approveAddress = feature.properties.place_name || feature.properties.full_address || feature.properties.address;\n      ModalAddressApprove.innerHTML = \"\";\n      ModalAddressApprove.appendChild(createAddressElement(autofillValues, approveAddress, feature.properties.feature_name, feature.properties.description, ((_a = feature.properties.place_type) == null ? void 0 : _a[0]) === \"secondary_address\"));\n    };\n    __privateAdd(this, _handleClose, () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"cancel\"));\n    });\n    this.approve = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"change\"));\n    };\n    this.reject = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"nochange\"));\n      sendFeedback(this.accessToken, {\n        originalCoordinate: __privateGet(this, _feature).geometry.coordinates,\n        originalAddress: __privateGet(this, _feature).properties.full_address,\n        changes: {\n          address: getAutofillSearchText(__privateGet(this, _formValues))\n        }\n      });\n    };\n    __privateAdd(this, _modalID, randomValidID());\n    __privateAdd(this, _modalHeaderTitleID, randomValidID());\n    __privateAdd(this, _modalAddressApproveID, randomValidID());\n  }\n  get template() {\n    return TEMPLATE2;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmationFeature\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal3);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal3, theme);\n    if (!__privateGet(this, _binding3) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmationFeature\", theme));\n    const { IconQuestion, IconClose } = __privateGet(this, _binding3);\n    IconQuestion.innerHTML = getIcon(\"question\", theme);\n    IconClose.innerHTML = getIcon(\"close\", theme);\n  }\n  set footer(val) {\n    if (val === void 0)\n      return;\n    const footerEl = this.querySelector(\".ModalFooter\");\n    if (typeof val === \"string\") {\n      footerEl.textContent = val;\n      footerEl.removeAttribute(\"aria-hidden\");\n    } else if (!val) {\n      footerEl.setAttribute(\"aria-hidden\", \"true\");\n    } else {\n      footerEl.removeAttribute(\"aria-hidden\");\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding3, bindElements(this, {\n      MapboxAddressConfirmationFeature: \".MapboxAddressConfirmationFeature\",\n      Modal: \".Modal\",\n      ModalHeaderTitle: \".ModalHeaderTitle\",\n      ModalMap: \".ModalMap\",\n      Minimap: \".Minimap\",\n      IconQuestion: \".IconQuestion\",\n      IconClose: \".IconClose\",\n      ButtonApprove: \".ButtonApprove\",\n      ButtonReject: \".ButtonReject\",\n      ModalAddressApprove: \".ModalAddressApprove\"\n    }));\n    const {\n      Modal,\n      ModalHeaderTitle,\n      IconClose,\n      ButtonApprove,\n      ButtonReject,\n      ModalAddressApprove\n    } = __privateGet(this, _binding3);\n    Modal.setAttribute(\"aria-labelledby\", __privateGet(this, _modalHeaderTitleID));\n    Modal.setAttribute(\"aria-describedby\", __privateGet(this, _modalAddressApproveID));\n    IconClose.setAttribute(\"aria-controls\", __privateGet(this, _modalID));\n    Modal.id = __privateGet(this, _modalID);\n    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID);\n    ModalAddressApprove.id = __privateGet(this, _modalAddressApproveID);\n    const buttons = Array.from(this.querySelectorAll('[role=\"button\"]'));\n    for (const button of buttons) {\n      button.addEventListener(\"keydown\", ariaButtonKeyDown);\n    }\n    IconClose.addEventListener(\"click\", __privateGet(this, _handleClose));\n    ButtonApprove.addEventListener(\"click\", this.approve);\n    ButtonReject.addEventListener(\"click\", this.reject);\n    const theme = this.theme;\n    if (theme) {\n      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding3);\n      IconQuestion.innerHTML = getIcon(\"question\", theme);\n      IconClose2.innerHTML = getIcon(\"close\", theme);\n    }\n  }\n  disconnectedCallback() {\n    const { IconClose, ButtonApprove } = __privateGet(this, _binding3);\n    IconClose.removeEventListener(\"click\", __privateGet(this, _handleClose));\n    ButtonApprove.removeEventListener(\"click\", this.approve);\n  }\n};\n_binding3 = new WeakMap();\n_themeInternal3 = new WeakMap();\n_feature = new WeakMap();\n_formValues = new WeakMap();\n_handleClose = new WeakMap();\n_modalID = new WeakMap();\n_modalHeaderTitleID = new WeakMap();\n_modalAddressApproveID = new WeakMap();\nwindow.MapboxAddressConfirmationFeature = MapboxAddressConfirmationFeature;\nif (!window.customElements.get(\"mapbox-address-confirmation-feature\")) {\n  customElements.define(\"mapbox-address-confirmation-feature\", MapboxAddressConfirmationFeature);\n}\n\n// src/components/MapboxAddressConfirmationNoFeature.ts\nvar TEMPLATE3 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmationNoFeature\">\n    <div class=\"Modal\" aria-modal=\"true\" role=\"dialog\">\n      <div class=\"ModalHeader\">\n        <svg viewBox=\"0 0 18 18\" class=\"Icon IconQuestion\"></svg>\n        <div class=\"ModalHeaderTitle\">Confirm address</div>\n        <svg\n          viewBox=\"0 0 18 18\"\n          class=\"Icon IconClose\"\n          tabindex=\"0\"\n          role=\"button\"\n          title=\"Close\"\n          aria-label=\"Close\"\n          aria-expanded=\"true\"\n        ></svg>\n      </div>\n      <div class=\"ModalDescription\">\n        We couldn't verify this address. Please check that your information is correct before continuing.\n      </div>\n      <br />\n      <div class=\"ModalSubheader\">\n        You entered\n      </div>\n      <div class=\"ModalAddress\"></div>\n      <div\n        class=\"Button ButtonPrimary\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Use the address I provided\"\n      >\n        Use the address I provided\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar _binding4, _themeInternal4, _handleClose2, _modalID2, _modalHeaderTitleID2, _modalAddressID;\nvar MapboxAddressConfirmationNoFeature = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _binding4, void 0);\n    __privateAdd(this, _themeInternal4, {});\n    this.update = (autofillValues) => {\n      const { ModalAddress } = __privateGet(this, _binding4);\n      ModalAddress.innerHTML = \"\";\n      ModalAddress.appendChild(createAddressElement(autofillValues));\n    };\n    __privateAdd(this, _handleClose2, () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"cancel\"));\n    });\n    this.reject = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"nochange\"));\n    };\n    __privateAdd(this, _modalID2, randomValidID());\n    __privateAdd(this, _modalHeaderTitleID2, randomValidID());\n    __privateAdd(this, _modalAddressID, randomValidID());\n  }\n  get template() {\n    return TEMPLATE3;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmationNoFeature\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal4);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal4, theme);\n    if (!__privateGet(this, _binding4) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmationNoFeature\", theme));\n    const { IconQuestion, IconClose } = __privateGet(this, _binding4);\n    IconQuestion.innerHTML = getIcon(\"question\", theme);\n    IconClose.innerHTML = getIcon(\"close\", theme);\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding4, bindElements(this, {\n      Modal: \".Modal\",\n      ModalHeaderTitle: \".ModalHeaderTitle\",\n      IconQuestion: \".IconQuestion\",\n      IconClose: \".IconClose\",\n      ModalAddress: \".ModalAddress\",\n      ButtonReject: \".Button\"\n    }));\n    const { Modal, ModalHeaderTitle, IconClose, ModalAddress, ButtonReject } = __privateGet(this, _binding4);\n    Modal.setAttribute(\"aria-labelledby\", __privateGet(this, _modalHeaderTitleID2));\n    Modal.setAttribute(\"aria-describedby\", __privateGet(this, _modalAddressID));\n    IconClose.setAttribute(\"aria-controls\", __privateGet(this, _modalID2));\n    Modal.id = __privateGet(this, _modalID2);\n    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID2);\n    ModalAddress.id = __privateGet(this, _modalAddressID);\n    const buttons = Array.from(this.querySelectorAll('[role=\"button\"]'));\n    for (const button of buttons) {\n      button.addEventListener(\"keydown\", ariaButtonKeyDown);\n    }\n    IconClose.addEventListener(\"click\", __privateGet(this, _handleClose2));\n    ButtonReject.addEventListener(\"click\", this.reject);\n    const theme = this.theme;\n    if (theme) {\n      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding4);\n      IconQuestion.innerHTML = getIcon(\"question\", theme);\n      IconClose2.innerHTML = getIcon(\"close\", theme);\n    }\n  }\n  disconnectedCallback() {\n    const { IconClose, ButtonReject } = __privateGet(this, _binding4);\n    IconClose.removeEventListener(\"click\", __privateGet(this, _handleClose2));\n    ButtonReject.removeEventListener(\"click\", this.reject);\n  }\n};\n_binding4 = new WeakMap();\n_themeInternal4 = new WeakMap();\n_handleClose2 = new WeakMap();\n_modalID2 = new WeakMap();\n_modalHeaderTitleID2 = new WeakMap();\n_modalAddressID = new WeakMap();\nwindow.MapboxAddressConfirmationNoFeature = MapboxAddressConfirmationNoFeature;\nif (!window.customElements.get(\"mapbox-address-confirmation-no-feature\")) {\n  customElements.define(\"mapbox-address-confirmation-no-feature\", MapboxAddressConfirmationNoFeature);\n}\n\n// src/components/MapboxAddressAutofill.ts\n\n\n// src/utils/detect_browser_autofill.ts\n\n\n// src/utils/detect_browser_autofill.css\nvar detect_browser_autofill_default = 'input:-webkit-autofill,select:-webkit-autofill,textarea:-webkit-autofill{animation-name:onbrowserautofillstart}input:not(:-webkit-autofill),select:not(:-webkit-autofill),textarea:not(:-webkit-autofill){animation-name:onbrowserautofillcancel}@keyframes onbrowserautofillstart{0%{animation-name:\"onbrowserautofillstart\"}to{animation-name:\"onbrowserautofillstart\"}}@keyframes onbrowserautofillcancel{0%{animation-name:\"onbrowserautofillcancel\"}to{animation-name:\"onbrowserautofillcancel\"}}';\n\n// src/utils/detect_browser_autofill.ts\nvar ATTR_NAME = \"browser-autofilled\";\nvar AUTOFILLED_ELEMENTS = [];\nfunction dispatchBrowserAutofillEvent() {\n  window.dispatchEvent(new window.CustomEvent(\"browserautofill\", {\n    bubbles: true,\n    cancelable: true,\n    detail: { elements: AUTOFILLED_ELEMENTS }\n  }));\n  AUTOFILLED_ELEMENTS = [];\n}\nvar debouncedAutofill = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.debounce)(dispatchBrowserAutofillEvent, 5);\nfunction browserAutofill(element) {\n  if (element.hasAttribute(ATTR_NAME))\n    return;\n  element.setAttribute(ATTR_NAME, \"\");\n  AUTOFILLED_ELEMENTS.push(element);\n  debouncedAutofill();\n}\nfunction cancelBrowserAutofill(element) {\n  if (!element.hasAttribute(ATTR_NAME))\n    return;\n  element.removeAttribute(ATTR_NAME);\n}\nfunction onAnimationStart(event) {\n  event.animationName === \"onbrowserautofillstart\" ? browserAutofill(event.target) : cancelBrowserAutofill(event.target);\n}\nfunction onInput(event) {\n  const targetEl = event.target;\n  targetEl.nodeName.toLowerCase() !== \"select\" && !event.simulated && !(event instanceof MapboxHTMLEvent) && (event.inputType === \"insertReplacementText\" || !(\"data\" in event)) ? browserAutofill(targetEl) : cancelBrowserAutofill(targetEl);\n}\nfunction initDetectBrowserAutofill() {\n  if (config.detectBrowserAutofillEnabled) {\n    return;\n  } else {\n    config.detectBrowserAutofillEnabled = true;\n  }\n  addDocumentStyle(detect_browser_autofill_default);\n  document.addEventListener(\"animationstart\", onAnimationStart, true);\n  document.addEventListener(\"input\", onInput, true);\n}\n\n// src/components/MapboxAddressAutofill.ts\nvar _autofill, _session, _input, _listbox, _initialAutocompleteValue, _browserAutofillEnabled, _handleSuggest, _handleSuggestError, _handleRetrieve, _handleObserve, _observer, _handleBrowserAutofill, _onHandleInput, _onHandleSelect, _onHandleBlur, _onHandleFocus;\nvar MapboxAddressAutofill = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _autofill, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.AddressAutofillCore());\n    __privateAdd(this, _session, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchSession(__privateGet(this, _autofill)));\n    __privateAdd(this, _input, void 0);\n    __privateAdd(this, _listbox, new MapboxSearchListbox());\n    __privateAdd(this, _initialAutocompleteValue, void 0);\n    this.options = {};\n    this.confirmOnBrowserAutofill = false;\n    __privateAdd(this, _browserAutofillEnabled, false);\n    __privateAdd(this, _handleSuggest, (result) => {\n      const filteredSuggestions = (result == null ? void 0 : result.suggestions) ? distinctExactStreetResults(result.suggestions) : null;\n      __privateGet(this, _listbox).handleSuggest(filteredSuggestions);\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggest\", result));\n    });\n    __privateAdd(this, _handleSuggestError, (error) => {\n      __privateGet(this, _listbox).handleError();\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggesterror\", error));\n    });\n    __privateAdd(this, _handleRetrieve, (result) => {\n      var _a;\n      this.dispatchEvent(new MapboxHTMLEvent(\"retrieve\", result));\n      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];\n      if (!__privateGet(this, _input)) {\n        return;\n      }\n      const featureCollection = result;\n      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {\n        return;\n      }\n      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input));\n    });\n    __privateAdd(this, _handleObserve, () => {\n      var _a;\n      try {\n        const input = (_a = this.querySelector(\"input\")) != null ? _a : null;\n        __privateSet(this, _input, input);\n        __privateGet(this, _listbox).input = input;\n      } catch (e) {\n        __privateSet(this, _input, null);\n        __privateGet(this, _listbox).input = null;\n        console.error(e.message || e);\n      }\n    });\n    __privateAdd(this, _observer, new MutationObserver(__privateGet(this, _handleObserve)));\n    __privateAdd(this, _handleBrowserAutofill, (e) => {\n      __privateGet(this, _listbox).blur();\n      tryConfirmBrowserAutofill(__privateGet(this, _input), e, this.confirmOnBrowserAutofill, this.accessToken);\n    });\n    this.retrieveFeature = null;\n    this.interceptSearch = null;\n    __privateAdd(this, _onHandleInput, (e) => {\n      this.dispatchEvent(e.clone());\n      const inputText = e.detail;\n      const enableBrowserAutocomplete = this.browserAutofillEnabled === true && (inputText == null ? void 0 : inputText.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), enableBrowserAutocomplete);\n      const alteredText = this.interceptSearch && this.interceptSearch(inputText);\n      const searchText = this.interceptSearch ? alteredText : inputText;\n      if (this.interceptSearch && !alteredText || (searchText == null ? void 0 : searchText.length) <= 2) {\n        __privateGet(this, _listbox).handleSuggest(null);\n        return;\n      }\n      __privateGet(this, _session).suggest(searchText, this.options);\n    });\n    __privateAdd(this, _onHandleSelect, (e) => {\n      const suggestion = e.detail;\n      if (e.detail.accuracy !== \"street\") {\n        toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), true);\n        __privateGet(this, _session).retrieve(suggestion, this.options);\n      } else {\n        handleStreetSelection(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), suggestion);\n      }\n    });\n    __privateAdd(this, _onHandleBlur, () => {\n      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), true);\n      __privateGet(this, _session).abort();\n    });\n    __privateAdd(this, _onHandleFocus, () => {\n      var _a;\n      const enableBrowserAutocomplete = this.browserAutofillEnabled === true && ((_a = __privateGet(this, _input).value) == null ? void 0 : _a.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), enableBrowserAutocomplete);\n    });\n  }\n  get accessToken() {\n    return __privateGet(this, _autofill).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _autofill).accessToken = newToken;\n  }\n  get input() {\n    return __privateGet(this, _input);\n  }\n  get theme() {\n    return __privateGet(this, _listbox).theme;\n  }\n  set theme(theme) {\n    __privateGet(this, _listbox).theme = theme;\n  }\n  get popoverOptions() {\n    return __privateGet(this, _listbox).popoverOptions;\n  }\n  set popoverOptions(newOptions) {\n    __privateGet(this, _listbox).popoverOptions = newOptions;\n  }\n  get browserAutofillEnabled() {\n    return __privateGet(this, _browserAutofillEnabled);\n  }\n  set browserAutofillEnabled(enable) {\n    __privateSet(this, _browserAutofillEnabled, enable);\n  }\n  connectedCallback() {\n    var _a;\n    super.connectedCallback();\n    config.autofillSessionEnabled = true;\n    __privateGet(this, _session).sessionToken = config.autofillSessionToken;\n    __privateGet(this, _listbox).autofillHost = this;\n    __privateGet(this, _listbox).searchService = 0 /* AddressAutofill */;\n    const input = (_a = this.querySelector(\"input\")) != null ? _a : null;\n    __privateGet(this, _observer).observe(this, {\n      subtree: true,\n      childList: true\n    });\n    __privateGet(this, _handleObserve).call(this);\n    __privateGet(this, _listbox).addEventListener(\"input\", __privateGet(this, _onHandleInput));\n    __privateGet(this, _listbox).addEventListener(\"select\", __privateGet(this, _onHandleSelect));\n    __privateGet(this, _listbox).addEventListener(\"blur\", __privateGet(this, _onHandleBlur));\n    __privateGet(this, _listbox).addEventListener(\"focus\", __privateGet(this, _onHandleFocus));\n    __privateGet(this, _session).addEventListener(\"suggest\", __privateGet(this, _handleSuggest));\n    __privateGet(this, _session).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError));\n    __privateGet(this, _session).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve));\n    document.body.appendChild(__privateGet(this, _listbox));\n    if (input) {\n      input.insertAdjacentElement(\"beforebegin\", createAriaLiveElement(__privateGet(this, _listbox).dataSeed));\n      suppressExtensionsAutocomplete(input);\n      __privateSet(this, _initialAutocompleteValue, input.autocomplete);\n    }\n    initDetectBrowserAutofill();\n    window.addEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill));\n  }\n  disconnectedCallback() {\n    __privateGet(this, _listbox).remove();\n    __privateGet(this, _listbox).removeEventListener(\"input\", __privateGet(this, _onHandleInput));\n    __privateGet(this, _listbox).removeEventListener(\"select\", __privateGet(this, _onHandleSelect));\n    __privateGet(this, _listbox).removeEventListener(\"blur\", __privateGet(this, _onHandleBlur));\n    __privateGet(this, _listbox).removeEventListener(\"focus\", __privateGet(this, _onHandleFocus));\n    __privateGet(this, _session).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest));\n    __privateGet(this, _session).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError));\n    __privateGet(this, _session).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve));\n    __privateGet(this, _observer).disconnect();\n    window.removeEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill));\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      __privateGet(this, _autofill).accessToken = newValue;\n      return;\n    }\n    if (name === \"browser-autofill-enabled\") {\n      __privateSet(this, _browserAutofillEnabled, Boolean(newValue));\n      return;\n    }\n    if (name === \"theme\") {\n      this.theme = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"popover-options\") {\n      this.popoverOptions = tryParseJSON(newValue);\n      return;\n    }\n    const optionName = name.split(\"-\").join(\"_\");\n    if (!newValue) {\n      delete this.options[optionName];\n    }\n    this.options[optionName] = newValue;\n  }\n  focus() {\n    __privateGet(this, _listbox).focus();\n  }\n  simulateRetrieve(feature) {\n    const input = this.input;\n    if (input) {\n      input.dataset[\"mapboxSuccess\"] = \"true\";\n    }\n    __privateGet(this, _listbox).hideResults();\n    const simResult = {\n      type: \"FeatureCollection\",\n      features: [feature],\n      url: \"\"\n    };\n    __privateGet(this, _handleRetrieve).call(this, simResult);\n  }\n};\n_autofill = new WeakMap();\n_session = new WeakMap();\n_input = new WeakMap();\n_listbox = new WeakMap();\n_initialAutocompleteValue = new WeakMap();\n_browserAutofillEnabled = new WeakMap();\n_handleSuggest = new WeakMap();\n_handleSuggestError = new WeakMap();\n_handleRetrieve = new WeakMap();\n_handleObserve = new WeakMap();\n_observer = new WeakMap();\n_handleBrowserAutofill = new WeakMap();\n_onHandleInput = new WeakMap();\n_onHandleSelect = new WeakMap();\n_onHandleBlur = new WeakMap();\n_onHandleFocus = new WeakMap();\nMapboxAddressAutofill.observedAttributes = [\n  \"access-token\",\n  \"browser-autofill-enabled\",\n  \"theme\",\n  \"popover-options\",\n  \"css-text\",\n  \"language\",\n  \"country\",\n  \"bbox\",\n  \"limit\",\n  \"proximity\",\n  \"streets\"\n];\nwindow.MapboxAddressAutofill = MapboxAddressAutofill;\nif (!window.customElements.get(\"mapbox-address-autofill\")) {\n  customElements.define(\"mapbox-address-autofill\", MapboxAddressAutofill);\n}\n\n// src/components/MapboxSearchBox.ts\n\n\n\n// src/utils/localization.ts\nvar placeholder = {\n  de: \"Suche\",\n  it: \"Ricerca\",\n  en: \"Search\",\n  nl: \"Zoeken\",\n  fr: \"Chercher\",\n  ca: \"Cerca\",\n  he: \"\\u05DC\\u05D7\\u05E4\\u05E9\",\n  ja: \"\\u30B5\\u30FC\\u30C1\",\n  lv: \"Mekl\\u0113t\",\n  pt: \"Procurar\",\n  sr: \"\\u041F\\u0440\\u0435\\u0442\\u0440\\u0430\\u0433\\u0430\",\n  zh: \"\\u641C\\u7D22\",\n  cs: \"Vyhled\\xE1v\\xE1n\\xED\",\n  hu: \"Keres\\xE9s\",\n  ka: \"\\u10EB\\u10D8\\u10D4\\u10D1\\u10D0\",\n  nb: \"S\\xF8ke\",\n  sk: \"Vyh\\u013Ead\\xE1vanie\",\n  th: \"\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\",\n  fi: \"Hae\",\n  is: \"Leita\",\n  ko: \"\\uC218\\uC0C9\",\n  pl: \"Szukaj\",\n  sl: \"Iskanje\",\n  fa: \"\\u062C\\u0633\\u062A\\u062C\\u0648\",\n  ru: \"\\u041F\\u043E\\u0438\\u0441\\u043A\"\n};\nvar localization_default = { placeholder };\n\n// src/components/MapboxSearchBox.ts\nvar MAX_ZOOM = 9;\nvar _binding5, _search, _session2, _map, _input2, _listbox2, _getDefaultPlaceholder, getDefaultPlaceholder_fn, _placeholder, _handleSuggest2, _handleSuggestError2, _handleRetrieve2, _mapMarker, _removeMarker, _handleMarker, _onHandleInput2, _onHandleSelect2, _onHandleBlur2, _setActionIcons, _handleClear, _handleMoveEnd;\nvar MapboxSearchBox = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _getDefaultPlaceholder);\n    __privateAdd(this, _binding5, void 0);\n    __privateAdd(this, _search, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchBoxCore({}));\n    __privateAdd(this, _session2, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchSession(__privateGet(this, _search)));\n    __privateAdd(this, _map, null);\n    __privateAdd(this, _input2, void 0);\n    __privateAdd(this, _listbox2, new MapboxSearchListbox());\n    this.options = {};\n    __privateAdd(this, _placeholder, void 0);\n    __privateAdd(this, _handleSuggest2, (result) => {\n      __privateGet(this, _setActionIcons).call(this);\n      __privateGet(this, _listbox2).handleSuggest((result == null ? void 0 : result.suggestions) || null);\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggest\", result));\n    });\n    __privateAdd(this, _handleSuggestError2, (error) => {\n      __privateGet(this, _setActionIcons).call(this);\n      __privateGet(this, _listbox2).handleError();\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggesterror\", error));\n    });\n    __privateAdd(this, _handleRetrieve2, (result) => {\n      __privateGet(this, _setActionIcons).call(this);\n      this.dispatchEvent(new MapboxHTMLEvent(\"retrieve\", result));\n      const featureCollection = result;\n      if (!featureCollection || !featureCollection.features.length) {\n        return;\n      }\n      const suggestion = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.featureToSuggestion)(featureCollection.features[0]);\n      __privateGet(this, _input2).value = suggestion.name;\n      const map = __privateGet(this, _map);\n      if (!map) {\n        return;\n      }\n      const feature = featureCollection.features[0];\n      if (!feature) {\n        return;\n      }\n      const placeType = feature.properties.feature_type;\n      const bounds = feature.properties.bbox;\n      if (bounds) {\n        map.flyTo(bboxViewport(map, _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds.convert(bounds).toFlatArray()));\n      } else {\n        const center = feature.geometry.coordinates;\n        const zoom = getMaxZoom(placeType);\n        map.flyTo({\n          center,\n          zoom,\n          speed: FLY_TO_SPEED\n        });\n      }\n      if (this.marker && this.mapboxgl) {\n        __privateGet(this, _handleMarker).call(this, feature);\n      }\n    });\n    __privateAdd(this, _mapMarker, void 0);\n    __privateAdd(this, _removeMarker, () => {\n      if (__privateGet(this, _mapMarker)) {\n        __privateGet(this, _mapMarker).remove();\n        __privateSet(this, _mapMarker, null);\n      }\n    });\n    __privateAdd(this, _handleMarker, (feature) => {\n      if (!__privateGet(this, _map)) {\n        return;\n      }\n      __privateGet(this, _removeMarker).call(this);\n      if (!feature)\n        return;\n      const defaultMarkerOptions = {\n        color: \"#4668F2\"\n      };\n      const markerOptions = __spreadValues(__spreadValues({}, defaultMarkerOptions), typeof this.marker === \"object\" && this.marker);\n      __privateSet(this, _mapMarker, new this.mapboxgl.Marker(markerOptions));\n      if (feature.geometry && feature.geometry.type && feature.geometry.type === \"Point\" && feature.geometry.coordinates) {\n        __privateGet(this, _mapMarker).setLngLat(feature.geometry.coordinates).addTo(__privateGet(this, _map));\n      }\n    });\n    this.interceptSearch = null;\n    __privateAdd(this, _onHandleInput2, (e) => {\n      this.dispatchEvent(e.clone());\n      const inputText = e.detail;\n      if (!inputText) {\n        __privateGet(this, _handleClear).call(this);\n        return;\n      }\n      const alteredText = this.interceptSearch && this.interceptSearch(inputText);\n      const searchText = this.interceptSearch ? alteredText : inputText;\n      if (this.interceptSearch && !alteredText) {\n        __privateGet(this, _listbox2).hideResults();\n        return;\n      }\n      __privateGet(this, _session2).suggest(searchText, this.options);\n      __privateGet(this, _setActionIcons).call(this, true);\n    });\n    __privateAdd(this, _onHandleSelect2, (e) => {\n      const suggestion = e.detail;\n      __privateGet(this, _session2).retrieve(suggestion, this.options);\n      __privateGet(this, _setActionIcons).call(this, true);\n    });\n    __privateAdd(this, _onHandleBlur2, () => {\n      __privateGet(this, _session2).abort();\n    });\n    __privateAdd(this, _setActionIcons, (loading = false) => {\n      if (loading) {\n        __privateGet(this, _binding5).ClearBtn.style.display = \"none\";\n        __privateGet(this, _binding5).LoadingIcon.style.display = \"block\";\n      } else {\n        __privateGet(this, _binding5).LoadingIcon.style.display = \"none\";\n        __privateGet(this, _binding5).ClearBtn.style.display = this.value ? \"block\" : \"none\";\n      }\n    });\n    __privateAdd(this, _handleClear, () => {\n      this.value = \"\";\n      __privateGet(this, _setActionIcons).call(this);\n      __privateGet(this, _handleMarker).call(this, null);\n      __privateGet(this, _listbox2).handleSuggest(null);\n    });\n    this.marker = true;\n    __privateAdd(this, _handleMoveEnd, () => {\n      const map = __privateGet(this, _map);\n      const options = __spreadValues({}, this.options);\n      if (map.getZoom() <= MAX_ZOOM) {\n        delete options.proximity;\n        this.options = options;\n        return;\n      }\n      const center = map.getCenter();\n      this.options = __spreadProps(__spreadValues({}, options), {\n        proximity: center\n      });\n    });\n  }\n  get accessToken() {\n    return __privateGet(this, _search).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _search).accessToken = newToken;\n  }\n  get value() {\n    return __privateGet(this, _input2).value;\n  }\n  set value(newValue) {\n    __privateGet(this, _input2).value = newValue;\n  }\n  get input() {\n    return __privateGet(this, _input2);\n  }\n  get template() {\n    return SEARCHBOX_TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".SearchBox\", __privateGet(this, _listbox2).theme);\n  }\n  get theme() {\n    return __privateGet(this, _listbox2).theme;\n  }\n  set theme(theme) {\n    __privateGet(this, _listbox2).theme = theme;\n    if (!__privateGet(this, _binding5) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".SearchBox\", theme));\n    __privateGet(this, _listbox2).updatePopover();\n    const { SearchIcon } = __privateGet(this, _binding5);\n    SearchIcon.innerHTML = getIcon(\"search\", theme);\n  }\n  get popoverOptions() {\n    return __privateGet(this, _listbox2).popoverOptions;\n  }\n  set popoverOptions(newOptions) {\n    __privateGet(this, _listbox2).popoverOptions = newOptions;\n  }\n  get placeholder() {\n    return __privateGet(this, _placeholder) || __privateMethod(this, _getDefaultPlaceholder, getDefaultPlaceholder_fn).call(this);\n  }\n  set placeholder(text) {\n    __privateSet(this, _placeholder, text);\n    if (__privateGet(this, _input2)) {\n      __privateGet(this, _input2).placeholder = this.placeholder;\n      __privateGet(this, _input2).setAttribute(\"aria-label\", this.placeholder);\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding5, bindElements(this, {\n      SearchBox: \".SearchBox\",\n      SearchIcon: \".SearchIcon\",\n      Input: \".Input\",\n      ClearBtn: \".ClearBtn\",\n      LoadingIcon: \".LoadingIcon\"\n    }));\n    this.theme = __spreadValues({}, this.theme);\n    const { Input, ClearBtn } = __privateGet(this, _binding5);\n    __privateSet(this, _input2, Input);\n    __privateGet(this, _listbox2).input = Input;\n    __privateGet(this, _listbox2).searchService = 2 /* SearchBox */;\n    __privateGet(this, _listbox2).addEventListener(\"input\", __privateGet(this, _onHandleInput2));\n    __privateGet(this, _listbox2).addEventListener(\"select\", __privateGet(this, _onHandleSelect2));\n    __privateGet(this, _listbox2).addEventListener(\"blur\", __privateGet(this, _onHandleBlur2));\n    __privateGet(this, _session2).addEventListener(\"suggest\", __privateGet(this, _handleSuggest2));\n    __privateGet(this, _session2).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError2));\n    __privateGet(this, _session2).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve2));\n    ClearBtn.addEventListener(\"click\", __privateGet(this, _handleClear));\n    this.placeholder = __privateGet(this, _placeholder);\n    document.body.appendChild(__privateGet(this, _listbox2));\n    if (Input) {\n      if (Input.previousElementSibling.hasAttribute(\"aria-live\")) {\n        Input.previousElementSibling.remove();\n      }\n      Input.insertAdjacentElement(\"beforebegin\", createAriaLiveElement(__privateGet(this, _listbox2).dataSeed));\n    }\n  }\n  disconnectedCallback() {\n    __privateGet(this, _listbox2).remove();\n    __privateGet(this, _listbox2).input = null;\n    __privateGet(this, _listbox2).removeEventListener(\"input\", __privateGet(this, _onHandleInput2));\n    __privateGet(this, _listbox2).removeEventListener(\"select\", __privateGet(this, _onHandleSelect2));\n    __privateGet(this, _listbox2).removeEventListener(\"blur\", __privateGet(this, _onHandleBlur2));\n    __privateGet(this, _session2).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest2));\n    __privateGet(this, _session2).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError2));\n    __privateGet(this, _session2).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve2));\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      __privateGet(this, _search).accessToken = newValue;\n      return;\n    }\n    if (name === \"theme\") {\n      this.theme = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"popover-options\") {\n      this.popoverOptions = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"placeholder\") {\n      this.placeholder = newValue;\n      return;\n    }\n    const optionName = name.split(\"-\").join(\"_\");\n    if (!newValue) {\n      delete this.options[optionName];\n    }\n    this.options[optionName] = newValue;\n    if (optionName === \"language\") {\n      this.placeholder = __privateGet(this, _placeholder);\n    }\n  }\n  focus() {\n    __privateGet(this, _listbox2).focus();\n  }\n  search(text) {\n    this.value = text;\n    __privateGet(this, _onHandleInput2).call(this, new MapboxHTMLEvent(\"input\", text));\n  }\n  bindMap(map) {\n    if (__privateGet(this, _map)) {\n      __privateGet(this, _map).off(\"moveend\", __privateGet(this, _handleMoveEnd));\n    }\n    if (map) {\n      map.on(\"moveend\", __privateGet(this, _handleMoveEnd));\n    }\n    __privateSet(this, _map, map);\n  }\n  unbindMap() {\n    this.bindMap(null);\n  }\n  onAdd(map) {\n    this.bindMap(map);\n    this.remove();\n    const container = document.createElement(\"div\");\n    container.className = \"mapboxgl-ctrl\";\n    container.style.width = \"300px\";\n    container.appendChild(this);\n    return container;\n  }\n  onRemove() {\n    this.remove();\n    this.unbindMap();\n    __privateGet(this, _removeMarker).call(this);\n  }\n  getDefaultPosition() {\n    return \"top-right\";\n  }\n};\n_binding5 = new WeakMap();\n_search = new WeakMap();\n_session2 = new WeakMap();\n_map = new WeakMap();\n_input2 = new WeakMap();\n_listbox2 = new WeakMap();\n_getDefaultPlaceholder = new WeakSet();\ngetDefaultPlaceholder_fn = function() {\n  if (this.options.language) {\n    const firstLanguage = this.options.language.split(\",\")[0];\n    const language = subtag__WEBPACK_IMPORTED_MODULE_4___default().language(firstLanguage);\n    const localizedValue = localization_default.placeholder[language];\n    if (localizedValue)\n      return localizedValue;\n  }\n  return \"Search\";\n};\n_placeholder = new WeakMap();\n_handleSuggest2 = new WeakMap();\n_handleSuggestError2 = new WeakMap();\n_handleRetrieve2 = new WeakMap();\n_mapMarker = new WeakMap();\n_removeMarker = new WeakMap();\n_handleMarker = new WeakMap();\n_onHandleInput2 = new WeakMap();\n_onHandleSelect2 = new WeakMap();\n_onHandleBlur2 = new WeakMap();\n_setActionIcons = new WeakMap();\n_handleClear = new WeakMap();\n_handleMoveEnd = new WeakMap();\nMapboxSearchBox.observedAttributes = [\n  \"access-token\",\n  \"theme\",\n  \"popover-options\",\n  \"placeholder\",\n  \"language\",\n  \"country\",\n  \"bbox\",\n  \"limit\",\n  \"navigation-profile\",\n  \"origin\",\n  \"proximity\",\n  \"eta-type\",\n  \"types\"\n];\nwindow.MapboxSearchBox = MapboxSearchBox;\nif (!window.customElements.get(\"mapbox-search-box\")) {\n  customElements.define(\"mapbox-search-box\", MapboxSearchBox);\n}\n\n// src/components/MapboxGeocoder.ts\n\n\nvar MAX_ZOOM2 = 9;\nvar _binding6, _search2, _session3, _map2, _input3, _listbox3, _getDefaultPlaceholder2, getDefaultPlaceholder_fn2, _placeholder2, _handleSuggest3, _handleSuggestError3, _handleRetrieve3, _mapMarker2, _removeMarker2, _handleMarker2, _onHandleInput3, _onHandleSelect3, _onHandleBlur3, _setActionIcons2, _handleClear2, _handleMoveEnd2;\nvar MapboxGeocoder = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _getDefaultPlaceholder2);\n    __privateAdd(this, _binding6, void 0);\n    __privateAdd(this, _search2, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.GeocodingCore({}));\n    __privateAdd(this, _session3, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchSession(__privateGet(this, _search2)));\n    __privateAdd(this, _map2, null);\n    __privateAdd(this, _input3, void 0);\n    __privateAdd(this, _listbox3, new MapboxSearchListbox());\n    this.options = {};\n    __privateAdd(this, _placeholder2, void 0);\n    __privateAdd(this, _handleSuggest3, (result) => {\n      __privateGet(this, _setActionIcons2).call(this);\n      __privateGet(this, _listbox3).handleSuggest((result == null ? void 0 : result.features) || null);\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggest\", result));\n    });\n    __privateAdd(this, _handleSuggestError3, (error) => {\n      __privateGet(this, _setActionIcons2).call(this);\n      __privateGet(this, _listbox3).handleError();\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggesterror\", error));\n    });\n    __privateAdd(this, _handleRetrieve3, (result) => {\n      __privateGet(this, _setActionIcons2).call(this);\n      this.dispatchEvent(new MapboxHTMLEvent(\"retrieve\", result));\n      const feature = result;\n      if (!feature) {\n        return;\n      }\n      __privateGet(this, _input3).value = feature.properties.full_address;\n      const map = __privateGet(this, _map2);\n      if (!map) {\n        return;\n      }\n      const placeType = feature.properties.feature_type;\n      const bounds = feature.properties.bbox;\n      if (bounds) {\n        map.flyTo(bboxViewport(map, _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds.convert(bounds).toFlatArray()));\n      } else {\n        const center = feature.geometry.coordinates;\n        const zoom = getMaxZoom(placeType);\n        map.flyTo({\n          center,\n          zoom,\n          speed: FLY_TO_SPEED\n        });\n      }\n      if (this.marker && this.mapboxgl) {\n        __privateGet(this, _handleMarker2).call(this, feature);\n      }\n    });\n    __privateAdd(this, _mapMarker2, void 0);\n    __privateAdd(this, _removeMarker2, () => {\n      if (__privateGet(this, _mapMarker2)) {\n        __privateGet(this, _mapMarker2).remove();\n        __privateSet(this, _mapMarker2, null);\n      }\n    });\n    __privateAdd(this, _handleMarker2, (feature) => {\n      if (!__privateGet(this, _map2)) {\n        return;\n      }\n      __privateGet(this, _removeMarker2).call(this);\n      if (!feature)\n        return;\n      const defaultMarkerOptions = {\n        color: \"#4668F2\"\n      };\n      const markerOptions = __spreadValues(__spreadValues({}, defaultMarkerOptions), typeof this.marker === \"object\" && this.marker);\n      __privateSet(this, _mapMarker2, new this.mapboxgl.Marker(markerOptions));\n      if (feature.geometry && feature.geometry.type && feature.geometry.type === \"Point\" && feature.geometry.coordinates) {\n        __privateGet(this, _mapMarker2).setLngLat(feature.geometry.coordinates).addTo(__privateGet(this, _map2));\n      }\n    });\n    this.interceptSearch = null;\n    __privateAdd(this, _onHandleInput3, (e) => {\n      this.dispatchEvent(e.clone());\n      const inputText = e.detail;\n      if (!inputText) {\n        __privateGet(this, _handleClear2).call(this);\n        return;\n      }\n      const alteredText = this.interceptSearch && this.interceptSearch(inputText);\n      const searchText = this.interceptSearch ? alteredText : inputText;\n      if (this.interceptSearch && !alteredText) {\n        __privateGet(this, _listbox3).hideResults();\n        return;\n      }\n      __privateGet(this, _session3).suggest(searchText, this.options);\n      __privateGet(this, _setActionIcons2).call(this, true);\n    });\n    __privateAdd(this, _onHandleSelect3, (e) => {\n      const suggestion = e.detail;\n      __privateGet(this, _session3).retrieve(suggestion, this.options);\n      __privateGet(this, _setActionIcons2).call(this, true);\n    });\n    __privateAdd(this, _onHandleBlur3, () => {\n      __privateGet(this, _session3).abort();\n    });\n    __privateAdd(this, _setActionIcons2, (loading = false) => {\n      if (loading) {\n        __privateGet(this, _binding6).ClearBtn.style.display = \"none\";\n        __privateGet(this, _binding6).LoadingIcon.style.display = \"block\";\n      } else {\n        __privateGet(this, _binding6).LoadingIcon.style.display = \"none\";\n        __privateGet(this, _binding6).ClearBtn.style.display = this.value ? \"block\" : \"none\";\n      }\n    });\n    __privateAdd(this, _handleClear2, () => {\n      this.value = \"\";\n      __privateGet(this, _setActionIcons2).call(this);\n      __privateGet(this, _handleMarker2).call(this, null);\n      __privateGet(this, _listbox3).handleSuggest(null);\n    });\n    this.marker = true;\n    __privateAdd(this, _handleMoveEnd2, () => {\n      const map = __privateGet(this, _map2);\n      const options = __spreadValues({}, this.options);\n      if (map.getZoom() <= MAX_ZOOM2) {\n        delete options.proximity;\n        this.options = options;\n        return;\n      }\n      const center = map.getCenter();\n      this.options = __spreadProps(__spreadValues({}, options), {\n        proximity: center\n      });\n    });\n  }\n  get accessToken() {\n    return __privateGet(this, _search2).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _search2).accessToken = newToken;\n  }\n  get value() {\n    return __privateGet(this, _input3).value;\n  }\n  set value(newValue) {\n    __privateGet(this, _input3).value = newValue;\n  }\n  get input() {\n    return __privateGet(this, _input3);\n  }\n  get template() {\n    return GEOCODER_TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".Geocoder\", __privateGet(this, _listbox3).theme);\n  }\n  get theme() {\n    return __privateGet(this, _listbox3).theme;\n  }\n  set theme(theme) {\n    __privateGet(this, _listbox3).theme = theme;\n    if (!__privateGet(this, _binding6) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".Geocoder\", theme));\n    __privateGet(this, _listbox3).updatePopover();\n    const { SearchIcon } = __privateGet(this, _binding6);\n    SearchIcon.innerHTML = getIcon(\"search\", theme);\n  }\n  get popoverOptions() {\n    return __privateGet(this, _listbox3).popoverOptions;\n  }\n  set popoverOptions(newOptions) {\n    __privateGet(this, _listbox3).popoverOptions = newOptions;\n  }\n  get placeholder() {\n    return __privateGet(this, _placeholder2) || __privateMethod(this, _getDefaultPlaceholder2, getDefaultPlaceholder_fn2).call(this);\n  }\n  set placeholder(text) {\n    __privateSet(this, _placeholder2, text);\n    if (__privateGet(this, _input3)) {\n      __privateGet(this, _input3).placeholder = this.placeholder;\n      __privateGet(this, _input3).setAttribute(\"aria-label\", this.placeholder);\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding6, bindElements(this, {\n      Geocoder: \".Geocoder\",\n      SearchIcon: \".SearchIcon\",\n      Input: \".Input\",\n      ClearBtn: \".ClearBtn\",\n      LoadingIcon: \".LoadingIcon\"\n    }));\n    this.theme = __spreadValues({}, this.theme);\n    const { Input, ClearBtn } = __privateGet(this, _binding6);\n    __privateSet(this, _input3, Input);\n    __privateGet(this, _listbox3).input = Input;\n    __privateGet(this, _listbox3).searchService = 1 /* Geocoding */;\n    __privateGet(this, _listbox3).addEventListener(\"input\", __privateGet(this, _onHandleInput3));\n    __privateGet(this, _listbox3).addEventListener(\"select\", __privateGet(this, _onHandleSelect3));\n    __privateGet(this, _listbox3).addEventListener(\"blur\", __privateGet(this, _onHandleBlur3));\n    __privateGet(this, _session3).addEventListener(\"suggest\", __privateGet(this, _handleSuggest3));\n    __privateGet(this, _session3).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError3));\n    __privateGet(this, _session3).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve3));\n    ClearBtn.addEventListener(\"click\", __privateGet(this, _handleClear2));\n    this.placeholder = __privateGet(this, _placeholder2);\n    document.body.appendChild(__privateGet(this, _listbox3));\n    if (Input) {\n      if (Input.previousElementSibling.hasAttribute(\"aria-live\")) {\n        Input.previousElementSibling.remove();\n      }\n      Input.insertAdjacentElement(\"beforebegin\", createAriaLiveElement(__privateGet(this, _listbox3).dataSeed));\n    }\n  }\n  disconnectedCallback() {\n    __privateGet(this, _listbox3).remove();\n    __privateGet(this, _listbox3).input = null;\n    __privateGet(this, _listbox3).removeEventListener(\"input\", __privateGet(this, _onHandleInput3));\n    __privateGet(this, _listbox3).removeEventListener(\"select\", __privateGet(this, _onHandleSelect3));\n    __privateGet(this, _listbox3).removeEventListener(\"blur\", __privateGet(this, _onHandleBlur3));\n    __privateGet(this, _session3).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest3));\n    __privateGet(this, _session3).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError3));\n    __privateGet(this, _session3).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve3));\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      __privateGet(this, _search2).accessToken = newValue;\n      return;\n    }\n    if (name === \"theme\") {\n      this.theme = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"popover-options\") {\n      this.popoverOptions = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"placeholder\") {\n      this.placeholder = newValue;\n      return;\n    }\n    const optionName = name.split(\"-\").join(\"_\");\n    if (!newValue) {\n      delete this.options[optionName];\n    }\n    this.options[optionName] = newValue;\n    if (optionName === \"language\") {\n      this.placeholder = __privateGet(this, _placeholder2);\n    }\n  }\n  focus() {\n    __privateGet(this, _listbox3).focus();\n  }\n  search(text) {\n    this.value = text;\n    __privateGet(this, _onHandleInput3).call(this, new MapboxHTMLEvent(\"input\", text));\n  }\n  bindMap(map) {\n    if (__privateGet(this, _map2)) {\n      __privateGet(this, _map2).off(\"moveend\", __privateGet(this, _handleMoveEnd2));\n    }\n    if (map) {\n      map.on(\"moveend\", __privateGet(this, _handleMoveEnd2));\n    }\n    __privateSet(this, _map2, map);\n  }\n  unbindMap() {\n    this.bindMap(null);\n  }\n  onAdd(map) {\n    this.bindMap(map);\n    this.remove();\n    const container = document.createElement(\"div\");\n    container.className = \"mapboxgl-ctrl\";\n    container.style.width = \"300px\";\n    container.appendChild(this);\n    return container;\n  }\n  onRemove() {\n    this.remove();\n    this.unbindMap();\n    __privateGet(this, _removeMarker2).call(this);\n  }\n  getDefaultPosition() {\n    return \"top-right\";\n  }\n};\n_binding6 = new WeakMap();\n_search2 = new WeakMap();\n_session3 = new WeakMap();\n_map2 = new WeakMap();\n_input3 = new WeakMap();\n_listbox3 = new WeakMap();\n_getDefaultPlaceholder2 = new WeakSet();\ngetDefaultPlaceholder_fn2 = function() {\n  if (this.options.language) {\n    const firstLanguage = this.options.language.split(\",\")[0];\n    const language = subtag__WEBPACK_IMPORTED_MODULE_4___default().language(firstLanguage);\n    const localizedValue = localization_default.placeholder[language];\n    if (localizedValue)\n      return localizedValue;\n  }\n  return \"Search\";\n};\n_placeholder2 = new WeakMap();\n_handleSuggest3 = new WeakMap();\n_handleSuggestError3 = new WeakMap();\n_handleRetrieve3 = new WeakMap();\n_mapMarker2 = new WeakMap();\n_removeMarker2 = new WeakMap();\n_handleMarker2 = new WeakMap();\n_onHandleInput3 = new WeakMap();\n_onHandleSelect3 = new WeakMap();\n_onHandleBlur3 = new WeakMap();\n_setActionIcons2 = new WeakMap();\n_handleClear2 = new WeakMap();\n_handleMoveEnd2 = new WeakMap();\nMapboxGeocoder.observedAttributes = [\n  \"access-token\",\n  \"theme\",\n  \"popover-options\",\n  \"placeholder\",\n  \"autocomplete\",\n  \"language\",\n  \"country\",\n  \"bbox\",\n  \"limit\",\n  \"proximity\",\n  \"types\",\n  \"worldview\",\n  \"permanent\"\n];\nwindow.MapboxGeocoder = MapboxGeocoder;\nif (!window.customElements.get(\"mapbox-geocoder\")) {\n  customElements.define(\"mapbox-geocoder\", MapboxGeocoder);\n}\n\n// src/components/MapboxAddressMinimap.ts\n\n\n// src/utils/minimap.ts\n\nvar merc = new (_mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_5___default())({ size: 512, antimeridian: true });\nvar MAX_IMAGE_DIM = 1280;\nfunction getAnchorOffset(marker, anchor) {\n  const { width, height } = getElementSize(marker, true);\n  switch (anchor) {\n    case \"center\":\n      return [0, 0];\n    case \"top\":\n      return [0, height / 2];\n    case \"bottom\":\n      return [0, -1 * height / 2];\n    case \"left\":\n      return [width / 2, 0];\n    case \"right\":\n      return [-1 * width / 2, 0];\n    case \"top-left\":\n      return [width / 2, height / 2];\n    case \"top-right\":\n      return [-1 * width / 2, height / 2];\n    case \"bottom-left\":\n      return [width / 2, -1 * height / 2];\n    case \"bottom-right\":\n      return [-1 * width / 2, -1 * height / 2];\n  }\n}\nvar _anchor, _handleAnchorResize, _markerTransform, _isActive, _originalCoordinate, _onPointerDownMarker, _onPointerUpMarker, _onPointerMoveMarker, _onPointerDownImage, _onPointerUpImage, _onPointerMoveImage, _updatePointerPosition, _updateMarkerTransform, _updateMarkerCorrection;\nvar MarkerController = class {\n  constructor(imageContainer, imageElement, marker, keepMarkerCentered, zoom, anchor) {\n    __privateAdd(this, _anchor, void 0);\n    __privateAdd(this, _handleAnchorResize, () => {\n      [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, this.anchor);\n      this.markerTransform = {\n        anchorX: this.anchorOffsetX,\n        anchorY: this.anchorOffsetY\n      };\n    });\n    __privateAdd(this, _markerTransform, {\n      anchorX: 0,\n      anchorY: 0,\n      globalX: 0,\n      globalY: 0,\n      correctionX: 0,\n      correctionY: 0\n    });\n    __privateAdd(this, _isActive, false);\n    __privateAdd(this, _originalCoordinate, void 0);\n    __privateAdd(this, _onPointerDownMarker, (m) => {\n      if (!this.isActive)\n        return;\n      m.preventDefault();\n      m.stopPropagation();\n      __privateGet(this, _updatePointerPosition).call(this, m);\n      window.addEventListener(\"pointermove\", __privateGet(this, _onPointerMoveMarker));\n      window.addEventListener(\"pointerup\", __privateGet(this, _onPointerUpMarker));\n    });\n    __privateAdd(this, _onPointerUpMarker, () => {\n      window.removeEventListener(\"pointermove\", __privateGet(this, _onPointerMoveMarker));\n      window.removeEventListener(\"pointerup\", __privateGet(this, _onPointerUpMarker));\n    });\n    __privateAdd(this, _onPointerMoveMarker, (m) => {\n      m.preventDefault();\n      m.stopPropagation();\n      const diffX = this.curPointerXPos - m.pageX;\n      const diffY = this.curPointerYPos - m.pageY;\n      this.markerDeltaX += diffX;\n      this.markerDeltaY -= diffY;\n      this.markerDeltaX = Math.max(Math.min(this.imgElement.width / 2, this.markerDeltaX), this.imgElement.width / 2 * -1);\n      this.markerDeltaY = Math.max(Math.min(this.imgElement.height / 2, this.markerDeltaY), this.imgElement.height / 2 * -1);\n      const imageOffsetX = this.imgCenterPx[0] - this.imgCenterAdjustedPx[0];\n      const imageOffsetY = this.imgCenterPx[1] - this.imgCenterAdjustedPx[1];\n      const deltaX = this.markerDeltaX - imageOffsetX;\n      const deltaY = this.markerDeltaY + imageOffsetY;\n      this.markerTransform = { globalX: deltaX, globalY: deltaY };\n      __privateGet(this, _updatePointerPosition).call(this, m);\n    });\n    __privateAdd(this, _onPointerDownImage, (m) => {\n      if (!this.isActive)\n        return;\n      m.preventDefault();\n      m.stopPropagation();\n      __privateGet(this, _updatePointerPosition).call(this, m);\n      window.addEventListener(\"pointermove\", __privateGet(this, _onPointerMoveImage));\n      window.addEventListener(\"pointerup\", __privateGet(this, _onPointerUpImage));\n    });\n    __privateAdd(this, _onPointerUpImage, () => {\n      window.removeEventListener(\"pointermove\", __privateGet(this, _onPointerMoveImage));\n      window.removeEventListener(\"pointerup\", __privateGet(this, _onPointerUpImage));\n    });\n    __privateAdd(this, _onPointerMoveImage, (m) => {\n      m.preventDefault();\n      let top = Math.round(this.imgContainerElement.scrollTop + (this.curPointerYPos - m.pageY));\n      top = Math.max(Math.min(this.imgElement.height - this.imgContainerElement.clientHeight, top), 0);\n      let left = Math.round(this.imgContainerElement.scrollLeft + (this.curPointerXPos - m.pageX));\n      left = Math.max(Math.min(this.imgElement.width - this.imgContainerElement.clientWidth, left), 0);\n      this.imgContainerElement.scrollTop = top;\n      this.imgContainerElement.scrollLeft = left;\n      const diffX = Math.round(left - (this.imgElement.width - this.imgContainerElement.clientWidth) / 2);\n      const diffY = Math.round((this.imgElement.height - this.imgContainerElement.clientHeight) / 2 - top);\n      this.imgCenterAdjustedPx = [\n        this.imgCenterPx[0] + diffX,\n        this.imgCenterPx[1] - diffY\n      ];\n      if (!this.keepMarkerCentered) {\n        const deltaX = this.markerDeltaX + diffX;\n        const deltaY = this.markerDeltaY + diffY;\n        this.markerTransform = { globalX: deltaX, globalY: deltaY };\n      }\n      __privateGet(this, _updateMarkerCorrection).call(this, left, top);\n      __privateGet(this, _updatePointerPosition).call(this, m);\n    });\n    __privateAdd(this, _updatePointerPosition, (m) => {\n      this.curPointerXPos = m.pageX;\n      this.curPointerYPos = m.pageY;\n    });\n    __privateAdd(this, _updateMarkerTransform, () => {\n      const { anchorX, anchorY, globalX, globalY, correctionX, correctionY } = __privateGet(this, _markerTransform);\n      const transformX = anchorX - globalX + correctionX;\n      const transformY = anchorY + globalY + correctionY;\n      this.markerElement.style.transform = `translate(calc(-50% + ${transformX}px), calc(-50% + ${transformY}px))`;\n    });\n    this.reCenter = () => {\n      const top = (this.imgElement.height - this.imgContainerElement.clientHeight) / 2;\n      const left = (this.imgElement.width - this.imgContainerElement.clientWidth) / 2;\n      this.imgContainerElement.scrollTop = top;\n      this.imgContainerElement.scrollLeft = left;\n      this.imgCenterAdjustedPx = this.imgCenterPx;\n      this.markerDeltaX = this.markerDeltaY = 0;\n      this.markerTransform = {\n        globalX: 0,\n        globalY: 0,\n        correctionX: 0,\n        correctionY: 0\n      };\n    };\n    this.handleMinimapResize = () => {\n      if (!this.imgElement.height || !this.imgElement.width)\n        return;\n      const centerOffsetX = this.imgCenterOffset.x;\n      const centerOffsetY = this.imgCenterOffset.y;\n      const left = this.imgElement.width / 2 - centerOffsetX - this.imgContainerElement.clientWidth / 2;\n      const top = this.imgElement.height / 2 - centerOffsetY - this.imgContainerElement.clientHeight / 2;\n      this.imgContainerElement.scrollLeft = left;\n      this.imgContainerElement.scrollTop = top;\n      __privateGet(this, _updateMarkerCorrection).call(this, left, top);\n    };\n    __privateAdd(this, _updateMarkerCorrection, (scrollLeft, scrollTop) => {\n      const centerOffsetX = this.imgCenterOffset.x;\n      const centerOffsetY = this.imgCenterOffset.y;\n      const { correctionX, correctionY } = this.markerTransform;\n      const corrections = {};\n      if (scrollLeft / 2 < centerOffsetX * -1) {\n        const markerTranslateX = centerOffsetX * -1 - scrollLeft / 2;\n        corrections.correctionX = markerTranslateX * 2;\n      } else if (scrollLeft < 0) {\n        corrections.correctionX = scrollLeft;\n      } else if (correctionX !== 0) {\n        corrections.correctionX = 0;\n      }\n      if (scrollTop / 2 < centerOffsetY * -1) {\n        const markerTranslateY = centerOffsetY * -1 - scrollTop / 2;\n        corrections.correctionY = markerTranslateY * 2;\n      } else if (scrollTop < 0) {\n        corrections.correctionY = scrollTop;\n      } else if (correctionY !== 0) {\n        corrections.correctionY = 0;\n      }\n      this.markerTransform = corrections;\n    });\n    this.markerElement = marker;\n    this.imgContainerElement = imageContainer;\n    this.imgElement = imageElement;\n    this.keepMarkerCentered = keepMarkerCentered;\n    this.zoom = zoom;\n    this.anchor = anchor;\n    this.curPointerXPos = 0;\n    this.curPointerYPos = 0;\n    this.markerDeltaX = 0;\n    this.markerDeltaY = 0;\n    this.imgContainerElement.addEventListener(\"pointerdown\", __privateGet(this, _onPointerDownImage));\n    if (!this.keepMarkerCentered) {\n      this.markerElement.addEventListener(\"pointerdown\", __privateGet(this, _onPointerDownMarker));\n    }\n    const resizeObserver = new ResizeObserver(__privateGet(this, _handleAnchorResize));\n    resizeObserver.observe(this.markerElement);\n  }\n  get anchor() {\n    return __privateGet(this, _anchor);\n  }\n  set anchor(newAnchor) {\n    __privateSet(this, _anchor, newAnchor);\n    [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, newAnchor);\n    this.markerTransform = {\n      anchorX: this.anchorOffsetX,\n      anchorY: this.anchorOffsetY\n    };\n  }\n  get markerTransform() {\n    return __privateGet(this, _markerTransform);\n  }\n  set markerTransform(val) {\n    __privateSet(this, _markerTransform, __spreadValues(__spreadValues({}, __privateGet(this, _markerTransform)), val));\n    __privateGet(this, _updateMarkerTransform).call(this);\n  }\n  get isActive() {\n    return __privateGet(this, _isActive);\n  }\n  set isActive(val) {\n    this.imgContainerElement.style.touchAction = val ? \"none\" : \"\";\n    __privateSet(this, _isActive, val);\n  }\n  get coordinate() {\n    const adjustedPx = this.keepMarkerCentered ? this.imgCenterAdjustedPx : [\n      this.imgCenterPx[0] - this.markerDeltaX,\n      this.imgCenterPx[1] + this.markerDeltaY\n    ];\n    if (deepEquals(adjustedPx, this.imgCenterPx)) {\n      return __privateGet(this, _originalCoordinate);\n    } else {\n      const lngLat = merc.ll(adjustedPx, this.zoom);\n      return [round(lngLat[0], 6), round(lngLat[1], 6)];\n    }\n  }\n  set coordinate(lngLat) {\n    __privateSet(this, _originalCoordinate, lngLat);\n    this.imgCenterPx = this.imgCenterAdjustedPx = merc.px(lngLat, this.zoom);\n  }\n  get imgCenterOffset() {\n    return {\n      x: this.imgCenterPx[0] - this.imgCenterAdjustedPx[0],\n      y: this.imgCenterPx[1] - this.imgCenterAdjustedPx[1]\n    };\n  }\n};\n_anchor = new WeakMap();\n_handleAnchorResize = new WeakMap();\n_markerTransform = new WeakMap();\n_isActive = new WeakMap();\n_originalCoordinate = new WeakMap();\n_onPointerDownMarker = new WeakMap();\n_onPointerUpMarker = new WeakMap();\n_onPointerMoveMarker = new WeakMap();\n_onPointerDownImage = new WeakMap();\n_onPointerUpImage = new WeakMap();\n_onPointerMoveImage = new WeakMap();\n_updatePointerPosition = new WeakMap();\n_updateMarkerTransform = new WeakMap();\n_updateMarkerCorrection = new WeakMap();\n\n// src/icons/mapboxgl-ctrl-logo.svg\nvar mapboxgl_ctrl_logo_default = '<svg width=\"88\" height=\"23\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill-rule=\"evenodd\"><defs><path id=\"g\" d=\"M11.5 2.25a9.25 9.25 0 1 1 0 18.5 9.25 9.25 0 0 1 0-18.5zM7 15.98c-.05-.33-.83-5.8 2.23-8.87a4.4 4.4 0 0 1 3.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39a4.4 4.4 0 0 1-1.28 3.13C12.72 16.93 7 16 7 16v-.02zm8.3-5.48-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z\"/><path id=\"b\" d=\"M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19A3.77 3.77 0 0 1 50.86 15v3.77c0 .13-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01.01-.01c.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V15a3.7 3.7 0 0 1-2.73 1.19c-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.38-.19a4.24 4.24 0 0 0-4.16 3.29 4.07 4.07 0 0 0 0 1.77 4.23 4.23 0 0 0 4.17 3.3 4.22 4.22 0 0 0 4.26-4.19 4.2 4.2 0 0 0-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18a4 4 0 0 1 3.84 3.28c.13.59.13 1.2 0 1.8a4 4 0 0 1-3.84 3.29A3.77 3.77 0 0 1 60.86 15v.77c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4a.23.23 0 0 1-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55a2.73 2.73 0 0 1 2.44-1.56c1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.62 0h-1.61a.27.27 0 0 1-.12-.03c-.1-.06-.13-.19-.06-.28l2.43-3.71-2.4-3.65a.21.21 0 0 1-.02-.12.2.2 0 0 1 .2-.21h1.61c.13 0 .24.06.3.17L82 10.54l1.4-2.37a.34.34 0 0 1 .3-.17h1.6l.12.03c.1.06.13.19.06.28l-2.37 3.65 2.43 3.7.01.13a.2.2 0 0 1-.2.21h-1.61a.33.33 0 0 1-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 0 1-.3.17zm-7.12-1.49A2.47 2.47 0 0 1 70.7 12a2.47 2.47 0 0 1 2.42-2.52 2.47 2.47 0 0 1 2.42 2.51 2.48 2.48 0 0 1-2.42 2.52zm-19.87 0a2.48 2.48 0 0 1-2.42-2.48v-.07a2.47 2.47 0 0 1 2.4-2.49 2.47 2.47 0 0 1 2.41 2.51 2.47 2.47 0 0 1-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51a2.47 2.47 0 0 1 2.4-2.52 2.46 2.46 0 0 1 2.41 2.48l.02.08zm18.12 2.47a2.47 2.47 0 0 1-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51a2.47 2.47 0 0 1-2.42 2.51z\"/></defs><mask id=\"c\"><rect width=\"100%\" height=\"100%\" fill=\"#fff\"/><use xlink:href=\"#g\"/><use xlink:href=\"#b\"/></mask><g opacity=\".3\" stroke=\"#000\" stroke-width=\"3\"><circle mask=\"url(#c)\" cx=\"11.5\" cy=\"11.5\" r=\"9.25\"/><use xlink:href=\"#b\" mask=\"url(#c)\"/></g><g opacity=\".9\" fill=\"#fff\"><use xlink:href=\"#g\"/><use xlink:href=\"#b\"/></g></svg>';\n\n// src/components/MapboxAddressMinimap.ts\nvar ZOOM = 16;\nvar TEMPLATE4 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressMinimap\" aria-hidden=\"true\">\n    <div class=\"MinimapImageContainer\">\n      <img class=\"MinimapImage\" draggable=\"false\"></img>\n      <div class=\"MinimapInnerFrame\">\n        <div class=\"MinimapMarker\"></div>\n        <div class=\"MinimapAttribution\">\n          <div class=\"MinimapAttributionLogo\">\n            <a target=\"_blank\" rel=\"noopener nofollow\" href=\"https://www.mapbox.com/\" aria-label=\"Mapbox logo\">\n              ${mapboxgl_ctrl_logo_default}\n            </a>\n          </div>\n          <div class=\"MinimapAttributionText\">\n            <a target=\"_blank\" href='https://www.mapbox.com/about/maps/'>\\xA9 Mapbox</a><a target=\"_blank\" href='http://www.openstreetmap.org/copyright'>\\xA9 OpenStreetMap</a>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar STYLE_TOGGLE_TEMPLATE = createElementFromString(`\n<template>\n  <button type=\"button\" class=\"MinimapStyleToggle\"></button>\n</template>\n`);\nvar FOOTER_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MinimapFooter\">Adjust the marker on the map if it doesn't precisely match your location. This helps improve address data quality.</div>\n</template>\n`);\nvar ADJUST_PIN_TEXT = \"Adjust pin\";\nvar SAVE_TEXT = \"Save\";\nvar CANCEL_TEXT = \"Cancel\";\nvar EDIT_BUTTONS_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MinimapEditButtons\">\n    <div class=\"Button ButtonPrimary MinimapButtonAdjust\">${ADJUST_PIN_TEXT}</div>\n    <div class=\"Button ButtonPrimary MinimapButtonSave\" aria-hidden=\"true\">${SAVE_TEXT}</div>\n    <div class=\"Button MinimapButtonCancel\" aria-hidden=\"true\">${CANCEL_TEXT}</div>\n  </div>\n</template>\n`);\nvar _canAdjustMarkerInternal, _isAdjustMarkerEditing, _imageLoaded, _feature2, _url, _width, _height, _binding7, _markerController, _accessToken, _themeInternal5, _satelliteToggleInternal, _mapStyleMode, _adjustBtnText, _saveBtnText, _cancelBtnText, _defaultMapStyle, _footer, _container, _toggleMarkerEditing, _handleStartMarkerEditing, _handleSaveMarkerEditing, _handleCancelMarkerEditing, _handleToggleMapStyle, _handleImageLoad, _handleImageError, _getImageUrl, _updateImageSrc, _getToggleBackgroundImageUrl, _setSize, _addMarkerEditControls, _removeMarkerEditControls, _addSatelliteToggle, _removeSatelliteToggle;\nvar MapboxAddressMinimap = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _canAdjustMarkerInternal, false);\n    this.keepMarkerCentered = false;\n    this.markerAnchor = \"bottom\";\n    __privateAdd(this, _isAdjustMarkerEditing, false);\n    __privateAdd(this, _imageLoaded, false);\n    __privateAdd(this, _feature2, void 0);\n    __privateAdd(this, _url, \"\");\n    __privateAdd(this, _width, void 0);\n    __privateAdd(this, _height, void 0);\n    __privateAdd(this, _binding7, void 0);\n    __privateAdd(this, _markerController, void 0);\n    __privateAdd(this, _accessToken, void 0);\n    __privateAdd(this, _themeInternal5, {});\n    __privateAdd(this, _satelliteToggleInternal, false);\n    __privateAdd(this, _mapStyleMode, \"default\");\n    __privateAdd(this, _adjustBtnText, void 0);\n    __privateAdd(this, _saveBtnText, void 0);\n    __privateAdd(this, _cancelBtnText, void 0);\n    __privateAdd(this, _defaultMapStyle, [\"mapbox\", \"streets-v11\"]);\n    __privateAdd(this, _footer, void 0);\n    __privateAdd(this, _container, void 0);\n    __privateAdd(this, _toggleMarkerEditing, () => {\n      const { ImageContainer, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding7);\n      if (__privateGet(this, _isAdjustMarkerEditing)) {\n        ImageContainer.classList.add(`${this.dataset.seed}--draggable`);\n        __privateGet(this, _markerController).isActive = true;\n        ButtonAdjust.setAttribute(\"aria-hidden\", \"true\");\n        ButtonSave.removeAttribute(\"aria-hidden\");\n        ButtonCancel.removeAttribute(\"aria-hidden\");\n      } else {\n        ImageContainer.classList.remove(`${this.dataset.seed}--draggable`);\n        __privateGet(this, _markerController).isActive = false;\n        ButtonAdjust.removeAttribute(\"aria-hidden\");\n        ButtonSave.setAttribute(\"aria-hidden\", \"true\");\n        ButtonCancel.setAttribute(\"aria-hidden\", \"true\");\n      }\n    });\n    __privateAdd(this, _handleStartMarkerEditing, () => {\n      __privateSet(this, _isAdjustMarkerEditing, true);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleSaveMarkerEditing, () => {\n      if (this.feature.properties.full_address && !deepEquals(this.feature.geometry.coordinates, __privateGet(this, _markerController).coordinate)) {\n        const [lng, lat] = __privateGet(this, _markerController).coordinate;\n        sendFeedback(this.accessToken, {\n          originalCoordinate: this.feature.geometry.coordinates,\n          originalAddress: this.feature.properties.full_address,\n          changes: {\n            location: { longitude: lng, latitude: lat }\n          }\n        });\n      }\n      if (this.onSaveMarkerLocation) {\n        this.onSaveMarkerLocation(__privateGet(this, _markerController).coordinate);\n      }\n      __privateSet(this, _isAdjustMarkerEditing, false);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleCancelMarkerEditing, () => {\n      __privateGet(this, _markerController).reCenter();\n      __privateSet(this, _isAdjustMarkerEditing, false);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleToggleMapStyle, () => {\n      this.mapStyleMode = this.mapStyleMode === \"default\" ? \"satellite\" : \"default\";\n    });\n    __privateAdd(this, _handleImageLoad, () => {\n      if (!__privateGet(this, _imageLoaded)) {\n        __privateGet(this, _markerController).reCenter();\n      }\n      __privateSet(this, _imageLoaded, true);\n      __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();\n    });\n    __privateAdd(this, _handleImageError, () => {\n      __privateSet(this, _imageLoaded, false);\n    });\n    __privateAdd(this, _getImageUrl, (lngLatLike) => {\n      if (__privateGet(this, _width) === 0 || __privateGet(this, _height) === 0)\n        return \"\";\n      const [username, styleId] = this.defaultMapStyle;\n      const defaultBaseUrl = getStaticBaseUrl(username, styleId);\n      const baseUrl = this.mapStyleMode === \"default\" ? defaultBaseUrl : STATIC_BASE_URL_SATELLITE;\n      const skuToken = AUTOFILL_SKU_TOKEN_PREFIX + config.autofillSessionToken.toString();\n      let imgUrl = baseUrl + _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.LngLat.convert(lngLatLike).toArray().join(\",\") + \",\" + ZOOM + \",0/\" + Math.min(__privateGet(this, _width) * 2, MAX_IMAGE_DIM) + \"x\" + Math.min(__privateGet(this, _height) * 2, MAX_IMAGE_DIM) + \"?access_token=\" + this.accessToken + \"&attribution=false&logo=false\";\n      if (config.autofillSessionEnabled) {\n        imgUrl += `&sku=${skuToken}`;\n      }\n      return imgUrl;\n    });\n    __privateAdd(this, _updateImageSrc, () => {\n      if (__privateGet(this, _feature2)) {\n        const lngLat = __privateGet(this, _feature2).geometry.coordinates;\n        __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));\n        const { Image } = __privateGet(this, _binding7);\n        Image.src = __privateGet(this, _url);\n      }\n    });\n    __privateAdd(this, _getToggleBackgroundImageUrl, (styleMode) => {\n      return `url(\"${getImage(styleMode === \"default\" ? \"styleToggleDefault\" : \"styleToggleSatellite\", this.theme)}\")`;\n    });\n    __privateAdd(this, _setSize, () => {\n      const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image } = __privateGet(this, _binding7);\n      const { width, height } = getElementSize(this.container);\n      const [oldWidth, oldHeight] = [__privateGet(this, _width), __privateGet(this, _height)];\n      __privateSet(this, _width, Math.min(width, MAX_IMAGE_DIM));\n      __privateSet(this, _height, Math.min(height, MAX_IMAGE_DIM));\n      MapboxAddressMinimap2.style.setProperty(\"width\", `${__privateGet(this, _width)}px`);\n      MapboxAddressMinimap2.style.setProperty(\"height\", `${__privateGet(this, _height)}px`);\n      ImageContainer.style.setProperty(\"height\", `${__privateGet(this, _height)}px`);\n      ImageContainer.style.setProperty(\"width\", `${__privateGet(this, _width)}px`);\n      const [imgWidth, imgHeight] = [Image.width, Image.height];\n      if (__privateGet(this, _width) > oldWidth && __privateGet(this, _width) > imgWidth / 2 && imgWidth < MAX_IMAGE_DIM || __privateGet(this, _height) > oldHeight && __privateGet(this, _height) > imgHeight / 2 && imgHeight < MAX_IMAGE_DIM) {\n        __privateGet(this, _updateImageSrc).call(this);\n      } else {\n        __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();\n      }\n    });\n    __privateAdd(this, _addMarkerEditControls, () => {\n      const existingFooter = this.querySelector(\".MinimapFooter\");\n      if (existingFooter)\n        return;\n      const footerElement = this.prepareTemplate(FOOTER_TEMPLATE);\n      const minimapElement = this.querySelector(\".MapboxAddressMinimap\");\n      if (!minimapElement)\n        return;\n      minimapElement.appendChild(footerElement);\n      const existingEditBtns = this.querySelector(\".MinimapEditButtons\");\n      if (existingEditBtns)\n        return;\n      const editButtonsElement = this.prepareTemplate(EDIT_BUTTONS_TEMPLATE);\n      const innerFrame = this.querySelector(\".MinimapInnerFrame\");\n      innerFrame.appendChild(editButtonsElement);\n      __privateSet(this, _binding7, __spreadProps(__spreadValues({}, __privateGet(this, _binding7)), {\n        EditButtons: this.querySelector(\".MinimapEditButtons\"),\n        ButtonAdjust: this.querySelector(\".MinimapButtonAdjust\"),\n        ButtonSave: this.querySelector(\".MinimapButtonSave\"),\n        ButtonCancel: this.querySelector(\".MinimapButtonCancel\")\n      }));\n      const { ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding7);\n      ButtonAdjust.addEventListener(\"click\", __privateGet(this, _handleStartMarkerEditing));\n      ButtonSave.addEventListener(\"click\", __privateGet(this, _handleSaveMarkerEditing));\n      ButtonCancel.addEventListener(\"click\", __privateGet(this, _handleCancelMarkerEditing));\n    });\n    __privateAdd(this, _removeMarkerEditControls, () => {\n      if (!__privateGet(this, _binding7))\n        return;\n      const { EditButtons, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding7);\n      const existingFooter = this.querySelector(\".MinimapFooter\");\n      existingFooter == null ? void 0 : existingFooter.remove();\n      EditButtons == null ? void 0 : EditButtons.remove();\n      if (ButtonAdjust) {\n        ButtonAdjust.remove();\n        ButtonAdjust.removeEventListener(\"click\", __privateGet(this, _handleStartMarkerEditing));\n      }\n      if (ButtonSave) {\n        ButtonSave.remove();\n        ButtonSave.removeEventListener(\"click\", __privateGet(this, _handleSaveMarkerEditing));\n      }\n      if (ButtonCancel) {\n        ButtonCancel.remove();\n        ButtonCancel.removeEventListener(\"click\", __privateGet(this, _handleCancelMarkerEditing));\n      }\n      delete __privateGet(this, _binding7).EditButtons;\n      delete __privateGet(this, _binding7).ButtonAdjust;\n      delete __privateGet(this, _binding7).ButtonSave;\n      delete __privateGet(this, _binding7).ButtonCancel;\n    });\n    __privateAdd(this, _addSatelliteToggle, () => {\n      const existingToggle = this.querySelector(\".MinimapStyleToggle\");\n      if (existingToggle)\n        return;\n      const toggleElement = this.prepareTemplate(STYLE_TOGGLE_TEMPLATE);\n      const innerFrame = this.querySelector(\".MinimapInnerFrame\");\n      if (!innerFrame)\n        return;\n      innerFrame.appendChild(toggleElement);\n      __privateGet(this, _binding7).MapStyleToggle = toggleElement;\n      toggleElement.addEventListener(\"click\", __privateGet(this, _handleToggleMapStyle));\n      toggleElement.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === \"default\" ? \"satellite\" : \"default\");\n      toggleElement.setAttribute(\"title\", `Switch to ${this.mapStyleMode === \"default\" ? \"Satellite\" : \"Default\"}`);\n    });\n    __privateAdd(this, _removeSatelliteToggle, () => {\n      if (!__privateGet(this, _binding7))\n        return;\n      const { MapStyleToggle } = __privateGet(this, _binding7);\n      if (!MapStyleToggle)\n        return;\n      MapStyleToggle.remove();\n      MapStyleToggle.removeEventListener(\"click\", __privateGet(this, _handleToggleMapStyle));\n      delete __privateGet(this, _binding7).MapStyleToggle;\n    });\n  }\n  get canAdjustMarker() {\n    return __privateGet(this, _canAdjustMarkerInternal);\n  }\n  set canAdjustMarker(val) {\n    __privateSet(this, _canAdjustMarkerInternal, val);\n    val ? __privateGet(this, _addMarkerEditControls).call(this) : __privateGet(this, _removeMarkerEditControls).call(this);\n  }\n  get accessToken() {\n    return __privateGet(this, _accessToken) || config.accessToken;\n  }\n  set accessToken(newToken) {\n    __privateSet(this, _accessToken, newToken);\n  }\n  get feature() {\n    return __privateGet(this, _feature2);\n  }\n  set feature(feature) {\n    __privateSet(this, _feature2, feature);\n    if (!feature) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  get template() {\n    return TEMPLATE4;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressMinimap\", this.theme);\n  }\n  get satelliteToggle() {\n    return __privateGet(this, _satelliteToggleInternal);\n  }\n  set satelliteToggle(val) {\n    __privateSet(this, _satelliteToggleInternal, val);\n    val ? __privateGet(this, _addSatelliteToggle).call(this) : __privateGet(this, _removeSatelliteToggle).call(this);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal5);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal5, theme);\n    if (!__privateGet(this, _binding7) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressMinimap\", theme));\n    const { Marker, MapStyleToggle } = __privateGet(this, _binding7);\n    Marker.innerHTML = getIcon(\"marker\", theme);\n    if (MapStyleToggle) {\n      MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === \"default\" ? \"satellite\" : \"default\");\n    }\n  }\n  get adjustBtnText() {\n    return __privateGet(this, _adjustBtnText) || ADJUST_PIN_TEXT;\n  }\n  set adjustBtnText(val) {\n    __privateSet(this, _adjustBtnText, val);\n    const adjustBtn = this.querySelector(\".MinimapButtonAdjust\");\n    adjustBtn.textContent = val || ADJUST_PIN_TEXT;\n  }\n  get saveBtnText() {\n    return __privateGet(this, _saveBtnText) || SAVE_TEXT;\n  }\n  set saveBtnText(val) {\n    __privateSet(this, _saveBtnText, val);\n    const saveBtn = this.querySelector(\".MinimapButtonSave\");\n    saveBtn.textContent = val || SAVE_TEXT;\n  }\n  get cancelBtnText() {\n    return __privateGet(this, _cancelBtnText) || CANCEL_TEXT;\n  }\n  set cancelBtnText(val) {\n    __privateSet(this, _cancelBtnText, val);\n    const cancelBtn = this.querySelector(\".MinimapButtonCancel\");\n    cancelBtn.textContent = val || CANCEL_TEXT;\n  }\n  get mapStyleMode() {\n    return __privateGet(this, _mapStyleMode);\n  }\n  set mapStyleMode(styleMode) {\n    const prevStyleMode = __privateGet(this, _mapStyleMode);\n    if (prevStyleMode === styleMode)\n      return;\n    __privateSet(this, _mapStyleMode, styleMode);\n    if (!__privateGet(this, _binding7)) {\n      return;\n    }\n    const { MapStyleToggle } = __privateGet(this, _binding7);\n    if (!MapStyleToggle) {\n      return;\n    }\n    MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, prevStyleMode);\n    MapStyleToggle.setAttribute(\"title\", `Switch to ${prevStyleMode === \"satellite\" ? \"Satellite\" : \"Default\"}`);\n    __privateGet(this, _updateImageSrc).call(this);\n  }\n  get defaultMapStyle() {\n    return __privateGet(this, _defaultMapStyle);\n  }\n  set defaultMapStyle(style) {\n    __privateSet(this, _defaultMapStyle, style);\n    __privateGet(this, _updateImageSrc).call(this);\n  }\n  get footer() {\n    return __privateGet(this, _footer);\n  }\n  set footer(val) {\n    __privateSet(this, _footer, val);\n    const footerEl = this.querySelector(\".MinimapFooter\");\n    if (footerEl) {\n      if (typeof val === \"string\") {\n        footerEl.textContent = val;\n        footerEl.removeAttribute(\"aria-hidden\");\n      } else if (!val) {\n        footerEl.setAttribute(\"aria-hidden\", \"true\");\n      } else {\n        footerEl.removeAttribute(\"aria-hidden\");\n      }\n    }\n  }\n  get container() {\n    return __privateGet(this, _container);\n  }\n  set container(newContainer) {\n    if (newContainer) {\n      newContainer.style.position = \"relative\";\n      __privateSet(this, _container, newContainer);\n    }\n  }\n  show() {\n    if (!__privateGet(this, _feature2)) {\n      return;\n    }\n    const lngLat = __privateGet(this, _feature2).geometry.coordinates;\n    __privateGet(this, _markerController).coordinate = lngLat;\n    __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));\n    const { MapboxAddressMinimap: MapboxAddressMinimap2, Image } = __privateGet(this, _binding7);\n    Image.src = __privateGet(this, _url);\n    MapboxAddressMinimap2.removeAttribute(\"aria-hidden\");\n  }\n  hide() {\n    const { MapboxAddressMinimap: MapboxAddressMinimap2 } = __privateGet(this, _binding7);\n    MapboxAddressMinimap2.setAttribute(\"aria-hidden\", \"true\");\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding7, bindElements(this, {\n      MapboxAddressMinimap: \".MapboxAddressMinimap\",\n      ImageContainer: \".MinimapImageContainer\",\n      Image: \".MinimapImage\",\n      Marker: \".MinimapMarker\",\n      MapStyleToggle: \".MinimapStyleToggle\",\n      EditButtons: \".MinimapEditButtons\",\n      ButtonAdjust: \".MinimapButtonAdjust\",\n      ButtonSave: \".MinimapButtonSave\",\n      ButtonCancel: \".MinimapButtonCancel\"\n    }));\n    this.mapStyleMode = __privateGet(this, _mapStyleMode);\n    this.theme = __spreadValues({}, this.theme);\n    if (this.canAdjustMarker) {\n      __privateGet(this, _addMarkerEditControls).call(this);\n    }\n    if (this.satelliteToggle) {\n      __privateGet(this, _addSatelliteToggle).call(this);\n    }\n    this.container = this.parentElement;\n    const resizeObserver = new ResizeObserver(__privateGet(this, _setSize));\n    resizeObserver.observe(this.container);\n    __privateGet(this, _setSize).call(this);\n    const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image, Marker } = __privateGet(this, _binding7);\n    __privateSet(this, _markerController, new MarkerController(ImageContainer, Image, Marker, this.keepMarkerCentered, ZOOM, this.markerAnchor));\n    __privateGet(this, _markerController).reCenter();\n    Image.onload = __privateGet(this, _handleImageLoad);\n    Image.onerror = __privateGet(this, _handleImageError);\n    Image.src = __privateGet(this, _url);\n    if (__privateGet(this, _feature2))\n      MapboxAddressMinimap2.removeAttribute(\"aria-hidden\");\n    else\n      MapboxAddressMinimap2.setAttribute(\"aria-hidden\", \"true\");\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      this.accessToken = newValue;\n    } else if (name === \"can-adjust-marker\") {\n      this.canAdjustMarker = newValue === \"true\";\n    } else if (name === \"keep-marker-centered\") {\n      this.keepMarkerCentered = newValue === \"true\";\n    } else if (name === \"marker-anchor\") {\n      const newAnchor = newValue;\n      this.markerAnchor = newAnchor;\n      __privateGet(this, _markerController) && (__privateGet(this, _markerController).anchor = newAnchor);\n    } else if (name === \"satellite-toggle\") {\n      this.satelliteToggle = newValue === \"true\";\n    }\n  }\n};\n_canAdjustMarkerInternal = new WeakMap();\n_isAdjustMarkerEditing = new WeakMap();\n_imageLoaded = new WeakMap();\n_feature2 = new WeakMap();\n_url = new WeakMap();\n_width = new WeakMap();\n_height = new WeakMap();\n_binding7 = new WeakMap();\n_markerController = new WeakMap();\n_accessToken = new WeakMap();\n_themeInternal5 = new WeakMap();\n_satelliteToggleInternal = new WeakMap();\n_mapStyleMode = new WeakMap();\n_adjustBtnText = new WeakMap();\n_saveBtnText = new WeakMap();\n_cancelBtnText = new WeakMap();\n_defaultMapStyle = new WeakMap();\n_footer = new WeakMap();\n_container = new WeakMap();\n_toggleMarkerEditing = new WeakMap();\n_handleStartMarkerEditing = new WeakMap();\n_handleSaveMarkerEditing = new WeakMap();\n_handleCancelMarkerEditing = new WeakMap();\n_handleToggleMapStyle = new WeakMap();\n_handleImageLoad = new WeakMap();\n_handleImageError = new WeakMap();\n_getImageUrl = new WeakMap();\n_updateImageSrc = new WeakMap();\n_getToggleBackgroundImageUrl = new WeakMap();\n_setSize = new WeakMap();\n_addMarkerEditControls = new WeakMap();\n_removeMarkerEditControls = new WeakMap();\n_addSatelliteToggle = new WeakMap();\n_removeSatelliteToggle = new WeakMap();\nMapboxAddressMinimap.observedAttributes = [\n  \"access-token\",\n  \"can-adjust-marker\",\n  \"keep-marker-centered\",\n  \"marker-anchor\",\n  \"satellite-toggle\"\n];\nwindow.MapboxAddressMinimap = MapboxAddressMinimap;\nif (!window.customElements.get(\"mapbox-address-minimap\")) {\n  customElements.define(\"mapbox-address-minimap\", MapboxAddressMinimap);\n}\n\n// src/autofill.ts\n\nvar _input4, _collection, _session4, _initialAutocompleteValue2, _onHandleInput4, _onHandleSelect4, _onHandleBlur4, _onHandleFocus2, _handleSuggest4, _handleSuggestError4, _handleRetrieve4;\nvar AddressAutofillInstance = class {\n  constructor(collection, input, autofillRef) {\n    __privateAdd(this, _input4, void 0);\n    __privateAdd(this, _collection, void 0);\n    __privateAdd(this, _session4, void 0);\n    this.options = {};\n    this.retrieveFeature = null;\n    this.listbox = new MapboxSearchListbox();\n    __privateAdd(this, _initialAutocompleteValue2, void 0);\n    __privateAdd(this, _onHandleInput4, (e) => {\n      const value = e.detail;\n      const enableBrowserAutocomplete = __privateGet(this, _collection).browserAutofillEnabled === true && (value == null ? void 0 : value.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input4), __privateGet(this, _initialAutocompleteValue2), enableBrowserAutocomplete);\n      if ((value == null ? void 0 : value.length) <= 2) {\n        this.listbox.handleSuggest(null);\n        return;\n      }\n      __privateGet(this, _session4).suggest(value, this.options);\n    });\n    __privateAdd(this, _onHandleSelect4, (e) => {\n      const suggestion = e.detail;\n      if (e.detail.accuracy !== \"street\") {\n        toggleAutocompletion(__privateGet(this, _input4), __privateGet(this, _initialAutocompleteValue2), true);\n        __privateGet(this, _session4).retrieve(suggestion, this.options);\n      } else {\n        handleStreetSelection(__privateGet(this, _input4), __privateGet(this, _initialAutocompleteValue2), suggestion);\n      }\n    });\n    __privateAdd(this, _onHandleBlur4, () => {\n      toggleAutocompletion(__privateGet(this, _input4), __privateGet(this, _initialAutocompleteValue2), true);\n      __privateGet(this, _session4).abort();\n    });\n    __privateAdd(this, _onHandleFocus2, () => {\n      var _a;\n      const enableBrowserAutocomplete = __privateGet(this, _collection).browserAutofillEnabled === true && ((_a = __privateGet(this, _input4).value) == null ? void 0 : _a.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input4), __privateGet(this, _initialAutocompleteValue2), enableBrowserAutocomplete);\n    });\n    __privateAdd(this, _handleSuggest4, (result) => {\n      const filteredSuggestions = (result == null ? void 0 : result.suggestions) ? distinctExactStreetResults(result.suggestions) : null;\n      this.listbox.handleSuggest(filteredSuggestions);\n      const event = new MapboxHTMLEvent(\"suggest\", result);\n      Object.defineProperty(event, \"target\", { value: __privateGet(this, _input4) });\n      __privateGet(this, _collection).fire(\"suggest\", event);\n    });\n    __privateAdd(this, _handleSuggestError4, (error) => {\n      this.listbox.handleError();\n      const event = new MapboxHTMLEvent(\"suggesterror\", error);\n      Object.defineProperty(event, \"target\", { value: __privateGet(this, _input4) });\n      __privateGet(this, _collection).fire(\"suggesterror\", event);\n    });\n    __privateAdd(this, _handleRetrieve4, (result) => {\n      var _a;\n      const event = new MapboxHTMLEvent(\"retrieve\", result);\n      Object.defineProperty(event, \"target\", { value: __privateGet(this, _input4) });\n      __privateGet(this, _collection).fire(\"retrieve\", event);\n      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];\n      if (!__privateGet(this, _input4)) {\n        return;\n      }\n      const featureCollection = result;\n      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {\n        return;\n      }\n      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input4));\n    });\n    __privateSet(this, _input4, input);\n    __privateSet(this, _collection, collection);\n    __privateSet(this, _session4, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchSession(autofillRef));\n    __privateGet(this, _session4).sessionToken = config.autofillSessionToken;\n    this.listbox.input = __privateGet(this, _input4);\n    this.listbox.autofillHost = this;\n    this.listbox.searchService = 0 /* AddressAutofill */;\n    this.listbox.addEventListener(\"input\", __privateGet(this, _onHandleInput4));\n    this.listbox.addEventListener(\"select\", __privateGet(this, _onHandleSelect4));\n    this.listbox.addEventListener(\"blur\", __privateGet(this, _onHandleBlur4));\n    this.listbox.addEventListener(\"focus\", __privateGet(this, _onHandleFocus2));\n    __privateGet(this, _session4).addEventListener(\"suggest\", __privateGet(this, _handleSuggest4));\n    __privateGet(this, _session4).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError4));\n    __privateGet(this, _session4).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve4));\n    document.body.appendChild(this.listbox);\n    if (input) {\n      input.insertAdjacentElement(\"beforebegin\", createAriaLiveElement(this.listbox.dataSeed));\n      suppressExtensionsAutocomplete(input);\n      __privateSet(this, _initialAutocompleteValue2, input.autocomplete);\n    }\n  }\n  get input() {\n    return __privateGet(this, _input4);\n  }\n  remove() {\n    this.listbox.remove();\n    this.listbox.removeEventListener(\"input\", __privateGet(this, _onHandleInput4));\n    this.listbox.removeEventListener(\"select\", __privateGet(this, _onHandleSelect4));\n    this.listbox.removeEventListener(\"blur\", __privateGet(this, _onHandleBlur4));\n    this.listbox.removeEventListener(\"focus\", __privateGet(this, _onHandleFocus2));\n    __privateGet(this, _session4).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest4));\n    __privateGet(this, _session4).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError4));\n    __privateGet(this, _session4).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve4));\n  }\n  simulateRetrieve(feature) {\n    const input = __privateGet(this, _input4);\n    if (input) {\n      input.dataset[\"mapboxSuccess\"] = \"true\";\n    }\n    this.listbox.hideResults();\n    const simResult = {\n      type: \"FeatureCollection\",\n      features: [feature],\n      url: \"\"\n    };\n    __privateGet(this, _handleRetrieve4).call(this, simResult);\n  }\n};\n_input4 = new WeakMap();\n_collection = new WeakMap();\n_session4 = new WeakMap();\n_initialAutocompleteValue2 = new WeakMap();\n_onHandleInput4 = new WeakMap();\n_onHandleSelect4 = new WeakMap();\n_onHandleBlur4 = new WeakMap();\n_onHandleFocus2 = new WeakMap();\n_handleSuggest4 = new WeakMap();\n_handleSuggestError4 = new WeakMap();\n_handleRetrieve4 = new WeakMap();\nvar _currentInputs, _autofill2, _options2, _theme, _popoverOptions2, _handleObserve2, _observer2, _handleBrowserAutofill2;\nvar AddressAutofillCollection = class extends _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.Evented {\n  constructor({\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    confirmOnBrowserAutofill,\n    browserAutofillEnabled\n  }) {\n    super();\n    this.instances = [];\n    __privateAdd(this, _currentInputs, void 0);\n    __privateAdd(this, _autofill2, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.AddressAutofillCore());\n    __privateAdd(this, _options2, void 0);\n    __privateAdd(this, _theme, void 0);\n    __privateAdd(this, _popoverOptions2, void 0);\n    this.confirmOnBrowserAutofill = false;\n    this.browserAutofillEnabled = false;\n    __privateAdd(this, _handleObserve2, () => {\n      if (!deepEquals(findAddressInputs(), __privateGet(this, _currentInputs))) {\n        this.update();\n      }\n    });\n    __privateAdd(this, _observer2, new MutationObserver(__privateGet(this, _handleObserve2)));\n    __privateAdd(this, _handleBrowserAutofill2, (e) => __async(this, null, function* () {\n      this.instances.forEach((instance) => instance.listbox.blur());\n      for (const instance of this.instances) {\n        const input = instance.listbox.input;\n        yield tryConfirmBrowserAutofill(input, e, this.confirmOnBrowserAutofill, this.accessToken);\n      }\n    }));\n    initDetectBrowserAutofill();\n    window.addEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill2));\n    config.autofillSessionEnabled = true;\n    this.accessToken = accessToken || config.accessToken;\n    options && (this.options = options);\n    theme && (this.theme = theme);\n    popoverOptions && (this.popoverOptions = popoverOptions);\n    confirmOnBrowserAutofill && (this.confirmOnBrowserAutofill = confirmOnBrowserAutofill);\n    browserAutofillEnabled && (this.browserAutofillEnabled = browserAutofillEnabled);\n    this.update();\n  }\n  get accessToken() {\n    return __privateGet(this, _autofill2).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _autofill2).accessToken = newToken;\n  }\n  get options() {\n    return __privateGet(this, _options2);\n  }\n  set options(newOptions) {\n    __privateSet(this, _options2, __spreadValues(__spreadValues({}, __privateGet(this, _options2)), newOptions));\n    this.instances.forEach((instance) => {\n      instance.options = __spreadValues(__spreadValues({}, instance.options), newOptions);\n    });\n  }\n  get theme() {\n    return __privateGet(this, _theme);\n  }\n  set theme(newTheme) {\n    __privateSet(this, _theme, newTheme);\n    this.instances.forEach((instance) => {\n      instance.listbox.theme = newTheme;\n    });\n  }\n  get popoverOptions() {\n    return __privateGet(this, _popoverOptions2);\n  }\n  set popoverOptions(newOptions) {\n    __privateSet(this, _popoverOptions2, newOptions);\n    this.instances.forEach((instance) => {\n      instance.listbox.popoverOptions = newOptions;\n    });\n  }\n  update() {\n    this.instances.forEach((instance) => {\n      instance.remove();\n    });\n    __privateSet(this, _currentInputs, findAddressInputs());\n    this.instances = [];\n    __privateGet(this, _currentInputs).forEach((input) => {\n      const autofillInstance = new AddressAutofillInstance(this, input, __privateGet(this, _autofill2));\n      autofillInstance.options = this.options;\n      autofillInstance.listbox.theme = this.theme;\n      autofillInstance.listbox.popoverOptions = this.popoverOptions;\n      this.instances.push(autofillInstance);\n    });\n  }\n  observe() {\n    __privateGet(this, _observer2).observe(document, {\n      subtree: true,\n      childList: true\n    });\n    __privateGet(this, _handleObserve2).call(this);\n  }\n  unobserve() {\n    __privateGet(this, _observer2).disconnect();\n  }\n  remove() {\n    this.instances.forEach((instance) => {\n      instance.remove();\n    });\n    this.unobserve();\n    window.removeEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill2));\n  }\n};\n_currentInputs = new WeakMap();\n_autofill2 = new WeakMap();\n_options2 = new WeakMap();\n_theme = new WeakMap();\n_popoverOptions2 = new WeakMap();\n_handleObserve2 = new WeakMap();\n_observer2 = new WeakMap();\n_handleBrowserAutofill2 = new WeakMap();\nfunction autofill(optionsArg) {\n  return new AddressAutofillCollection(optionsArg);\n}\n\n//# sourceMappingURL=index-esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtd2ViL2Rpc3QvaW5kZXgtZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEUsbUVBQW1FLElBQUksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxFQUFFLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsRUFBRSw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTLEdBQUcsUUFBUTtBQUNqRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEIsSUFBSSxVQUFVO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUVBQW1FLFFBQVE7QUFDM0UsaUVBQWlFLFFBQVE7QUFDekU7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLG9EQUFvRCxpREFBaUQ7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxJQUFJLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSyxFQUFFLFNBQVM7QUFDcEY7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0IsRUFBRSxnQkFBZ0IsSUFBSSxJQUFJLElBQUksYUFBYSxlQUFlO0FBQ2xHLDBCQUEwQixJQUFJLElBQUksY0FBYztBQUNoRDtBQUNBLHNCQUFzQixnQkFBZ0IsRUFBRSxnQkFBZ0I7QUFDeEQ7QUFDQSxxQ0FBcUM7QUFDckMsZ0RBQWdELHlDQUF5QztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaURBQWlELDJDQUEyQztBQUM1RjtBQUNBO0FBQ0E7O0FBRUE7QUFNMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQU07QUFDaEIsK0JBQStCLHNEQUFJO0FBQ25DO0FBQ0E7QUFDQSxjQUFjLE9BQU8sUUFBUSxpRUFBZTtBQUM1QztBQUNBLGlCQUFpQixFQUFFO0FBQ25CLGdCQUFnQixFQUFFO0FBQ2xCLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxtQkFBbUIsNERBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnQ0FBZ0MsY0FBYyxlQUFlLGNBQWMsVUFBVSxhQUFhLFNBQVMsd0NBQXdDLHFCQUFxQixrQ0FBa0MsNEJBQTRCLHVCQUF1Qiw4QkFBOEIsc0JBQXNCLDhCQUE4Qiw4QkFBOEIsMEJBQTBCLGdCQUFnQixrQkFBa0Isd0JBQXdCLHNDQUFzQyxtQkFBbUIsYUFBYSxpQ0FBaUMsbUJBQW1CLDJCQUEyQiwrREFBK0Qsa0JBQWtCLFlBQVksbUJBQW1CLGFBQWEsdUJBQXVCLGtCQUFrQixlQUFlLGdDQUFnQyw2Q0FBNkMsbUJBQW1CLDhDQUE4QyxnQkFBZ0Isa0NBQWtDLGdCQUFnQixpQkFBaUIsa0NBQWtDLGFBQWEsb0JBQW9CLGtDQUFrQyxzQkFBc0IsNEJBQTRCLGtDQUFrQyxxQkFBcUIsYUFBYSxnQkFBZ0IsU0FBUyxVQUFVLE9BQU8sYUFBYSxxQkFBcUIsd0NBQXdDLHFCQUFxQixrQ0FBa0MsNEJBQTRCLHVCQUF1Qiw4QkFBOEIsc0JBQXNCLDhCQUE4Qiw4QkFBOEIsdUJBQXVCLGlCQUFpQixjQUFjLGtCQUFrQixXQUFXLFlBQVksYUFBYSxVQUFVLHdCQUF3QixTQUFTLFlBQVksY0FBYyxrQkFBa0IsTUFBTSxXQUFXLFlBQVksV0FBVyxtQkFBbUIsZ0JBQWdCLFlBQVksY0FBYyxlQUFlLGFBQWEsWUFBWSxnQkFBZ0IsVUFBVSxXQUFXLHlCQUF5QiwwQkFBMEIsVUFBVSxhQUFhLGdCQUFnQixjQUFjLGFBQWEsaUVBQWlFLG9FQUFvRSw0REFBNEQsYUFBYSxZQUFZLDBCQUEwQixHQUFHLDRCQUE0QixvQkFBb0IsR0FBRyxnQ0FBZ0MseUJBQXlCLGtCQUFrQixHQUFHLDRCQUE0QixvQkFBb0IsR0FBRyxnQ0FBZ0MseUJBQXlCLE9BQU8sNkJBQTZCLFNBQVMsY0FBYyxzQkFBc0IsYUFBYSxZQUFZLFNBQVMsZ0JBQWdCLGVBQWUsdUJBQXVCLG1CQUFtQixXQUFXLGtCQUFrQixhQUFhLGFBQWEsbUJBQW1CLGtDQUFrQyxnQkFBZ0IsY0FBYyxzQkFBc0IsVUFBVSwrR0FBK0csYUFBYSwyQkFBMkIsbUJBQW1CLHNDQUFzQyxTQUFTLGFBQWEsdUJBQXVCLE9BQU8sZUFBZSxRQUFRLE1BQU0sd0JBQXdCLGFBQWEsbURBQW1ELHVEQUF1RCxtQkFBbUIsNkNBQTZDLGtCQUFrQixrQ0FBa0Msc0JBQXNCLE9BQU8sd0NBQXdDLHFCQUFxQixrQ0FBa0MsNEJBQTRCLHVCQUF1Qiw4QkFBOEIsc0JBQXNCLDhCQUE4Qiw4QkFBOEIsNEJBQTRCLFdBQVcsb0NBQW9DLDJCQUEyQixxQkFBcUIsa0NBQWtDLFdBQVcsT0FBTyw0QkFBNEIsOEJBQThCLGFBQWEsbUJBQW1CLDBCQUEwQixhQUFhLDRCQUE0QixrQ0FBa0MsNkJBQTZCLGlCQUFpQixXQUFXLFVBQVUsa0NBQWtDLHlDQUF5Qyx5Q0FBeUMsNEJBQTRCLGFBQWEsTUFBTSx5QkFBeUIsd0JBQXdCLGdCQUFnQiw0QkFBNEIsa0JBQWtCLE9BQU8sa0JBQWtCLGFBQWEsNEJBQTRCLDBCQUEwQixrQkFBa0IsK0JBQStCLGFBQWEsZ0JBQWdCLGtDQUFrQyxpQkFBaUIsa0JBQWtCLDBCQUEwQiw4QkFBOEIsNkJBQTZCLGtDQUFrQywwQkFBMEIsUUFBUSxrQ0FBa0MsZUFBZSxzQ0FBc0MsMEJBQTBCLHVCQUF1QixrQkFBa0IsaUJBQWlCLFdBQVcsMEJBQTBCLGFBQWEsc0JBQXNCLHFDQUFxQyw2QkFBNkIsd0JBQXdCLHVDQUF1Qyw0QkFBNEIsa0JBQWtCLEdBQUcsVUFBVSxHQUFHLFdBQVcsc0JBQXNCLDhCQUE4QixzQkFBc0IsOEJBQThCLDhCQUE4Qix3Q0FBd0MsYUFBYSx1QkFBdUIsa0NBQWtDLGdCQUFnQixjQUFjLGFBQWEsaUJBQWlCLGdCQUFnQixrQkFBa0IsWUFBWSxtQkFBbUIscUJBQXFCLHNCQUFzQixlQUFlLE9BQU8sZ0JBQWdCLGtCQUFrQixNQUFNLGNBQWMsZUFBZSxTQUFTLGtCQUFrQixRQUFRLG1CQUFtQiwwQkFBMEIsd0JBQXdCLHdCQUF3QixTQUFTLE9BQU8sbUJBQW1CLGtCQUFrQiwwQkFBMEIsZUFBZSxjQUFjLFlBQVksV0FBVyx3QkFBd0IscUNBQXFDLFNBQVMseURBQXlELGNBQWMsa0JBQWtCLFFBQVEsMEJBQTBCLHNCQUFzQixxQkFBcUIsZ0NBQWdDLGNBQWMsMEJBQTBCLDRDQUE0QyxnQkFBZ0Isb0JBQW9CLHNCQUFzQiw0QkFBNEIsd0JBQXdCLHNCQUFzQixrQkFBa0IsNEJBQTRCLGVBQWUsV0FBVyxrQkFBa0IscUJBQXFCLG1CQUFtQixVQUFVLGVBQWUsNEJBQTRCLDhCQUE4QixzQkFBc0IsMEJBQTBCLGlDQUFpQyxhQUFhLG9CQUFvQixZQUFZLGFBQWEsOEJBQThCLGtCQUFrQixxQkFBcUIsNEJBQTRCLDRCQUE0QixxQkFBcUIsd0NBQXdDLDJCQUEyQixXQUFXLFlBQVksWUFBWSxrQkFBa0IsZ0JBQWdCOztBQUVuZ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixpQkFBaUIsRUFBRSxxREFBcUQsYUFBYSxRQUFRLElBQUksY0FBYyxLQUFLLGlCQUFpQjtBQUN2Tix5REFBeUQsaUJBQWlCLEVBQUUscURBQXFEOztBQUVqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrQkFBK0IsWUFBWSxvQkFBb0IsbUJBQW1CLGlCQUFpQixhQUFhLG1CQUFtQixvQkFBb0IsV0FBVztBQUNqTjtBQUNBLG9DQUFvQyxLQUFLLElBQUksb0JBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsS0FBSyxJQUFJLG9CQUFvQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksYUFBYSxHQUFHLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDBDQUEwQztBQUMxQztBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEdBQUc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkVBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHZ0M7O0FBRWhDO0FBSWdDO0FBQ0M7QUFDWTs7QUFFN0M7QUFDdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBLElBQUksb0RBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWMsMEZBQTBGO0FBQ3hHLGNBQWMsOENBQThDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtREFBVztBQUNqQjtBQUNBLHFDQUFxQywyREFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDLDJCQUEyQixrRUFBYztBQUN6QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhGQUE4Rix1RUFBbUI7QUFDakgsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw2QkFBNkIsMkVBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQXdDLEVBQUUsb0NBQW9DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTLEdBQUcseUJBQXlCLHdCQUF3QixZQUFZO0FBQzFGLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLEdBQUcsb0JBQW9CO0FBQ3ZFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQXdEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksaUVBQWlFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlnQzs7QUFFaEM7QUFDa0Q7O0FBRWxEO0FBQ0EsZ0hBQWdILHNDQUFzQywyRkFBMkYsdUNBQXVDLGtDQUFrQyxHQUFHLHdDQUF3QyxHQUFHLHlDQUF5QyxtQ0FBbUMsR0FBRyx5Q0FBeUMsR0FBRywwQ0FBMEM7O0FBRTdnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixnRUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1RUFBbUI7QUFDekQscUNBQXFDLGlFQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTWdDO0FBQ0o7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlFQUFhLEdBQUc7QUFDcEQsc0NBQXNDLGlFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyRUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFZO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtDQUFrQztBQUNsQyxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtnQztBQUNIO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlFQUFhLEdBQUc7QUFDckQsc0NBQXNDLGlFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0VBQWE7QUFDakQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0NBQWtDO0FBQ2xDLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRDs7QUFFaEQ7QUFDMEQ7QUFDMUQsZUFBZSxrRUFBaUIsR0FBRywrQkFBK0I7QUFDbEU7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVcsbUJBQW1CLFdBQVc7QUFDN0csS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUUsNkVBQTZFLFVBQVU7QUFDdkYsaUVBQWlFLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBeUQ7QUFDdkU7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQU07QUFDbkM7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQiw4RkFBOEY7QUFDbkgsS0FBSztBQUNMO0FBQ0EsY0FBYyxxRUFBcUU7QUFDbkYsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJCQUEyQjtBQUNyRiwyREFBMkQsNEJBQTRCO0FBQ3ZGLG9EQUFvRCw0QkFBNEI7QUFDaEYsbURBQW1ELDJCQUEyQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwREFBMEQ7QUFDakgsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3REFBd0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQXFEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkVBQTZFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9DQUFvQztBQUNuRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0NBQW9DO0FBQ25GO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQyxpRUFBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkRBQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVFQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EseURBQXlEO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtd2ViL2Rpc3QvaW5kZXgtZXNtLmpzPzhhNzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvdXRpbHMvZG9tLnRzXG52YXIgc3ViZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG5mdW5jdGlvbiBiaW5kRWxlbWVudHMocm9vdCwgZWxlbWVudHMpIHtcbiAgY29uc3QgYmluZGluZyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcyhlbGVtZW50cykpIHtcbiAgICBiaW5kaW5nW2tleV0gPSByb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG4gIHJldHVybiBiaW5kaW5nO1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRFbGVtZW50cyhub2RlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcyB8fCBbXSkuZmlsdGVyKChlbCkgPT4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGlubmVySFRNTCkge1xuICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNTU1N0eWxlU2hlZXQodGV4dCkge1xuICBjb25zdCBzdHlsZSA9IHN1YmRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgc3ViZG9jLmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICByZXR1cm4gc3R5bGUuc2hlZXQ7XG59XG5mdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCkge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCI7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGlucHV0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ2YWx1ZVwiKS5zZXQ7XG4gIHNldC5jYWxsKGlucHV0LCB2YWx1ZSk7XG4gIGNvbnN0IHdyYXBwZXJTdGF0ZSA9IGlucHV0O1xuICBpZiAod3JhcHBlclN0YXRlLl92YWx1ZVRyYWNrZXIpIHtcbiAgICB3cmFwcGVyU3RhdGUuX3ZhbHVlVHJhY2tlci5zZXRWYWx1ZShcIlwiKTtcbiAgfVxuICBjb25zdCBvbklucHV0RXZlbnQgPSBuZXcgRXZlbnQoXCJpbnB1dFwiLCB7XG4gICAgYnViYmxlczogdHJ1ZVxuICB9KTtcbiAgb25JbnB1dEV2ZW50LnNpbXVsYXRlZCA9IHRydWU7XG4gIGlucHV0LmRpc3BhdGNoRXZlbnQob25JbnB1dEV2ZW50KTtcbiAgY29uc3Qgb25DaGFuZ2VFdmVudCA9IG5ldyBFdmVudChcImNoYW5nZVwiLCB7XG4gICAgYnViYmxlczogdHJ1ZVxuICB9KTtcbiAgb25DaGFuZ2VFdmVudC5zaW11bGF0ZWQgPSB0cnVlO1xuICBpbnB1dC5kaXNwYXRjaEV2ZW50KG9uQ2hhbmdlRXZlbnQpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFNpemUoZWxlbWVudCwgZGVlcCA9IGZhbHNlKSB7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtZW50UmVjdC5oZWlnaHQgPT09IDAgJiYgZWxlbWVudFJlY3Qud2lkdGggPT09IDApIHtcbiAgICBjb25zdCBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKGRlZXApO1xuICAgIGVsZW1lbnQucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgY2xvbmUuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgY29uc3QgY2xvbmVSZWN0ID0gY2xvbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgd2lkdGggPSBjbG9uZVJlY3Qud2lkdGg7XG4gICAgaGVpZ2h0ID0gY2xvbmVSZWN0LmhlaWdodDtcbiAgICBjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGNsb25lLnJlbW92ZSgpO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gZWxlbWVudFJlY3Qud2lkdGg7XG4gICAgaGVpZ2h0ID0gZWxlbWVudFJlY3QuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBNYXRoLmZsb29yKGhlaWdodCksXG4gICAgd2lkdGg6IE1hdGguZmxvb3Iod2lkdGgpXG4gIH07XG59XG5mdW5jdGlvbiBhZGREb2N1bWVudFN0eWxlKGNzcykge1xuICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NsYXNzX25hbWVfdHJhbnNmb3JtZXJzLnRzXG52YXIgSURFTlRJRklFUl9SRUdFWCA9IG5ldyBSZWdFeHAoXCJbX2EtekEtWl0rW19hLXpBLVowLTktXSpcIiwgXCJnXCIpO1xudmFyIENMQVNTX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKGBcXFxcLiR7SURFTlRJRklFUl9SRUdFWC5zb3VyY2V9YCwgXCJnXCIpO1xudmFyIENPTkRJVElPTl9SVUxFX1JFR0VYID0gbmV3IFJlZ0V4cChgXlxcXFxzKihAKD86bWVkaWF8c3VwcG9ydHMpW157XSopeyguKil9XFxcXHMqJGApO1xuZnVuY3Rpb24gdHJhbnNmb3JtQ2xhc3NTZWxlY3RvcnMoY3NzLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGNzcy5yZXBsYWNlKENMQVNTX05BTUVfUkVHRVgsIChjbGFzc05hbWUpID0+IHtcbiAgICByZXR1cm4gXCIuXCIgKyB0cmFuc2Zvcm0oY2xhc3NOYW1lLnNsaWNlKDEpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DU1NDbGFzc1J1bGVzKHRleHQsIHRyYW5zZm9ybSkge1xuICBjb25zdCBzaGVldCA9IGNyZWF0ZUNTU1N0eWxlU2hlZXQodGV4dCk7XG4gIGNvbnN0IHJ1bGVzID0gc2hlZXQuY3NzUnVsZXM7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNTU1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlKSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IHRyYW5zZm9ybUNsYXNzU2VsZWN0b3JzKHJ1bGUuc2VsZWN0b3JUZXh0LCB0cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIGAke3NlbGVjdG9yfSB7ICR7cnVsZS5zdHlsZS5jc3NUZXh0fSB9YDtcbiAgICB9XG4gICAgY29uc3QgYXRSdWxlID0gQ09ORElUSU9OX1JVTEVfUkVHRVguZXhlYyhydWxlLmNzc1RleHQuc3BsaXQoXCJcXG5cIikuam9pbihcIlwiKSk7XG4gICAgaWYgKGF0UnVsZSAmJiBhdFJ1bGUubGVuZ3RoID4gMikge1xuICAgICAgY29uc3QgcnVsZTIgPSBhdFJ1bGVbMV07XG4gICAgICBjb25zdCBjb250ZW50cyA9IGF0UnVsZVsyXTtcbiAgICAgIHJldHVybiBgJHtydWxlMn0geyAke3RyYW5zZm9ybUNTU0NsYXNzUnVsZXMoY29udGVudHMsIHRyYW5zZm9ybSl9IH1gO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZS5jc3NUZXh0O1xuICB9XG4gIGxldCBzdHlsZSA9IFwiXCI7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBBcnJheS5mcm9tKHJ1bGVzKSkge1xuICAgIHN0eWxlICs9IHRyYW5zZm9ybUNTU1J1bGUocnVsZSkgKyBcIlxcblxcblwiO1xuICB9XG4gIHJldHVybiBzdHlsZS50cmltKCk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1ET01DbGFzc0F0dHJpYnV0ZXMoY29udGVudCwgdHJhbnNmb3JtKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbY2xhc3NdXCIpKTtcbiAgZWxlbWVudHMucHVzaChjb250ZW50KTtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGVsZW1lbnQ7XG4gICAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgQXJyYXkuZnJvbShjbGFzc0xpc3QpKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICBjbGFzc0xpc3QuYWRkKHRyYW5zZm9ybShjbGFzc05hbWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8vIHNyYy91dGlscy9pbmRleC50c1xuaW1wb3J0IHsgU2Vzc2lvblRva2VuIH0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcblxuLy8gc3JjL3V0aWxzL21hcC50c1xudmFyIEZMWV9UT19TUEVFRCA9IDEuNDtcbmZ1bmN0aW9uIGJib3hWaWV3cG9ydChtYXAsIGJvdW5kcywgZGVsdGEgPSAwLjUpIHtcbiAgY29uc3QgeyBjZW50ZXIsIHpvb20gfSA9IG1hcC5jYW1lcmFGb3JCb3VuZHMoYm91bmRzKTtcbiAgY29uc3QgdHJhbnNmb3JtZWRab29tID0gTWF0aC5tYXgoem9vbSAtIGRlbHRhLCAwKTtcbiAgcmV0dXJuIHtcbiAgICBjZW50ZXIsXG4gICAgem9vbTogdHJhbnNmb3JtZWRab29tLFxuICAgIHNwZWVkOiBGTFlfVE9fU1BFRURcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE1heFpvb20ocGxhY2VUeXBlKSB7XG4gIHN3aXRjaCAocGxhY2VUeXBlKSB7XG4gICAgY2FzZSBcInN0cmVldFwiOlxuICAgICAgcmV0dXJuIDE1O1xuICAgIGNhc2UgXCJuZWlnaGJvcmhvb2RcIjpcbiAgICBjYXNlIFwicG9zdGNvZGVcIjpcbiAgICBjYXNlIFwibG9jYWxpdHlcIjpcbiAgICBjYXNlIFwib2F6YVwiOlxuICAgICAgcmV0dXJuIDE0O1xuICAgIGNhc2UgXCJwbGFjZVwiOlxuICAgIGNhc2UgXCJjaXR5XCI6XG4gICAgICByZXR1cm4gMTM7XG4gICAgY2FzZSBcImRpc3RyaWN0XCI6XG4gICAgICByZXR1cm4gOTtcbiAgICBjYXNlIFwicmVnaW9uXCI6XG4gICAgY2FzZSBcInByZWZlY3R1cmVcIjpcbiAgICAgIHJldHVybiA2O1xuICAgIGNhc2UgXCJjb3VudHJ5XCI6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDE2O1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdGF0aWNCYXNlVXJsKHVzZXJuYW1lLCBzdHlsZUlkKSB7XG4gIHJldHVybiBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zdHlsZXMvdjEvJHt1c2VybmFtZX0vJHtzdHlsZUlkfS9zdGF0aWMvYDtcbn1cblxuLy8gc3JjL2ljb25zL2Nsb3NlLnN2Z1xudmFyIGNsb3NlX2RlZmF1bHQgPSAnPHN2ZyB2aWV3Qm94PVwiMCAwIDE4IDE4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0zLjggMy44YTEgMSAwIDAgMSAxLjQgMEw5IDcuNThsMy44LTMuOGExIDEgMCAxIDEgMS40IDEuNDJMMTAuNDIgOWwzLjggMy44YTEgMSAwIDAgMS0xLjQyIDEuNEw5IDEwLjQybC0zLjggMy44YTEgMSAwIDAgMS0xLjQtMS40Mkw3LjU4IDlsLTMuOC0zLjhhMSAxIDAgMCAxIDAtMS40WlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIi8+PC9zdmc+JztcblxuLy8gc3JjL2ljb25zL2xvYWRpbmcuc3ZnXG52YXIgbG9hZGluZ19kZWZhdWx0ID0gJzxzdmcgdmlld0JveD1cIjAgMCAxOCAxOFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBmaWxsPVwiIzMzM1wiIGQ9XCJNNC40IDQuNGwuOC44YzIuMS0yLjEgNS41LTIuMSA3LjYgMGwuOC0uOGMtMi41LTIuNS02LjctMi41LTkuMiAwelwiLz48cGF0aCBvcGFjaXR5PVwiLjFcIiBkPVwiTTEyLjggMTIuOWMtMi4xIDIuMS01LjUgMi4xLTcuNiAwLTIuMS0yLjEtMi4xLTUuNSAwLTcuN2wtLjgtLjhjLTIuNSAyLjUtMi41IDYuNyAwIDkuMnM2LjYgMi41IDkuMiAwIDIuNS02LjYgMC05LjJsLS44LjhjMi4yIDIuMSAyLjIgNS42IDAgNy43elwiLz48L3N2Zz4nO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgU1RBVElDX0JBU0VfVVJMX1NBVEVMTElURSA9IGdldFN0YXRpY0Jhc2VVcmwoXCJtYXBib3hcIiwgXCJzYXRlbGxpdGUtc3RyZWV0cy12MTFcIik7XG52YXIgQVVUT0ZJTExfU0tVX1RPS0VOX1BSRUZJWCA9IFwiMjBkMDFcIjtcbnZhciBNQVBCT1hfRE9NQUlOUyA9IFtcIm1hcGJveC5jb21cIiwgXCJtYXBib3guY25cIiwgXCJ0aWxlc3RyZWFtLm5ldFwiXTtcbnZhciBMSVNUQk9YX1RFTVBMQVRFID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiTWFwYm94U2VhcmNoXCI+XG4gICAgPGRpdiBjbGFzcz1cIkxhYmVsXCIgcm9sZT1cImxhYmVsXCIgYXJpYS1saXZlPVwicG9saXRlXCIgYXJpYS1hdG9taWM9XCJ0cnVlXCI+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIlJlc3VsdHNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJSZXN1bHRzTGlzdFwiIHJvbGU9XCJsaXN0Ym94XCI+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJSZXN1bHRzQXR0cmlidXRpb25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm1hcGJveC5jb20vc2VhcmNoLXNlcnZpY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIiB0YWJpbmRleD1cIi0xXCI+XG4gICAgICAgICAgUG93ZXJlZCBieSBNYXBib3hcbiAgICAgICAgPC9hPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIExJU1RCT1hfU1VHR0VTVElPTl9URU1QTEFURSA9IGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGBcbjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIlN1Z2dlc3Rpb25cIiByb2xlPVwib3B0aW9uXCIgdGFiaW5kZXg9XCItMVwiPlxuICAgIDxkaXYgY2xhc3M9XCJTdWdnZXN0aW9uSWNvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJTdWdnZXN0aW9uVGV4dFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIlN1Z2dlc3Rpb25OYW1lXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiU3VnZ2VzdGlvbkRlc2NcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuYCk7XG52YXIgU0VBUkNIQk9YX1RFTVBMQVRFID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiU2VhcmNoQm94XCI+XG4gICAgPGRpdiBjbGFzcz1cIlNlYXJjaEljb25cIj48L2Rpdj5cbiAgICA8aW5wdXQgY2xhc3M9XCJJbnB1dFwiIHR5cGU9XCJ0ZXh0XCIgLz5cbiAgICA8ZGl2IGNsYXNzPVwiQWN0aW9uSWNvblwiPlxuICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPVwiQ2xlYXJcIiBjbGFzcz1cIkNsZWFyQnRuXCI+JHtjbG9zZV9kZWZhdWx0fTwvYnV0dG9uPlxuICAgICAgPGRpdiBjbGFzcz1cIkxvYWRpbmdJY29uXCI+JHtsb2FkaW5nX2RlZmF1bHR9PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIEdFT0NPREVSX1RFTVBMQVRFID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiR2VvY29kZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiU2VhcmNoSWNvblwiPjwvZGl2PlxuICAgIDxpbnB1dCBjbGFzcz1cIklucHV0XCIgdHlwZT1cInRleHRcIiAvPlxuICAgIDxkaXYgY2xhc3M9XCJBY3Rpb25JY29uXCI+XG4gICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9XCJDbGVhclwiIGNsYXNzPVwiQ2xlYXJCdG5cIj4ke2Nsb3NlX2RlZmF1bHR9PC9idXR0b24+XG4gICAgICA8ZGl2IGNsYXNzPVwiTG9hZGluZ0ljb25cIj4ke2xvYWRpbmdfZGVmYXVsdH08L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuYCk7XG5cbi8vIHNyYy91dGlscy9pbmRleC50c1xuZnVuY3Rpb24gcmFuZG9tVmFsaWRJRCgpIHtcbiAgcmV0dXJuIGBtYnhgICsgbmV3IFNlc3Npb25Ub2tlbigpLmlkLnNsaWNlKDAsIDgpO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKU09OKGpzb24pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwRXF1YWxzKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgYUtleXMpIHtcbiAgICBpZiAoIWRlZXBFcXVhbHMoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcm91bmQobnVtLCBkZWNpbWFsUGxhY2VzKSB7XG4gIGNvbnN0IGZhY3Rvck9mVGVuID0gTWF0aC5wb3coMTAsIGRlY2ltYWxQbGFjZXMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBmYWN0b3JPZlRlbikgLyBmYWN0b3JPZlRlbjtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxTZXJ2ZXIoaG9zdG5hbWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oaG9zdG5hbWUubWF0Y2goL2xvY2FsaG9zdHxbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9fDo6MXxcXC5sb2NhbHxeJC9naSkpO1xufVxuZnVuY3Rpb24gaXNNYXBib3hEb21haW4oaG9zdG5hbWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oTUFQQk9YX0RPTUFJTlMuc29tZSgoZG9tYWluKSA9PiBob3N0bmFtZS5pbmNsdWRlcyhkb21haW4pKSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL0hUTUxTY29wZWRFbGVtZW50LnRzXG52YXIgX3NlZWQsIF90ZW1wbGF0ZVVzZXJTdHlsZUVsZW1lbnQsIF90cmFuc2Zvcm07XG52YXIgSFRNTFNjb3BlZEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NlZWQsIHJhbmRvbVZhbGlkSUQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90ZW1wbGF0ZVVzZXJTdHlsZUVsZW1lbnQsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90cmFuc2Zvcm0sIChjbGFzc05hbWUpID0+IHtcbiAgICAgIHJldHVybiBgJHtfX3ByaXZhdGVHZXQodGhpcywgX3NlZWQpfS0tJHtjbGFzc05hbWV9YDtcbiAgICB9KTtcbiAgfVxuICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlU3R5bGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlVXNlclN0eWxlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNsb25lZENhbGxiYWNrKG9sZFNlZWQsIG5ld1NlZWQpIHtcbiAgICBjb25zdCBzZWVkVHJhbnNmb3JtID0gKGNsYXNzTmFtZSkgPT4gY2xhc3NOYW1lLnJlcGxhY2Uob2xkU2VlZCwgbmV3U2VlZCk7XG4gICAgdHJhbnNmb3JtRE9NQ2xhc3NBdHRyaWJ1dGVzKHRoaXMsIHNlZWRUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVcIikpO1xuICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRyYW5zZm9ybUNsYXNzU2VsZWN0b3JzKHN0eWxlLnRleHRDb250ZW50LCBzZWVkVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlcy5sZW5ndGgpIHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGVtcGxhdGVVc2VyU3R5bGVFbGVtZW50LCBzdHlsZXNbc3R5bGVzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXNXaXRoSWQgPSBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChgW2lkXj1cIiR7b2xkU2VlZH1cIl1gKSk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzV2l0aElkKSB7XG4gICAgICBub2RlLmlkID0gbm9kZS5pZC5yZXBsYWNlKG9sZFNlZWQsIG5ld1NlZWQpO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IG9sZFNlZWQgPSB0aGlzLmRhdGFzZXQuc2VlZDtcbiAgICAgIGNvbnN0IG5ld1NlZWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX3NlZWQpO1xuICAgICAgaWYgKG9sZFNlZWQgJiYgb2xkU2VlZCAhPT0gbmV3U2VlZCkge1xuICAgICAgICB0aGlzLmNsb25lZENhbGxiYWNrKG9sZFNlZWQsIG5ld1NlZWQpO1xuICAgICAgICB0aGlzLmRhdGFzZXQuc2VlZCA9IG5ld1NlZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGF0YXNldC5zZWVkID0gX19wcml2YXRlR2V0KHRoaXMsIF9zZWVkKTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3QgdGVtcGxhdGVTdHlsZSA9IHRoaXMudGVtcGxhdGVTdHlsZTtcbiAgICBpZiAodGVtcGxhdGVTdHlsZSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRoaXMucHJlcGFyZUNTUyh0ZW1wbGF0ZVN0eWxlKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICBjb25zdCB1c2VyU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgaWYgKHRoaXMudGVtcGxhdGVVc2VyU3R5bGUpIHtcbiAgICAgIHVzZXJTdHlsZS50ZXh0Q29udGVudCA9IHRoaXMucHJlcGFyZUNTUyh0aGlzLnRlbXBsYXRlVXNlclN0eWxlKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRDaGlsZCh1c2VyU3R5bGUpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGVtcGxhdGVVc2VyU3R5bGVFbGVtZW50LCB1c2VyU3R5bGUpO1xuICB9XG4gIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgIHJldHVybiB0cmFuc2Zvcm1ET01DbGFzc0F0dHJpYnV0ZXMoZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSksIF9fcHJpdmF0ZUdldCh0aGlzLCBfdHJhbnNmb3JtKSk7XG4gIH1cbiAgcHJlcGFyZUNTUyhjc3MpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtQ1NTQ2xhc3NSdWxlcyhjc3MsIF9fcHJpdmF0ZUdldCh0aGlzLCBfdHJhbnNmb3JtKSk7XG4gIH1cbiAgdXBkYXRlVGVtcGxhdGVVc2VyU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfdGVtcGxhdGVVc2VyU3R5bGVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3RlbXBsYXRlVXNlclN0eWxlRWxlbWVudCkudGV4dENvbnRlbnQgPSB0aGlzLnByZXBhcmVDU1Moc3R5bGUpO1xuICB9XG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIHN1cGVyLnF1ZXJ5U2VsZWN0b3IodHJhbnNmb3JtQ2xhc3NTZWxlY3RvcnMoc2VsZWN0b3JzLCBfX3ByaXZhdGVHZXQodGhpcywgX3RyYW5zZm9ybSkpKTtcbiAgfVxuICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycykge1xuICAgIHJldHVybiBzdXBlci5xdWVyeVNlbGVjdG9yQWxsKHRyYW5zZm9ybUNsYXNzU2VsZWN0b3JzKHNlbGVjdG9ycywgX19wcml2YXRlR2V0KHRoaXMsIF90cmFuc2Zvcm0pKSk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHN1cGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59O1xuX3NlZWQgPSBuZXcgV2Vha01hcCgpO1xuX3RlbXBsYXRlVXNlclN0eWxlRWxlbWVudCA9IG5ldyBXZWFrTWFwKCk7XG5fdHJhbnNmb3JtID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gc3JjL2ljb25zL3F1ZXN0aW9uLnN2Z1xudmFyIHF1ZXN0aW9uX2RlZmF1bHQgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/Pjxzdmcgdmlld0JveD1cIjAgMCAxOCAxOFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNOSAxNkE3IDcgMCAxIDAgOSAyYTcgNyAwIDAgMCAwIDE0Wk02Ljg4IDQuODhhMi41OCAyLjU4IDAgMCAxIDEuODMtLjc1aDEuMDhhMi41OCAyLjU4IDAgMCAxIDIuNTkgMi41OHYuMTZjMCAxLS41MyAxLjk0LTEuNCAyLjQ2bC0uNTYuMzRjLS4yNy4xNi0uNDUuNDItLjUyLjcxLS4wMy4xNC0uMTQuMjUtLjI4LjI1SDguMzhhLjIzLjIzIDAgMCAxLS4yNC0uMjVjLjA4LS45MS41OS0xLjc0IDEuMzgtMi4yMWwuNTYtLjM0Yy4zNC0uMi41NC0uNTcuNTQtLjk2VjYuN2EuODMuODMgMCAwIDAtLjgzLS44M0g4LjcxYS44My44MyAwIDAgMC0uODQuODN2LjE4YS44Ny44NyAwIDEgMS0xLjc1IDBWNi43YzAtLjY5LjI4LTEuMzQuNzYtMS44M1pNMTAgMTNhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIi8+PC9zdmc+JztcblxuLy8gc3JjL2ljb25zL21hcmtlci5zdmdcbnZhciBtYXJrZXJfZGVmYXVsdCA9ICc8c3ZnIHdpZHRoPVwiNDhcIiBoZWlnaHQ9XCI1NlwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxnIGZpbHRlcj1cInVybCgjYSlcIj48cGF0aCBkPVwibTI0IDUwLjQgMTMuNzktMTQuMTJhMTguODIgMTguODIgMCAwIDAgNC4yMy0yMC44NiAxOS4yMyAxOS4yMyAwIDAgMC03LjE5LTguNiAxOS43NiAxOS43NiAwIDAgMC0yMS42NiAwYy0zLjIxIDIuMTEtNS43MSA1LjEtNy4xOSA4LjZhMTguODIgMTguODIgMCAwIDAgNC4yMyAyMC44NkwyNCA1MC40WlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIi8+PHBhdGggZD1cIk0zNy4yNiAzNS43NSAyNCA0OS4zNCAxMC43NSAzNS43NmwtLjAxLS4wMUExOC4wNyAxOC4wNyAwIDAgMSA2LjY4IDE1LjdhMTguNDggMTguNDggMCAwIDEgNi45LTguMjYgMTkgMTkgMCAwIDEgMjAuODQgMCAxOC40OCAxOC40OCAwIDAgMSA2LjkgOC4yNiAxOC4wNyAxOC4wNyAwIDAgMS00LjA2IDIwLjA0WlwiIHN0cm9rZT1cIiNmZmZcIiBzdHJva2Utd2lkdGg9XCIxLjVcIi8+PC9nPjxjaXJjbGUgY3g9XCIyNFwiIGN5PVwiMjIuNDVcIiBmaWxsPVwiI2ZmZlwiIHI9XCI1Ljg1XCIvPjxkZWZzPjxmaWx0ZXIgaWQ9XCJhXCIgeD1cIi41XCIgeT1cIi42XCIgd2lkdGg9XCI0N1wiIGhlaWdodD1cIjU0LjhcIiBmaWx0ZXJVbml0cz1cInVzZXJTcGFjZU9uVXNlXCIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPVwic1JHQlwiPjxmZUZsb29kIGZsb29kLW9wYWNpdHk9XCIwXCIgcmVzdWx0PVwiQmFja2dyb3VuZEltYWdlRml4XCIvPjxmZUNvbG9yTWF0cml4IGluPVwiU291cmNlQWxwaGFcIiB2YWx1ZXM9XCIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMFwiIHJlc3VsdD1cImhhcmRBbHBoYVwiLz48ZmVPZmZzZXQgZHk9XCIxXCIvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCIyXCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz1cIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMiAwXCIvPjxmZUJsZW5kIGluMj1cIkJhY2tncm91bmRJbWFnZUZpeFwiIHJlc3VsdD1cImVmZmVjdDFfZHJvcFNoYWRvd18xN184NzFcIi8+PGZlQmxlbmQgaW49XCJTb3VyY2VHcmFwaGljXCIgaW4yPVwiZWZmZWN0MV9kcm9wU2hhZG93XzE3Xzg3MVwiIHJlc3VsdD1cInNoYXBlXCIvPjwvZmlsdGVyPjwvZGVmcz48L3N2Zz4nO1xuXG4vLyBzcmMvaWNvbnMvc3RyZWV0LnN2Z1xudmFyIHN0cmVldF9kZWZhdWx0ID0gJzxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAxOCAxOFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxcbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEuMDggMTQuOTQgNS42MjUgMy4wNmgxLjE3bC0zLjQyIDExLjg4SDEuMDhabTE1Ljg4NSAwTDEyLjQyIDMuMDZoLTEuMTdsMy40MiAxMS44OGgyLjI5NVptLTYuODYtMS40NEg3Ljk0NmwuMTI4LTIuNjFoMS45MTJsLjExOSAyLjYxWm0tLjIxNy00Ljc3SDguMTgxbC4wODgtMS44aDEuNTM3bC4wODIgMS44Wk05Ljc0IDUuNDloLTEuNGwuMDQ5LS45OWgxLjMwNmwuMDQ1Ljk5WlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiAvPlxcbjwvc3ZnPic7XG5cbi8vIHNyYy9pY29ucy9hZGRyZXNzTWFya2VyLnN2Z1xudmFyIGFkZHJlc3NNYXJrZXJfZGVmYXVsdCA9IGA8IS0tIFRPRE86IEknbSBub3Qgc3VyZSBpZiB0aGUgd2F5IEkgYWRkZWQgdGhlIGNpcmNsZSB3aWxsIFwic2NhbGVcIiBwcm9wZXJseSwgbmVlZCB0byBjaGVjayB0aGF0IC0tPlxuPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDE4IDE4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIGQ9XCJNNCA3YTUgNSAwIDEgMSAxMCAwYzAgMy4wMjUtMy4yOCA2LjcxMy01IDktMS43Mi0yLjI4Ny01LTUuOTc1LTUtOXpcIj48L3BhdGg+XG4gICAgPGNpcmNsZSBjeD1cIjlcIiBjeT1cIjdcIiByPVwiMlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj48L2NpcmNsZT5cbjwvc3ZnPmA7XG5cbi8vIHNyYy9pY29ucy9zZWFyY2guc3ZnXG52YXIgc2VhcmNoX2RlZmF1bHQgPSAnPHN2ZyB2aWV3Qm94PVwiMCAwIDE4IDE4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxcbiAgPHBhdGggZD1cIk03LjQgMi41Yy0yLjcgMC00LjkgMi4yLTQuOSA0LjlzMi4yIDQuOSA0LjkgNC45YzEgMCAxLjgtLjIgMi41LS44bDMuNyAzLjdjLjIuMi40LjMuOC4zLjcgMCAxLjEtLjQgMS4xLTEuMSAwLS4zLS4xLS41LS4zLS44TDExLjQgMTBjLjQtLjguOC0xLjYuOC0yLjUuMS0yLjgtMi4xLTUtNC44LTV6bTAgMS42YzEuOCAwIDMuMiAxLjQgMy4yIDMuMnMtMS40IDMuMi0zLjIgMy4yLTMuMy0xLjMtMy4zLTMuMSAxLjQtMy4zIDMuMy0zLjN6XCIvPlxcbjwvc3ZnPic7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjEuMC4wLWJldGEuMjFcIjtcblxuLy8gc3JjL3RoZW1lLnRzXG52YXIgc3R5bGVUb2dnbGVTYXRlbGxpdGVJbWcgPSBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zZWFyY2gtanMvdiR7dmVyc2lvbn0vaW1nL3N0eWxlLXRvZ2dsZS1zYXRlbGxpdGUuanBnYDtcbnZhciBzdHlsZVRvZ2dsZURlZmF1bHRJbWcgPSBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zZWFyY2gtanMvdiR7dmVyc2lvbn0vaW1nL3N0eWxlLXRvZ2dsZS1kZWZhdWx0LmpwZ2A7XG52YXIgTU9CSUxFX0JSRUFLUE9JTlQgPSA3NjggLSAxO1xudmFyIE1PQklMRV9NRURJQV9RVUVSWSA9IGBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICR7TU9CSUxFX0JSRUFLUE9JTlR9cHgpYDtcbnZhciBERUZBVUxUX1RIRU1FID0ge1xuICB2YXJpYWJsZXM6IHtcbiAgICB1bml0OiBbXCJtb2JpbGVcIiwgXCIxNnB4XCIsIFwiMTRweFwiXSxcbiAgICB1bml0SGVhZGVyOiBbXCJtb2JpbGVcIiwgXCIyNHB4XCIsIFwiMThweFwiXSxcbiAgICBtaW5XaWR0aDogXCJtaW4oMzAwcHgsIDEwMHZ3KVwiLFxuICAgIHNwYWNpbmc6IFwiMC43NWVtXCIsXG4gICAgcGFkZGluZzogXCIwLjVlbSAwLjc1ZW1cIixcbiAgICBwYWRkaW5nRm9vdGVyTGFiZWw6IFwiMC41ZW0gMC43NWVtXCIsXG4gICAgcGFkZGluZ01vZGFsOiBcIjEuMjVlbVwiLFxuICAgIGNvbG9yVGV4dDogXCJyZ2JhKDAsIDAsIDAsIDAuNzUpXCIsXG4gICAgY29sb3JQcmltYXJ5OiBcIiM0MjY0RkJcIixcbiAgICBjb2xvclNlY29uZGFyeTogXCIjNjY3RjkxXCIsXG4gICAgY29sb3JCYWNrZ3JvdW5kOiBcIiNmZmZcIixcbiAgICBjb2xvckJhY2tncm91bmRIb3ZlcjogXCIjZjVmNWY1XCIsXG4gICAgY29sb3JCYWNrZ3JvdW5kQWN0aXZlOiBcIiNmMGYwZjBcIixcbiAgICBjb2xvckJhY2tkcm9wOiBcInJnYmEoMTAyLCAxMjcsIDE0NSwgMC4zKVwiLFxuICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxuICAgIGJveFNoYWRvdzogYFxuICAgICAgMCAwIDEwcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4wNSksXG4gICAgICAwIDAgNnB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMSksXG4gICAgICAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpXG4gICAgYCxcbiAgICBsaW5lSGVpZ2h0OiBcIjEuMmVtXCIsXG4gICAgZm9udEZhbWlseTogYFxuICAgICAgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LFxuICAgICAgYXZlbmlyIG5leHQsIGF2ZW5pcixcbiAgICAgIHNlZ29lIHVpLFxuICAgICAgaGVsdmV0aWNhIG5ldWUsIGhlbHZldGljYSxcbiAgICAgIFVidW50dSwgcm9ib3RvLCBub3RvLCBhcmlhbCwgc2Fucy1zZXJpZlxuICAgIGAsXG4gICAgZm9udFdlaWdodDogXCJub3JtYWxcIixcbiAgICBmb250V2VpZ2h0U2VtaWJvbGQ6IFwiNjAwXCIsXG4gICAgZm9udFdlaWdodEJvbGQ6IFwiYm9sZFwiLFxuICAgIGR1cmF0aW9uOiBcIjE1MG1zXCIsXG4gICAgY3VydmU6IFwiZWFzZS1vdXRcIlxuICB9LFxuICBpY29uczoge1xuICAgIGNsb3NlOiBjbG9zZV9kZWZhdWx0LFxuICAgIHF1ZXN0aW9uOiBxdWVzdGlvbl9kZWZhdWx0LFxuICAgIG1hcmtlcjogbWFya2VyX2RlZmF1bHQsXG4gICAgc3RyZWV0OiBzdHJlZXRfZGVmYXVsdCxcbiAgICBhZGRyZXNzTWFya2VyOiBhZGRyZXNzTWFya2VyX2RlZmF1bHQsXG4gICAgc2VhcmNoOiBzZWFyY2hfZGVmYXVsdFxuICB9LFxuICBpbWFnZXM6IHtcbiAgICBzdHlsZVRvZ2dsZURlZmF1bHQ6IHN0eWxlVG9nZ2xlRGVmYXVsdEltZyxcbiAgICBzdHlsZVRvZ2dsZVNhdGVsbGl0ZTogc3R5bGVUb2dnbGVTYXRlbGxpdGVJbWdcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFRoZW1lQ1NTKHJvb3RTZWxlY3RvciwgdGhlbWUgPSB7fSkge1xuICBjb25zdCB2YXJpYWJsZXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgREVGQVVMVF9USEVNRS52YXJpYWJsZXMpLCB0aGVtZS52YXJpYWJsZXMgfHwge30pO1xuICBsZXQgY3NzVGV4dCA9IHRoZW1lLmNzc1RleHQgfHwgXCJcIjtcbiAgbGV0IHJvb3RWYXJpYWJsZXMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YXJpYWJsZXMpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcm9vdFZhcmlhYmxlcyArPSBgLS0ke2tleX06ICR7dmFsdWV9O2A7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlWzBdICE9PSBcIm1vYmlsZVwiKSB7XG4gICAgICBjb25zdCB2YWx1ZVN0ciA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZXhwcmVzc2lvbiBpbiB0aGVtZSB2YXJpYWJsZXM6ICR7a2V5fSAke3ZhbHVlU3RyfWApO1xuICAgIH1cbiAgICBjb25zdCBbLCBtb2JpbGVWYWx1ZSwgZGVza3RvcFZhbHVlXSA9IHZhbHVlO1xuICAgIGNzc1RleHQgKz0gYCR7TU9CSUxFX01FRElBX1FVRVJZfSB7ICR7cm9vdFNlbGVjdG9yfSB7IC0tJHtrZXl9OiAke21vYmlsZVZhbHVlfSAhaW1wb3J0YW50OyB9IH1gO1xuICAgIHJvb3RWYXJpYWJsZXMgKz0gYC0tJHtrZXl9OiAke2Rlc2t0b3BWYWx1ZX07YDtcbiAgfVxuICByZXR1cm4gY3NzVGV4dCArIGAke3Jvb3RTZWxlY3Rvcn0geyAke3Jvb3RWYXJpYWJsZXN9IH1gO1xufVxuZnVuY3Rpb24gZ2V0SWNvbihpY29uTmFtZSwgdGhlbWUgPSB7fSkge1xuICBjb25zdCBpY29ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBERUZBVUxUX1RIRU1FLmljb25zKSwgdGhlbWUuaWNvbnMgfHwge30pO1xuICBjb25zdCBzdmdTdHJpbmcgPSBpY29uc1tpY29uTmFtZV07XG4gIHJldHVybiBzdmdTdHJpbmc7XG59XG5mdW5jdGlvbiBnZXRJbWFnZShpbWFnZU5hbWUsIHRoZW1lID0ge30pIHtcbiAgY29uc3QgaW1hZ2VzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIERFRkFVTFRfVEhFTUUuaW1hZ2VzKSwgdGhlbWUuaW1hZ2VzIHx8IHt9KTtcbiAgY29uc3QgaW1nU3RyaW5nID0gaW1hZ2VzW2ltYWdlTmFtZV07XG4gIHJldHVybiBpbWdTdHJpbmc7XG59XG5cbi8vIHNyYy91dGlscy9wb3BvdmVyLnRzXG5pbXBvcnQge1xuICBjb21wdXRlUG9zaXRpb24sXG4gIGF1dG9VcGRhdGUsXG4gIGZsaXAsXG4gIG9mZnNldFxufSBmcm9tIFwiQGZsb2F0aW5nLXVpL2RvbVwiO1xudmFyIF9vcHRpb25zLCBfZGVmYXVsdE9wdGlvbnM7XG52YXIgUG9wb3ZlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIG9wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29wdGlvbnMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9kZWZhdWx0T3B0aW9ucywge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgZmxpcDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IDEwXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUgPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjb25maWcyID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgICBvZmZzZXQodGhpcy5vcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZsaXAgJiYgZmxpcCgpXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pXG4gICAgICB9O1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSB5aWVsZCBjb21wdXRlUG9zaXRpb24odGhpcy5yZWZlcmVuY2VFbCwgdGhpcy5mbG9hdGluZ0VsLCBjb25maWcyKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5mbG9hdGluZ0VsLnN0eWxlLCB7XG4gICAgICAgIGxlZnQ6IGAke3h9cHhgLFxuICAgICAgICB0b3A6IGAke3l9cHhgXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZmVyZW5jZUVsID0gcmVmZXJlbmNlRWw7XG4gICAgdGhpcy5mbG9hdGluZ0VsID0gZmxvYXRpbmdFbDtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29wdGlvbnMsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVHZXQodGhpcywgX2RlZmF1bHRPcHRpb25zKSksIG9wdGlvbnMpKTtcbiAgICB0aGlzLmRlc3Ryb3kgPSBhdXRvVXBkYXRlKHRoaXMucmVmZXJlbmNlRWwsIHRoaXMuZmxvYXRpbmdFbCwgdGhpcy51cGRhdGUpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX29wdGlvbnMpO1xuICB9XG4gIHNldCBvcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29wdGlvbnMsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVHZXQodGhpcywgX29wdGlvbnMpKSwgbmV3T3B0aW9ucykpO1xuICB9XG59O1xuX29wdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuX2RlZmF1bHRPcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gc3JjL3N0eWxlLmNzc1xudmFyIHN0eWxlX2RlZmF1bHQgPSBcIip7Ym94LXNpemluZzpib3JkZXItYm94IWltcG9ydGFudH1bcm9sZT1idXR0b25de2N1cnNvcjpwb2ludGVyfS5NYXBib3hTZWFyY2h7LS13aWR0aDowO2Rpc3BsYXk6bm9uZX0uUmVzdWx0c3tiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yQmFja2dyb3VuZCk7Ym9yZGVyOnZhcigtLWJvcmRlcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXJSYWRpdXMpO2JveC1zaGFkb3c6dmFyKC0tYm94U2hhZG93KTtjb2xvcjp2YXIoLS1jb2xvclRleHQpO2ZvbnQtZmFtaWx5OnZhcigtLWZvbnRGYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS11bml0KTtmb250LXdlaWdodDp2YXIoLS1mb250V2VpZ2h0KTtsaW5lLWhlaWdodDp2YXIoLS1saW5lSGVpZ2h0KTttaW4td2lkdGg6dmFyKC0tbWluV2lkdGgpO292ZXJmbG93LXk6YXV0bztwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2l0aW9uOnZpc2liaWxpdHkgdmFyKC0tZHVyYXRpb24pO3dpZHRoOnZhcigtLXdpZHRoKTt6LWluZGV4OjEwMDB9LlJlc3VsdHM6bm90KFthcmlhLWhpZGRlbj10cnVlXSl7dmlzaWJpbGl0eTp2aXNpYmxlfS5SZXN1bHRzW2FyaWEtaGlkZGVuPXRydWVde2FuaW1hdGlvbjpmYWRlaW4gdmFyKC0tZHVyYXRpb24pIHZhcigtLWN1cnZlKSByZXZlcnNlIGZvcndhcmRzO3Zpc2liaWxpdHk6aGlkZGVufS5TdWdnZXN0aW9ue2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7cGFkZGluZzp2YXIoLS1wYWRkaW5nKX0uU3VnZ2VzdGlvbjpob3ZlcntjdXJzb3I6cG9pbnRlcn0uU3VnZ2VzdGlvblthcmlhLXNlbGVjdGVkPXRydWVde2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3JCYWNrZ3JvdW5kSG92ZXIpfS5TdWdnZXN0aW9uOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yQmFja2dyb3VuZEFjdGl2ZSl9LlN1Z2dlc3Rpb25OYW1le2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnRXZWlnaHRCb2xkKX0uU3VnZ2VzdGlvbkljb257bWFyZ2luLXJpZ2h0OjZweH0uU3VnZ2VzdGlvbkljb25bYXJpYS1oaWRkZW49dHJ1ZV17ZGlzcGxheTpub25lfS5SZXN1bHRzQXR0cmlidXRpb257cGFkZGluZzp2YXIoLS1wYWRkaW5nRm9vdGVyTGFiZWwpfS5SZXN1bHRzQXR0cmlidXRpb24gYXtjb2xvcjp2YXIoLS1jb2xvclNlY29uZGFyeSl9LlJlc3VsdHNBdHRyaWJ1dGlvbiBhOm5vdCg6aG92ZXIpe3RleHQtZGVjb3JhdGlvbjpub25lfS5SZXN1bHRzTGlzdHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowfS5MYWJlbHtkaXNwbGF5Om5vbmV9Lkdlb2NvZGVyLC5TZWFyY2hCb3h7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvckJhY2tncm91bmQpO2JvcmRlcjp2YXIoLS1ib3JkZXIpO2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyUmFkaXVzKTtib3gtc2hhZG93OnZhcigtLWJveFNoYWRvdyk7Y29sb3I6dmFyKC0tY29sb3JUZXh0KTtmb250LWZhbWlseTp2YXIoLS1mb250RmFtaWx5KTtmb250LXNpemU6dmFyKC0tdW5pdCk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udFdlaWdodCk7bGluZS1oZWlnaHQ6dmFyKC0tbGluZUhlaWdodCk7cGFkZGluZzp2YXIoLS1wYWRkaW5nKTtwYWRkaW5nLWJvdHRvbTowO3BhZGRpbmctdG9wOjA7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJX0uU2VhcmNoSWNvbntmaWxsOiM3NTc1NzU7bGVmdDouNWVtfS5BY3Rpb25JY29uLC5TZWFyY2hJY29ue2JvdHRvbTowO2hlaWdodDoyMHB4O21hcmdpbjphdXRvIDA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6MjBweH0uQWN0aW9uSWNvbntyaWdodDouNWVtfS5BY3Rpb25JY29uPmJ1dHRvbntiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7Y29sb3I6aW5oZXJpdDtjdXJzb3I6cG9pbnRlcjtmb250OmluaGVyaXQ7aGVpZ2h0OjEwMCU7b3V0bGluZTppbmhlcml0O3BhZGRpbmc6MDt3aWR0aDoxMDAlfS5BY3Rpb25JY29uPmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOm5vbmUhaW1wb3J0YW50fS5DbGVhckJ0bntkaXNwbGF5Om5vbmV9LkNsZWFyQnRuOmhvdmVye2NvbG9yOiM5MDkwOTB9LkxvYWRpbmdJY29uey1tb3otYW5pbWF0aW9uOnJvdGF0ZSAuOHMgY3ViaWMtYmV6aWVyKC40NSwuMDUsLjU1LC45NSkgaW5maW5pdGU7LXdlYmtpdC1hbmltYXRpb246cm90YXRlIC44cyBjdWJpYy1iZXppZXIoLjQ1LC4wNSwuNTUsLjk1KSBpbmZpbml0ZTthbmltYXRpb246cm90YXRlIC44cyBjdWJpYy1iZXppZXIoLjQ1LC4wNSwuNTUsLjk1KSBpbmZpbml0ZTtkaXNwbGF5Om5vbmU7aGVpZ2h0OjEwMCV9QC13ZWJraXQta2V5ZnJhbWVzIHJvdGF0ZXswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMCk7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMXR1cm4pO3RyYW5zZm9ybTpyb3RhdGUoMXR1cm4pfX1Aa2V5ZnJhbWVzIHJvdGF0ZXswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMCk7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMXR1cm4pO3RyYW5zZm9ybTpyb3RhdGUoMXR1cm4pfX0uSW5wdXR7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MDtjb2xvcjojNDA0MDQwO2NvbG9yOnJnYmEoMCwwLDAsLjc1KTtmb250OmluaGVyaXQ7aGVpZ2h0OjM2cHg7bWFyZ2luOjA7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCA0MHB4O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO3dpZHRoOjEwMCV9LklucHV0OjotbXMtY2xlYXJ7ZGlzcGxheTpub25lfS5JbnB1dDpmb2N1c3tib3JkZXI6dGhpbiBkb3R0ZWQ7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXJSYWRpdXMpO2JveC1zaGFkb3c6bm9uZTtjb2xvcjojNDA0MDQwO2NvbG9yOnJnYmEoMCwwLDAsLjc1KTtvdXRsaW5lOjB9bWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uLWZlYXR1cmVbYXJpYS1oaWRkZW49dHJ1ZV0sbWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uLW5vLWZlYXR1cmVbYXJpYS1oaWRkZW49dHJ1ZV17ZGlzcGxheTpub25lfS5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9ue2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yQmFja2Ryb3ApO2JvdHRvbTowO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2xlZnQ6MDtwb3NpdGlvbjpmaXhlZDtyaWdodDowO3RvcDowO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3otaW5kZXg6MTAwMH0uTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjpub3QoW2FyaWEtaGlkZGVuPXRydWVdKXthbmltYXRpb246ZmFkZWluIHZhcigtLWR1cmF0aW9uKSB2YXIoLS1jdXJ2ZSkgZm9yd2FyZHM7dmlzaWJpbGl0eTp2aXNpYmxlfS5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uW2FyaWEtaGlkZGVuPXRydWVde3Zpc2liaWxpdHk6aGlkZGVufS5Db250ZW50RmVhdHVyZSwuQ29udGVudE5vRmVhdHVyZXt3aWR0aDp2YXIoLS1taW5XaWR0aCl9Lk1vZGFse2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3JCYWNrZ3JvdW5kKTtib3JkZXI6dmFyKC0tYm9yZGVyKTtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlclJhZGl1cyk7Ym94LXNoYWRvdzp2YXIoLS1ib3hTaGFkb3cpO2NvbG9yOnZhcigtLWNvbG9yVGV4dCk7Zm9udC1mYW1pbHk6dmFyKC0tZm9udEZhbWlseSk7Zm9udC1zaXplOnZhcigtLXVuaXQpO2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnRXZWlnaHQpO2xpbmUtaGVpZ2h0OnZhcigtLWxpbmVIZWlnaHQpO3BhZGRpbmc6dmFyKC0tcGFkZGluZ01vZGFsKTt3aWR0aDoxMDAlfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6NDgwcHgpey5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9ue2FsaWduLWl0ZW1zOmZsZXgtZW5kfS5Db250ZW50RmVhdHVyZSwuQ29udGVudE5vRmVhdHVyZXt3aWR0aDoxMDAlfS5Nb2RhbHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MH19Lk1vZGFsSGVhZGVye2FsaWduLWl0ZW1zOmNlbnRlcjtjb2xvcjp2YXIoLS1jb2xvclByaW1hcnkpO2Rpc3BsYXk6ZmxleDtmb250LXNpemU6dmFyKC0tdW5pdEhlYWRlcik7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udFdlaWdodEJvbGQpO21hcmdpbi1ib3R0b206dmFyKC0tc3BhY2luZyk7dXNlci1zZWxlY3Q6bm9uZTt3aWR0aDoxMDAlfS5Nb2RhbE1hcHtoZWlnaHQ6Y2FsYyh2YXIoLS1taW5XaWR0aCkqOS8xNik7bWFyZ2luLWxlZnQ6Y2FsYyh2YXIoLS1wYWRkaW5nTW9kYWwpKi0xKTt3aWR0aDpjYWxjKDEwMCUgKyB2YXIoLS1wYWRkaW5nTW9kYWwpKjIpfS5Nb2RhbE1hcFthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9Lkljb257aGVpZ2h0OnZhcigtLXVuaXRIZWFkZXIpO3dpZHRoOnZhcigtLXVuaXRIZWFkZXIpfS5JY29uLkljb25DbG9zZXtjb2xvcjp2YXIoLS1jb2xvclNlY29uZGFyeSl9Lk1vZGFsSGVhZGVyVGl0bGV7ZmxleDoxO21hcmdpbi1sZWZ0Oi4yNWVtfS5Nb2RhbEZvb3Rlcntjb2xvcjp2YXIoLS1jb2xvclNlY29uZGFyeSk7bWFyZ2luLXRvcDp2YXIoLS1zcGFjaW5nKTt0ZXh0LWFsaWduOmNlbnRlcn0uTW9kYWxGb290ZXJbYXJpYS1oaWRkZW49dHJ1ZV17ZGlzcGxheTpub25lfS5Nb2RhbFN1YmhlYWRlcntmb250LXdlaWdodDp2YXIoLS1mb250V2VpZ2h0Qm9sZCk7dXNlci1zZWxlY3Q6bm9uZX0uTW9kYWxEZXNjcmlwdGlvbntjb2xvcjp2YXIoLS1jb2xvclByaW1hcnkpfS5Nb2RhbEFkZHJlc3MsLk1vZGFsU3ViaGVhZGVye21hcmdpbi1ib3R0b206dmFyKC0tc3BhY2luZyl9Lk1vZGFsQWRkcmVzcy5Nb2RhbEFkZHJlc3NBcHByb3Zle2NvbG9yOnZhcigtLWNvbG9yUHJpbWFyeSl9LkJ1dHRvbntib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlclJhZGl1cyk7Y3Vyc29yOnBvaW50ZXI7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udFdlaWdodFNlbWlib2xkKTttYXJnaW4tdG9wOnZhcigtLXNwYWNpbmcpO3BhZGRpbmc6dmFyKC0tcGFkZGluZyk7dGV4dC1hbGlnbjpjZW50ZXI7dXNlci1zZWxlY3Q6bm9uZTt3aWR0aDoxMDAlfS5CdXR0b25bYXJpYS1oaWRkZW49dHJ1ZV17ZGlzcGxheTpub25lfS5CdXR0b24uQnV0dG9uUHJpbWFyeXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yUHJpbWFyeSk7Y29sb3I6dmFyKC0tY29sb3JCYWNrZ3JvdW5kKX0uQnV0dG9uLkJ1dHRvblNlY29uZGFyeXtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNvbG9yU2Vjb25kYXJ5KTtjb2xvcjp2YXIoLS1jb2xvclNlY29uZGFyeSl9QGtleWZyYW1lcyBmYWRlaW57MCV7b3BhY2l0eTowfXRve29wYWNpdHk6MX19Lk1hcGJveEFkZHJlc3NNaW5pbWFwe2ZvbnQtZmFtaWx5OnZhcigtLWZvbnRGYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS11bml0KTtmb250LXdlaWdodDp2YXIoLS1mb250V2VpZ2h0KTtsaW5lLWhlaWdodDp2YXIoLS1saW5lSGVpZ2h0KX0uTWFwYm94QWRkcmVzc01pbmltYXBbYXJpYS1oaWRkZW49dHJ1ZV17ZGlzcGxheTpub25lfS5NaW5pbWFwSW1hZ2VDb250YWluZXJ7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXJSYWRpdXMpO292ZXJmbG93OmhpZGRlbn0uTWluaW1hcEltYWdle2hlaWdodDp1bnNldDttYXgtaGVpZ2h0OnVuc2V0O21heC13aWR0aDp1bnNldDtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDp1bnNldH0uTWluaW1hcElubmVyRnJhbWV7Ym9yZGVyOnZhcigtLWJvcmRlcik7Ym9yZGVyLXJhZGl1czppbmhlcml0O2hlaWdodDppbmhlcml0O2xlZnQ6MDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6aW5oZXJpdH0uTWluaW1hcE1hcmtlcntsZWZ0OjUwJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlfS5NaW5pbWFwTWFya2VyPnN2Z3tjb2xvcjp2YXIoLS1jb2xvclByaW1hcnkpO2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5NaW5pbWFwQXR0cmlidXRpb25Mb2dve2JvdHRvbTowO2xlZnQ6MDttYXJnaW46MCAwIDZweCA2cHg7cG9zaXRpb246YWJzb2x1dGV9Lk1pbmltYXBBdHRyaWJ1dGlvbkxvZ28gYXtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmJsb2NrO2hlaWdodDoyM3B4O3dpZHRoOjg4cHh9Lk1pbmltYXBBdHRyaWJ1dGlvblRleHR7YmFja2dyb3VuZC1jb2xvcjpoc2xhKDAsMCUsMTAwJSwuNjUpO2JvdHRvbTowO2ZvbnQ6MTFweC8xNnB4IEhlbHZldGljYSBOZXVlLEFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmO3BhZGRpbmc6MCA1cHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uTWluaW1hcEF0dHJpYnV0aW9uVGV4dCBhe2NvbG9yOnJnYmEoMCwwLDAsLjc1KTt0ZXh0LWRlY29yYXRpb246bm9uZX0uTWluaW1hcEF0dHJpYnV0aW9uVGV4dCBhOmhvdmVye2NvbG9yOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX0uTWluaW1hcEF0dHJpYnV0aW9uVGV4dCBhOm5vdCg6Zmlyc3QtY2hpbGQpe21hcmdpbi1sZWZ0OjNweH0uTWluaW1hcFN0eWxlVG9nZ2xle2JhY2tncm91bmQtcG9zaXRpb246MDtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47Ym9yZGVyOjJweCBzb2xpZCAjZmZmO2JvcmRlci1yYWRpdXM6M3B4O2JveC1zaGFkb3c6dmFyKC0tYm94U2hhZG93KTtjdXJzb3I6cG9pbnRlcjtoZWlnaHQ6MmVtO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OnZhcigtLXNwYWNpbmcpO3RvcDp2YXIoLS1zcGFjaW5nKTt3aWR0aDoyZW19Lk1pbmltYXBGb290ZXJ7Y29sb3I6dmFyKC0tY29sb3JTZWNvbmRhcnkpO2ZvbnQtZmFtaWx5OnZhcigtLWZvbnRGYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS11bml0KTttYXJnaW4tdG9wOnZhcigtLXNwYWNpbmcpfS5NaW5pbWFwRm9vdGVyW2FyaWEtaGlkZGVuPXRydWVde2Rpc3BsYXk6bm9uZX0uTWluaW1hcEVkaXRCdXR0b25ze2JvdHRvbToyNnB4O2Rpc3BsYXk6ZmxleDtmb250LWZhbWlseTp2YXIoLS1mb250RmFtaWx5KTtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDp2YXIoLS1zcGFjaW5nKX0uTWluaW1hcEVkaXRCdXR0b25zIC5CdXR0b257Ym94LXNoYWRvdzp2YXIoLS1ib3hTaGFkb3cpfS5NaW5pbWFwQnV0dG9uQ2FuY2Vse2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3JCYWNrZ3JvdW5kKTttYXJnaW4tbGVmdDp2YXIoLS1zcGFjaW5nKX0uZHJhZ2dhYmxle2N1cnNvcjptb3ZlO2N1cnNvcjpncmFifS5kcmFnZ2FibGU6YWN0aXZle2N1cnNvcjpncmFiYmluZ31cIjtcblxuLy8gc3JjL01hcGJveEhUTUxFdmVudC50c1xudmFyIE1hcGJveEhUTUxFdmVudCA9IGNsYXNzIGV4dGVuZHMgQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBkZXRhaWwpIHtcbiAgICBzdXBlcih0eXBlLCB7XG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGRldGFpbFxuICAgIH0pO1xuICB9XG4gIGNsb25lKG5ld1RhcmdldCkge1xuICAgIGNvbnN0IGV2ZW50Q2xvbmUgPSBuZXcgTWFwYm94SFRNTEV2ZW50KHRoaXMudHlwZSwgdGhpcy5kZXRhaWwpO1xuICAgIGlmIChuZXdUYXJnZXQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudENsb25lLCBcInRhcmdldFwiLCB7IHZhbHVlOiBuZXdUYXJnZXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudENsb25lO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvYXJpYS9tZXNzYWdlcy50c1xudmFyIExFTkdUSF9NRVNTQUdFID0gXCJUeXBlIGluIDIgb3IgbW9yZSBjaGFyYWN0ZXJzIGZvciByZXN1bHRzLlwiO1xudmFyIEtFWUJPQVJEX05BVklHQVRJT05fR1VJREVfTUVTU0FHRSA9IFwiV2hlbiBhdXRvY29tcGxldGUgcmVzdWx0cyBhcmUgYXZhaWxhYmxlIHVzZSB1cCBhbmQgZG93biBhcnJvd3MgdG8gcmV2aWV3IGFuZCBlbnRlciB0byBzZWxlY3QuIFRvdWNoIGRldmljZSB1c2VycywgZXhwbG9yZSBieSB0b3VjaCBvciB3aXRoIHN3aXBlIGdlc3R1cmVzLlwiO1xudmFyIE5PX1NFQVJDSF9SRVNVTFRTX01FU1NBR0UgPSBcIk5vIHNlYXJjaCByZXN1bHRzLlwiO1xudmFyIGdldFN1Z2dlc3Rpb25TZWxlY3RlZE1lc3NhZ2UgPSAoYWRkcmVzcywgbnVtYmVyT2ZSZXN1bHRzLCBjdXJyZW50SW5kZXgpID0+IGAke251bWJlck9mUmVzdWx0c30gJHtudW1iZXJPZlJlc3VsdHMgPT09IDEgPyBcInJlc3VsdCBpc1wiIDogXCJyZXN1bHRzIGFyZVwifSBhdmFpbGFibGUuICR7YWRkcmVzc30uICR7Y3VycmVudEluZGV4fSBvZiAke251bWJlck9mUmVzdWx0c30gaXMgc2VsZWN0ZWQuYDtcbnZhciBnZXRTdWdnZXN0aW9uc1JlYWR5TWVzc2FnZSA9IChudW1iZXJPZlJlc3VsdHMpID0+IGAke251bWJlck9mUmVzdWx0c30gJHtudW1iZXJPZlJlc3VsdHMgPT09IDEgPyBcInJlc3VsdCBpc1wiIDogXCJyZXN1bHRzIGFyZVwifSBhdmFpbGFibGUuIFVzZSB1cCBhbmQgZG93biBhcnJvd3MgdG8gcmV2aWV3IGFuZCBlbnRlciB0byBzZWxlY3QuIFRvdWNoIGRldmljZSB1c2VycywgZXhwbG9yZSBieSB0b3VjaCBvciB3aXRoIHN3aXBlIGdlc3R1cmVzLmA7XG5cbi8vIHNyYy91dGlscy9hcmlhL2luZGV4LnRzXG5mdW5jdGlvbiBhcmlhQnV0dG9uS2V5RG93bihlKSB7XG4gIGNvbnN0IGVsID0gZS5jdXJyZW50VGFyZ2V0O1xuICBpZiAoZS5rZXkgPT09IFwiIFwiIHx8IGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfSkpO1xuICB9XG59XG52YXIgQVJJQV9ERVNDUklQVElPTl9JRCA9IFwic2VhcmNoLWxpc3Rib3hfX2Rlc2NyaXB0aW9uXCI7XG52YXIgY3JlYXRlQXJpYUxpdmVFbGVtZW50ID0gKHNlZWQpID0+IHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtYXRvbWljXCIsIFwidHJ1ZVwiKTtcbiAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzdGF0dXNcIik7XG4gIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImJvcmRlcjogMHB4O2NsaXA6IHJlY3QoMHB4LCAwcHgsIDBweCwgMHB4KTtoZWlnaHQ6IDFweDttYXJnaW4tYm90dG9tOiAtMXB4O21hcmdpbi1yaWdodDogLTFweDtvdmVyZmxvdzogaGlkZGVuO3BhZGRpbmc6IDBweDtwb3NpdGlvbjogYWJzb2x1dGU7d2hpdGUtc3BhY2U6IG5vd3JhcDt3aWR0aDogMXB4O1wiKTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBkZXNjcmlwdGlvbi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtzZWVkfS0tJHtBUklBX0RFU0NSSVBUSU9OX0lEfWApO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGVzY3JpcHRpb24pO1xuICByZXR1cm4gY29udGFpbmVyO1xufTtcbnZhciBzZXRMaXZlUmVnaW9uTWVzc2FnZSA9IChtZXNzYWdlLCBzZWVkKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSAoX2EgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7c2VlZH0tLSR7QVJJQV9ERVNDUklQVElPTl9JRH1cIl1gKSkgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgZGVzY3JpcHRpb24udGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIHN1cHByZXNzRXh0ZW5zaW9uc0F1dG9jb21wbGV0ZSA9IChpbnB1dCkgPT4ge1xuICBpbnB1dC5uYW1lID0gaW5wdXQubmFtZSArIFwiIGFkZHJlc3Mtc2VhcmNoXCI7XG4gIGlucHV0LnNldEF0dHJpYnV0ZShcImRhdGEtbHBpZ25vcmVcIiwgXCJ0cnVlXCIpO1xufTtcbnZhciBnZXRBcmlhTWVzc2FnZSA9IChzZWFyY2hWYWx1ZSwgc3VnZ2VzdGlvbnMsIHNlbGVjdGVkSW5kZXgpID0+IHtcbiAgbGV0IGFyaWFNZXNzYWdlID0gbnVsbDtcbiAgY29uc3Qgbm9SZXN1bHRzID0gIXN1Z2dlc3Rpb25zIHx8IHN1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMDtcbiAgaWYgKChzZWFyY2hWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogc2VhcmNoVmFsdWUubGVuZ3RoKSA8IDIpIHtcbiAgICBhcmlhTWVzc2FnZSA9IExFTkdUSF9NRVNTQUdFICsgXCIgXCIgKyBLRVlCT0FSRF9OQVZJR0FUSU9OX0dVSURFX01FU1NBR0U7XG4gIH0gZWxzZSBpZiAobm9SZXN1bHRzKSB7XG4gICAgYXJpYU1lc3NhZ2UgPSBOT19TRUFSQ0hfUkVTVUxUU19NRVNTQUdFO1xuICB9IGVsc2UgaWYgKHNlbGVjdGVkSW5kZXggIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBzdWdnZXN0aW9uc1tzZWxlY3RlZEluZGV4XTtcbiAgICBjb25zdCBwbGFjZU5hbWUgPSBzdWdnZXN0aW9uLm5hbWUgfHwgc3VnZ2VzdGlvbi5mZWF0dXJlX25hbWUgfHwgc3VnZ2VzdGlvbi5wcm9wZXJ0aWVzLm5hbWU7XG4gICAgYXJpYU1lc3NhZ2UgPSBnZXRTdWdnZXN0aW9uU2VsZWN0ZWRNZXNzYWdlKHBsYWNlTmFtZSwgc3VnZ2VzdGlvbnMubGVuZ3RoLCBzZWxlY3RlZEluZGV4ICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgYXJpYU1lc3NhZ2UgPSBnZXRTdWdnZXN0aW9uc1JlYWR5TWVzc2FnZShzdWdnZXN0aW9ucy5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBhcmlhTWVzc2FnZTtcbn07XG5cbi8vIHNyYy91dGlscy9saXN0Ym94LnRzXG52YXIgZ2V0U3VnZ2VzdGlvblRpdGxlID0gKGl0ZW0sIHNlcnZpY2UpID0+IHtcbiAgc3dpdGNoIChzZXJ2aWNlKSB7XG4gICAgY2FzZSAwIC8qIEFkZHJlc3NBdXRvZmlsbCAqLzpcbiAgICAgIHJldHVybiBpdGVtLm1hdGNoaW5nX25hbWUgfHwgaXRlbS5mZWF0dXJlX25hbWUgfHwgaXRlbS5hZGRyZXNzX2xpbmUxO1xuICAgIGNhc2UgMiAvKiBTZWFyY2hCb3ggKi86XG4gICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICAgIGNhc2UgMSAvKiBHZW9jb2RpbmcgKi86XG4gICAgICByZXR1cm4gaXRlbS5wcm9wZXJ0aWVzLm5hbWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xudmFyIGJ1aWxkU3VnZ2VzdGlvbkRlc2NyaXB0aW9uID0gKGl0ZW0sIHNlcnZpY2UpID0+IHtcbiAgc3dpdGNoIChzZXJ2aWNlKSB7XG4gICAgY2FzZSAwIC8qIEFkZHJlc3NBdXRvZmlsbCAqLzpcbiAgICAgIHJldHVybiBpdGVtLmRlc2NyaXB0aW9uO1xuICAgIGNhc2UgMiAvKiBTZWFyY2hCb3ggKi86XG4gICAgICBpZiAoaXRlbS5mZWF0dXJlX3R5cGUgPT09IFwicG9pXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZnVsbF9hZGRyZXNzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW0ucGxhY2VfZm9ybWF0dGVkO1xuICAgIGNhc2UgMSAvKiBHZW9jb2RpbmcgKi86XG4gICAgICByZXR1cm4gaXRlbS5wcm9wZXJ0aWVzLnBsYWNlX2Zvcm1hdHRlZDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL01hcGJveFNlYXJjaExpc3Rib3gudHNcbmZ1bmN0aW9uIGdldEFyaWFJZEZvclN1Z2dlc3Rpb24ocmVzdWx0TGlzdElkLCBpKSB7XG4gIHJldHVybiBgJHtyZXN1bHRMaXN0SWR9LSR7aX1gO1xufVxudmFyIF9wb3BvdmVyLCBfYmluZGluZywgX2xhYmVsSUQsIF9yZXN1bHRMaXN0SUQsIF9pbnB1dEludGVybmFsLCBfc2VhcmNoU2VydmljZSwgX3NlbGVjdGVkSW5kZXhJbnRlcm5hbCwgX3Nob3dSZXN1bHRzLCBzaG93UmVzdWx0c19mbiwgX3JlbmRlclJlc3VsdHNMaXN0LCByZW5kZXJSZXN1bHRzTGlzdF9mbiwgX3RoZW1lSW50ZXJuYWwsIF9wb3BvdmVyT3B0aW9ucywgX2hhbmRsZUlucHV0LCBfaGFuZGxlU2VsZWN0LCBfaGFuZGxlRm9jdXMsIF9oYW5kbGVCbHVyLCBfaGFuZGxlS2V5RG93bjtcbnZhciBNYXBib3hTZWFyY2hMaXN0Ym94ID0gY2xhc3MgZXh0ZW5kcyBIVE1MU2NvcGVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zaG93UmVzdWx0cyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yZW5kZXJSZXN1bHRzTGlzdCk7XG4gICAgdGhpcy5zdWdnZXN0aW9ucyA9IG51bGw7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wb3BvdmVyLCBudWxsKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2JpbmRpbmcsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9sYWJlbElELCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcmVzdWx0TGlzdElELCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaW5wdXRJbnRlcm5hbCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NlYXJjaFNlcnZpY2UsIG51bGwpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2VsZWN0ZWRJbmRleEludGVybmFsLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdGhlbWVJbnRlcm5hbCwge30pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcG9wb3Zlck9wdGlvbnMsIHt9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUlucHV0LCAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBSZXN1bHRzIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICAgICAgY29uc3QgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgIGlmIChpbnB1dC5kYXRhc2V0W1wibWFwYm94U3VjY2Vzc1wiXSkge1xuICAgICAgICBkZWxldGUgaW5wdXQuZGF0YXNldFtcIm1hcGJveFN1Y2Nlc3NcIl07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlYXJjaFRleHQgPSBpbnB1dC52YWx1ZTtcbiAgICAgIHRoaXMucmVuZGVyQXJpYU1lc3NhZ2UoKTtcbiAgICAgIFJlc3VsdHMuc2V0QXR0cmlidXRlKFwiYXJpYS1idXN5XCIsIFwidHJ1ZVwiKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwiaW5wdXRcIiwgc2VhcmNoVGV4dCkpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyQXJpYU1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZ2V0QXJpYU1lc3NhZ2UoKF9hID0gdGhpcy5pbnB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlLCB0aGlzLnN1Z2dlc3Rpb25zLCB0aGlzLnNlbGVjdGVkSW5kZXgpO1xuICAgICAgc2V0TGl2ZVJlZ2lvbk1lc3NhZ2UobWVzc2FnZSwgdGhpcy5kYXRhc2V0LnNlZWQpO1xuICAgIH07XG4gICAgdGhpcy5jbGVhckFyaWFNZXNzYWdlID0gKCkgPT4ge1xuICAgICAgc2V0TGl2ZVJlZ2lvbk1lc3NhZ2UoXCJcIiwgdGhpcy5kYXRhc2V0LnNlZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWdnZXN0ID0gKHN1Z2dlc3Rpb25zKSA9PiB7XG4gICAgICB0aGlzLnN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnM7XG4gICAgICBpZiAoIXN1Z2dlc3Rpb25zIHx8IHN1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbmRlckFyaWFNZXNzYWdlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXN1Z2dlc3Rpb25zKSB7XG4gICAgICAgIHRoaXMuaGlkZVJlc3VsdHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9yZW5kZXJSZXN1bHRzTGlzdCwgcmVuZGVyUmVzdWx0c0xpc3RfZm4pLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfc2hvd1Jlc3VsdHMsIHNob3dSZXN1bHRzX2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBSZXN1bHRzIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICAgICAgUmVzdWx0cy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWJ1c3lcIiwgXCJmYWxzZVwiKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRXJyb3IgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IFJlc3VsdHMgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZyk7XG4gICAgICBSZXN1bHRzLnNldEF0dHJpYnV0ZShcImFyaWEtYnVzeVwiLCBcImZhbHNlXCIpO1xuICAgICAgdGhpcy5oaWRlUmVzdWx0cygpO1xuICAgIH07XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTZWxlY3QsIChzdWdnZXN0aW9uKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQuZGF0YXNldFtcIm1hcGJveFN1Y2Nlc3NcIl0gPSBcInRydWVcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwic2VsZWN0XCIsIHN1Z2dlc3Rpb24pKTtcbiAgICAgIHRoaXMuaGlkZVJlc3VsdHMoKTtcbiAgICB9KSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVGb2N1cywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgZGVsZXRlIGlucHV0LmRhdGFzZXRbXCJtYXBib3hTdWNjZXNzXCJdO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoXCJmb2N1c1wiKSk7XG4gICAgICB0aGlzLnJlbmRlckFyaWFNZXNzYWdlKCk7XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3Nob3dSZXN1bHRzLCBzaG93UmVzdWx0c19mbikuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUJsdXIsICgpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmlucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwiYmx1clwiKSk7XG4gICAgICB0aGlzLmNsZWFyQXJpYU1lc3NhZ2UoKTtcbiAgICAgIHRoaXMuaGlkZVJlc3VsdHMoKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZUFycm93VXAgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5zdWdnZXN0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgoMCwgdGhpcy5zZWxlY3RlZEluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUFycm93RG93biA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPT09IHRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBNYXRoLm1pbih0aGlzLnNlbGVjdGVkSW5kZXggKyAxLCB0aGlzLnN1Z2dlc3Rpb25zLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVLZXlEb3duLCAoZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5zdWdnZXN0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChlLmtleSA9PT0gXCJBcnJvd0Rvd25cIikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQXJyb3dEb3duKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlLmtleSA9PT0gXCJBcnJvd1VwXCIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmhhbmRsZUFycm93VXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIHRoaXMuaGlkZVJlc3VsdHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlLmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVNlbGVjdCkuY2FsbCh0aGlzLCB0aGlzLnN1Z2dlc3Rpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU2VsZWN0KS5jYWxsKHRoaXMsIHRoaXMuc3VnZ2VzdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIExJU1RCT1hfVEVNUExBVEU7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlU3R5bGUoKSB7XG4gICAgcmV0dXJuIHN0eWxlX2RlZmF1bHQ7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlVXNlclN0eWxlKCkge1xuICAgIHJldHVybiBnZXRUaGVtZUNTUyhcIi5NYXBib3hTZWFyY2hcIiwgdGhpcy50aGVtZSk7XG4gIH1cbiAgZ2V0IGlucHV0KCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0SW50ZXJuYWwpO1xuICB9XG4gIHNldCBpbnB1dChuZXdJbnB1dCkge1xuICAgIGNvbnN0IG9sZElucHV0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dEludGVybmFsKTtcbiAgICBpZiAob2xkSW5wdXQpIHtcbiAgICAgIG9sZElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUlucHV0KSk7XG4gICAgICBvbGRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVGb2N1cykpO1xuICAgICAgb2xkSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVCbHVyKSk7XG4gICAgICBvbGRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUtleURvd24pKTtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3BvcG92ZXIpKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5wdXQpIHtcbiAgICAgIG5ld0lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUlucHV0KSk7XG4gICAgICBuZXdJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVGb2N1cykpO1xuICAgICAgbmV3SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVCbHVyKSk7XG4gICAgICBuZXdJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUtleURvd24pKTtcbiAgICAgIG5ld0lucHV0LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21ib2JveFwiKTtcbiAgICAgIG5ld0lucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtYXV0b2NvbXBsZXRlXCIsIFwibGlzdFwiKTtcbiAgICAgIG5ld0lucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9yZXN1bHRMaXN0SUQpKTtcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcG9wb3ZlciwgbmV3IFBvcG92ZXIobmV3SW5wdXQsIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZykuUmVzdWx0cywgdGhpcy5wb3BvdmVyT3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lucHV0SW50ZXJuYWwsIG5ld0lucHV0KTtcbiAgfVxuICBnZXQgc2VhcmNoU2VydmljZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zZWFyY2hTZXJ2aWNlKTtcbiAgfVxuICBzZXQgc2VhcmNoU2VydmljZShzZXJ2aWNlKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9zZWFyY2hTZXJ2aWNlLCBzZXJ2aWNlKTtcbiAgfVxuICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zZWxlY3RlZEluZGV4SW50ZXJuYWwpO1xuICB9XG4gIHNldCBzZWxlY3RlZEluZGV4KG5ld0luZGV4KSB7XG4gICAgY29uc3Qgb2xkSW5kZXggPSBfX3ByaXZhdGVHZXQodGhpcywgX3NlbGVjdGVkSW5kZXhJbnRlcm5hbCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9zZWxlY3RlZEluZGV4SW50ZXJuYWwsIG5ld0luZGV4KTtcbiAgICBjb25zdCB7IFJlc3VsdHNMaXN0IH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICAgIGNvbnN0IGlkID0gZ2V0QXJpYUlkRm9yU3VnZ2VzdGlvbihfX3ByaXZhdGVHZXQodGhpcywgX3Jlc3VsdExpc3RJRCksIG5ld0luZGV4KTtcbiAgICBpZiAobmV3SW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgaWQpO1xuICAgICAgUmVzdWx0c0xpc3Quc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgICBSZXN1bHRzTGlzdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgfVxuICAgIGlmIChvbGRJbmRleCAhPT0gbmV3SW5kZXgpIHtcbiAgICAgIGNvbnN0IG9sZElkID0gZ2V0QXJpYUlkRm9yU3VnZ2VzdGlvbihfX3ByaXZhdGVHZXQodGhpcywgX3Jlc3VsdExpc3RJRCksIG9sZEluZGV4KTtcbiAgICAgIGNvbnN0IG9sZEVsID0gUmVzdWx0c0xpc3QucXVlcnlTZWxlY3RvcihgIyR7b2xkSWR9YCk7XG4gICAgICBvbGRFbCA9PSBudWxsID8gdm9pZCAwIDogb2xkRWwucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgIG9sZEVsID09IG51bGwgPyB2b2lkIDAgOiBvbGRFbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuICAgICAgaWYgKG5ld0luZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgZWwgPSBSZXN1bHRzTGlzdC5xdWVyeVNlbGVjdG9yKGAjJHtpZH1gKTtcbiAgICAgICAgZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlckFyaWFNZXNzYWdlKCk7XG4gIH1cbiAgaGlkZVJlc3VsdHMoKSB7XG4gICAgY29uc3QgeyBSZXN1bHRzLCBSZXN1bHRzTGlzdCB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nKTtcbiAgICBSZXN1bHRzLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKTtcbiAgICBSZXN1bHRzTGlzdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gIH1cbiAgcmVuZGVySXRlbShpKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJlcGFyZVRlbXBsYXRlKExJU1RCT1hfU1VHR0VTVElPTl9URU1QTEFURSk7XG4gICAgZWxlbWVudC5pZCA9IGdldEFyaWFJZEZvclN1Z2dlc3Rpb24oX19wcml2YXRlR2V0KHRoaXMsIF9yZXN1bHRMaXN0SUQpLCBpKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBmaWxsSXRlbShlbCwgaXRlbSwgaSwgdG90YWxMZW5ndGgpIHtcbiAgICBjb25zdCBpY29uRWwgPSBlbC5xdWVyeVNlbGVjdG9yKCdbY2xhc3MkPVwiU3VnZ2VzdGlvbkljb25cIl0nKTtcbiAgICBjb25zdCBuYW1lRWwgPSBlbC5xdWVyeVNlbGVjdG9yKCdbY2xhc3MkPVwiU3VnZ2VzdGlvbk5hbWVcIl0nKTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbkVsID0gZWwucXVlcnlTZWxlY3RvcignW2NsYXNzJD1cIlN1Z2dlc3Rpb25EZXNjXCJdJyk7XG4gICAgaWYgKHRoaXMuc2VhcmNoU2VydmljZSA9PT0gMCAvKiBBZGRyZXNzQXV0b2ZpbGwgKi8pIHtcbiAgICAgIGljb25FbC5pbm5lckhUTUwgPSBnZXRJY29uKGl0ZW0uYWNjdXJhY3kgPT09IFwic3RyZWV0XCIgPyBcInN0cmVldFwiIDogXCJhZGRyZXNzTWFya2VyXCIsIHRoaXMudGhlbWUpO1xuICAgICAgaWNvbkVsLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpY29uRWwuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBuYW1lRWwudGV4dENvbnRlbnQgPSBkZXNjcmlwdGlvbkVsLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICBuYW1lRWwudGV4dENvbnRlbnQgPSBnZXRTdWdnZXN0aW9uVGl0bGUoaXRlbSwgdGhpcy5zZWFyY2hTZXJ2aWNlKTtcbiAgICBkZXNjcmlwdGlvbkVsLnRleHRDb250ZW50ID0gYnVpbGRTdWdnZXN0aW9uRGVzY3JpcHRpb24oaXRlbSwgdGhpcy5zZWFyY2hTZXJ2aWNlKTtcbiAgICBpZiAoaSA9PT0gdGhpcy5zZWxlY3RlZEluZGV4KSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1wb3NpbnNldFwiLCAoaSArIDEpLnRvU3RyaW5nKCkpO1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtc2V0c2l6ZVwiLCB0b3RhbExlbmd0aC50b1N0cmluZygpKTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdGhlbWVJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IHRoZW1lKHRoZW1lKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90aGVtZUludGVybmFsLCB0aGVtZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpIHx8ICF0aGVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlVXNlclN0eWxlKGdldFRoZW1lQ1NTKFwiLk1hcGJveFNlYXJjaFwiLCB0aGVtZSkpO1xuICB9XG4gIGdldCBwb3BvdmVyT3B0aW9ucygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyT3B0aW9ucyk7XG4gIH1cbiAgc2V0IHBvcG92ZXJPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BvcG92ZXJPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKSkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKS5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdGhpcy5kYXRhU2VlZCA9IHRoaXMuZGF0YXNldC5zZWVkO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGFiZWxJRCwgdGhpcy5kYXRhc2V0LnNlZWQgKyBcIi1MYWJlbFwiKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Jlc3VsdExpc3RJRCwgdGhpcy5kYXRhc2V0LnNlZWQgKyBcIi1SZXN1bHRzTGlzdFwiKTtcbiAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVzdWx0TGlzdElEKSk7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYmluZGluZywgYmluZEVsZW1lbnRzKHRoaXMsIHtcbiAgICAgIE1hcGJveFNlYXJjaDogXCIuTWFwYm94U2VhcmNoXCIsXG4gICAgICBSZXN1bHRzOiBcIi5SZXN1bHRzXCIsXG4gICAgICBSZXN1bHRzTGlzdDogXCIuUmVzdWx0c0xpc3RcIixcbiAgICAgIExhYmVsOiBcIi5MYWJlbFwiXG4gICAgfSkpO1xuICAgIGNvbnN0IHsgUmVzdWx0cywgUmVzdWx0c0xpc3QsIExhYmVsIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICAgIExhYmVsLmlkID0gX19wcml2YXRlR2V0KHRoaXMsIF9sYWJlbElEKTtcbiAgICBSZXN1bHRzTGlzdC5pZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVzdWx0TGlzdElEKTtcbiAgICBSZXN1bHRzTGlzdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9sYWJlbElEKSk7XG4gICAgUmVzdWx0cy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUJsdXIpKTtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikgJiYgdGhpcy5pbnB1dCkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9wb3BvdmVyLCBuZXcgUG9wb3Zlcih0aGlzLmlucHV0LCBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpLlJlc3VsdHMsIHRoaXMucG9wb3Zlck9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3BvcG92ZXIpKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5pbnB1dCA9IG51bGw7XG4gICAgY29uc3QgeyBSZXN1bHRzIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICAgIFJlc3VsdHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVCbHVyKSk7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikpXG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3BvcG92ZXIpLmRlc3Ryb3koKTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5pbnB1dCkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVGb2N1cykuY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBibHVyKCkge1xuICAgIHRoaXMuaW5wdXQuYmx1cigpO1xuICB9XG4gIHVwZGF0ZVBvcG92ZXIoKSB7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikudXBkYXRlKCk7XG4gICAgfVxuICB9XG59O1xuX3BvcG92ZXIgPSBuZXcgV2Vha01hcCgpO1xuX2JpbmRpbmcgPSBuZXcgV2Vha01hcCgpO1xuX2xhYmVsSUQgPSBuZXcgV2Vha01hcCgpO1xuX3Jlc3VsdExpc3RJRCA9IG5ldyBXZWFrTWFwKCk7XG5faW5wdXRJbnRlcm5hbCA9IG5ldyBXZWFrTWFwKCk7XG5fc2VhcmNoU2VydmljZSA9IG5ldyBXZWFrTWFwKCk7XG5fc2VsZWN0ZWRJbmRleEludGVybmFsID0gbmV3IFdlYWtNYXAoKTtcbl9zaG93UmVzdWx0cyA9IG5ldyBXZWFrU2V0KCk7XG5zaG93UmVzdWx0c19mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuc3VnZ2VzdGlvbnMgfHwgIXRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgUmVzdWx0cywgTWFwYm94U2VhcmNoIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICBjb25zdCByZWN0ID0gdGhpcy5pbnB1dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgTWFwYm94U2VhcmNoLnN0eWxlLnNldFByb3BlcnR5KFwiLS13aWR0aFwiLCBgJHtyZWN0LndpZHRofXB4YCk7XG4gIE1hcGJveFNlYXJjaC5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcbiAgUmVzdWx0cy5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdm9pZCAwO1xufTtcbl9yZW5kZXJSZXN1bHRzTGlzdCA9IG5ldyBXZWFrU2V0KCk7XG5yZW5kZXJSZXN1bHRzTGlzdF9mbiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB7IFJlc3VsdHNMaXN0IH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICBpZiAoIXRoaXMuc3VnZ2VzdGlvbnMgfHwgIXRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoKSB7XG4gICAgUmVzdWx0c0xpc3QuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB0aGlzLmhpZGVSZXN1bHRzKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRzID0gZ2V0Q2hpbGRFbGVtZW50cyhSZXN1bHRzTGlzdCk7XG4gIGlmICh0aGlzLnN1Z2dlc3Rpb25zLmxlbmd0aCA+IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCB0aGlzLnN1Z2dlc3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5yZW5kZXJJdGVtKGkpO1xuICAgICAgZWxlbWVudHMucHVzaChpdGVtKTtcbiAgICAgIGl0ZW0ub25tb3VzZWVudGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgfTtcbiAgICAgIGl0ZW0ub25tb3VzZWxlYXZlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgUmVzdWx0c0xpc3QuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLnN1Z2dlc3Rpb25zLmxlbmd0aCA8IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnN1Z2dlc3Rpb25zLmxlbmd0aDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbGVtZW50c1tpXS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzdWdnZXN0aW9uIG9mIHRoaXMuc3VnZ2VzdGlvbnMpIHtcbiAgICBjb25zdCBpID0gdGhpcy5zdWdnZXN0aW9ucy5pbmRleE9mKHN1Z2dlc3Rpb24pO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICB0aGlzLmZpbGxJdGVtKGVsZW1lbnQsIHN1Z2dlc3Rpb24sIGksIHRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoKTtcbiAgICBlbGVtZW50Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVNlbGVjdCkuY2FsbCh0aGlzLCBzdWdnZXN0aW9uKTtcbiAgICB9O1xuICB9XG59O1xuX3RoZW1lSW50ZXJuYWwgPSBuZXcgV2Vha01hcCgpO1xuX3BvcG92ZXJPcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVJbnB1dCA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU2VsZWN0ID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVGb2N1cyA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlQmx1ciA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlS2V5RG93biA9IG5ldyBXZWFrTWFwKCk7XG53aW5kb3cuTWFwYm94U2VhcmNoTGlzdGJveCA9IE1hcGJveFNlYXJjaExpc3Rib3g7XG5pZiAoIXdpbmRvdy5jdXN0b21FbGVtZW50cy5nZXQoXCJtYXBib3gtc2VhcmNoLWxpc3Rib3hcIikpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWFwYm94LXNlYXJjaC1saXN0Ym94XCIsIE1hcGJveFNlYXJjaExpc3Rib3gpO1xufVxuXG4vLyBzcmMvdXRpbHMvYXV0b2ZpbGwudHNcbmltcG9ydCB7XG4gIGZlYXR1cmVUb1N1Z2dlc3Rpb25cbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbnZhciBBVVRPRklMTF9UT0tFTlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwic3RyZWV0LWFkZHJlc3NcIixcbiAgXCJhZGRyZXNzLWxpbmUxXCIsXG4gIFwiYWRkcmVzcy1saW5lMlwiLFxuICBcImFkZHJlc3MtbGluZTNcIixcbiAgXCJhZGRyZXNzLWxldmVsNFwiLFxuICBcImFkZHJlc3MtbGV2ZWwzXCIsXG4gIFwiYWRkcmVzcy1sZXZlbDJcIixcbiAgXCJhZGRyZXNzLWxldmVsMVwiLFxuICBcImNvdW50cnlcIixcbiAgXCJjb3VudHJ5LW5hbWVcIixcbiAgXCJwb3N0YWwtY29kZVwiXG5dKTtcbnZhciBBVVRPRklMTF9TS0lQX1RPS0VOUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm9mZlwiLCBcIm9uXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCJdKTtcbmZ1bmN0aW9uIGZpbmRQYXJlbnRGb3JtKGVsKSB7XG4gIGxldCBub2RlID0gZWwucGFyZW50Tm9kZTtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQWRkcmVzc0lucHV0cyhmb3JtKSB7XG4gIGNvbnN0IHBhcmVudCA9IGZvcm0gfHwgZG9jdW1lbnQ7XG4gIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFthdXRvY29tcGxldGV+PVwiYWRkcmVzcy1saW5lMVwiXSwgaW5wdXRbYXV0b2NvbXBsZXRlfj1cInN0cmVldC1hZGRyZXNzXCJdJykpO1xufVxudmFyIFNFQ1RJT04gPSBcInNlY3Rpb24tXCI7XG52YXIgU0VDVElPTl9ERUZBVUxUID0gXCJzZWN0aW9uLWRlZmF1bHRcIjtcbnZhciBTRUNUSU9OX1NISVBQSU5HID0gXCJzZWN0aW9uLXNoaXBwaW5nXCI7XG52YXIgU0VDVElPTl9CSUxMSU5HID0gXCJzZWN0aW9uLWJpbGxpbmdcIjtcbmZ1bmN0aW9uIHBhcnNlRm9ybVN0cnVjdHVyZShmb3JtKSB7XG4gIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20oZm9ybS5xdWVyeVNlbGVjdG9yQWxsKFwiW2F1dG9jb21wbGV0ZV1cIikpLmZpbHRlcigoZWwpID0+IHtcbiAgICBjb25zdCB0YWdOYW1lID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB0YWdOYW1lID09PSBcImlucHV0XCIgfHwgdGFnTmFtZSA9PT0gXCJzZWxlY3RcIiB8fCB0YWdOYW1lID09PSBcInRleHRhcmVhXCI7XG4gIH0pO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICBpZiAoIWlzVmlzaWJsZShpbnB1dCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBhdXRvY29tcGxldGUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIikgfHwgXCJcIjtcbiAgICBpZiAoIWF1dG9jb21wbGV0ZSB8fCBBVVRPRklMTF9TS0lQX1RPS0VOUy5oYXMoYXV0b2NvbXBsZXRlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IGF1dG9jb21wbGV0ZS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiIFwiKTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFBVVRPRklMTF9UT0tFTlMuaGFzKGZpZWxkKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRva2Vucy5wb3AoKTtcbiAgICBsZXQgc2VjdGlvbiA9IFNFQ1RJT05fREVGQVVMVDtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc2VjdGlvblRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChzZWN0aW9uVG9rZW4gPT09IFwic2hpcHBpbmdcIikge1xuICAgICAgICBzZWN0aW9uID0gU0VDVElPTl9TSElQUElORztcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKHNlY3Rpb25Ub2tlbiA9PT0gXCJiaWxsaW5nXCIpIHtcbiAgICAgICAgc2VjdGlvbiA9IFNFQ1RJT05fQklMTElORztcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc2VjdGlvblRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChzZWN0aW9uVG9rZW4uc3RhcnRzV2l0aChTRUNUSU9OKSkge1xuICAgICAgICBzZWN0aW9uID0gc2VjdGlvblRva2VuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXMucHVzaCh7XG4gICAgICBpbnB1dCxcbiAgICAgIHNlY3Rpb24sXG4gICAgICBmaWVsZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmaW5kQWRkcmVzc0F1dG9maWxsSW5wdXRzKGZvcm0sIHJlZikge1xuICBjb25zdCBsb2dpY2FsU2VjdGlvbnMgPSBbXTtcbiAgY29uc3QgbG9naWNhbFNlY3Rpb25TZWN0aW9ucyA9IFtdO1xuICBjb25zdCBmb3JtU3RydWN0dXJlID0gcGFyc2VGb3JtU3RydWN0dXJlKGZvcm0pO1xuICBsZXQgZm91bmRTZWN0aW9uID0gbnVsbDtcbiAgZm9yIChjb25zdCB7IGlucHV0LCBzZWN0aW9uLCBmaWVsZCB9IG9mIGZvcm1TdHJ1Y3R1cmUpIHtcbiAgICBsZXQgbGFzdEluZGV4ID0gbG9naWNhbFNlY3Rpb25zLmxlbmd0aCAtIDE7XG4gICAgbGV0IGNyZWF0ZU5ld1NlY3Rpb24gPSBmYWxzZTtcbiAgICBpZiAoIWxvZ2ljYWxTZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNyZWF0ZU5ld1NlY3Rpb24gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobG9naWNhbFNlY3Rpb25TZWN0aW9uc1tsYXN0SW5kZXhdICE9PSBzZWN0aW9uKSB7XG4gICAgICBjcmVhdGVOZXdTZWN0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGxvZ2ljYWxTZWN0aW9uc1tsYXN0SW5kZXhdW2ZpZWxkXSkge1xuICAgICAgY3JlYXRlTmV3U2VjdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjcmVhdGVOZXdTZWN0aW9uKSB7XG4gICAgICBpZiAoZm91bmRTZWN0aW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbG9naWNhbFNlY3Rpb25zLnB1c2goe1xuICAgICAgICBbZmllbGRdOiBpbnB1dFxuICAgICAgfSk7XG4gICAgICBsb2dpY2FsU2VjdGlvblNlY3Rpb25zLnB1c2goc2VjdGlvbik7XG4gICAgICBsYXN0SW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbG9naWNhbFNlY3Rpb25zW2xhc3RJbmRleF1bZmllbGRdID0gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gcmVmKSB7XG4gICAgICBmb3VuZFNlY3Rpb24gPSBsb2dpY2FsU2VjdGlvbnNbbGFzdEluZGV4XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kU2VjdGlvbiAhPSBudWxsID8gZm91bmRTZWN0aW9uIDoge307XG59XG5mdW5jdGlvbiBzZXRGb3JtQXV0b2ZpbGxWYWx1ZXMoZm9ybSwgcmVmLCBzdWdnZXN0aW9uKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbWFwID0gZmluZEFkZHJlc3NBdXRvZmlsbElucHV0cyhmb3JtLCByZWYpO1xuICBjb25zdCBzdHJlZXRBZGRyZXNzID0gW1xuICAgIHN1Z2dlc3Rpb24uYWRkcmVzc19saW5lMSxcbiAgICBzdWdnZXN0aW9uLmFkZHJlc3NfbGluZTIsXG4gICAgc3VnZ2VzdGlvbi5hZGRyZXNzX2xpbmUzXG4gIF0uZmlsdGVyKChwYXJ0KSA9PiBCb29sZWFuKHBhcnQpKS5qb2luKFwiLCBcIik7XG4gIHNldFZhbHVlKG1hcFtcInN0cmVldC1hZGRyZXNzXCJdLCBtYXBbXCJhZGRyZXNzLWxpbmUyXCJdID8gc3VnZ2VzdGlvbi5hZGRyZXNzX2xpbmUxIHx8IFwiXCIgOiBzdHJlZXRBZGRyZXNzKTtcbiAgc2V0VmFsdWUobWFwW1wiYWRkcmVzcy1saW5lMVwiXSwgc3VnZ2VzdGlvbi5hZGRyZXNzX2xpbmUxIHx8IFwiXCIpO1xuICBzZXRWYWx1ZShtYXBbXCJhZGRyZXNzLWxpbmUyXCJdLCBzdWdnZXN0aW9uLmFkZHJlc3NfbGluZTIgfHwgXCJcIik7XG4gIHNldFZhbHVlKG1hcFtcImFkZHJlc3MtbGV2ZWwxXCJdLCBzdWdnZXN0aW9uLmFkZHJlc3NfbGV2ZWwxIHx8IFwiXCIpO1xuICBzZXRWYWx1ZShtYXBbXCJhZGRyZXNzLWxldmVsMlwiXSwgc3VnZ2VzdGlvbi5hZGRyZXNzX2xldmVsMiB8fCBcIlwiKTtcbiAgc2V0VmFsdWUobWFwW1wiYWRkcmVzcy1sZXZlbDNcIl0sIHN1Z2dlc3Rpb24uYWRkcmVzc19sZXZlbDMgfHwgXCJcIik7XG4gIGNvbnN0IGNvdW50cnlDb2RlID0gc3VnZ2VzdGlvbi5jb3VudHJ5X2NvZGUgfHwgKChfYSA9IHN1Z2dlc3Rpb24ubWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pc29fMzE2Nl8xKSB8fCBcIlwiO1xuICBpZiAobWFwLmNvdW50cnkgJiYgbWFwLmNvdW50cnkgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkge1xuICAgIGxldCBmaXJzdE9wdGlvbiA9IG1hcC5jb3VudHJ5LnF1ZXJ5U2VsZWN0b3IoYG9wdGlvbmApLnZhbHVlO1xuICAgIGlmIChmaXJzdE9wdGlvbiA9PT0gXCJcIikge1xuICAgICAgZmlyc3RPcHRpb24gPSBtYXAuY291bnRyeS5xdWVyeVNlbGVjdG9yQWxsKGBvcHRpb25gKVsxXS52YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNVcHBlckNhc2UgPSBmaXJzdE9wdGlvbiA9PT0gZmlyc3RPcHRpb24udG9VcHBlckNhc2UoKTtcbiAgICBzZXRWYWx1ZShtYXBbXCJjb3VudHJ5XCJdLCBpc1VwcGVyQ2FzZSA/IGNvdW50cnlDb2RlLnRvVXBwZXJDYXNlKCkgOiBjb3VudHJ5Q29kZSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWUobWFwW1wiY291bnRyeVwiXSwgY291bnRyeUNvZGUpO1xuICB9XG4gIHNldFZhbHVlKG1hcFtcImNvdW50cnktbmFtZVwiXSwgc3VnZ2VzdGlvbi5jb3VudHJ5IHx8IFwiXCIpO1xuICBzZXRWYWx1ZShtYXBbXCJwb3N0YWwtY29kZVwiXSwgc3VnZ2VzdGlvbi5wb3N0Y29kZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1BdXRvZmlsbFZhbHVlcyhmb3JtLCByZWYpIHtcbiAgY29uc3QgbWFwID0gZmluZEFkZHJlc3NBdXRvZmlsbElucHV0cyhmb3JtLCByZWYpO1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCBpbnB1dF0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsID8gdm9pZCAwIDogaW5wdXQudmFsdWUpIHtcbiAgICAgIHZhbHVlc1trZXldID0gaW5wdXQudmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRBdXRvZmlsbFNlYXJjaFRleHQoc25hcHNob3QpIHtcbiAgY29uc3Qgc2VhcmNoVGV4dCA9IFtdO1xuICBpZiAoc25hcHNob3RbXCJzdHJlZXQtYWRkcmVzc1wiXSkge1xuICAgIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcInN0cmVldC1hZGRyZXNzXCJdKTtcbiAgfSBlbHNlIHtcbiAgICBzZWFyY2hUZXh0LnB1c2goc25hcHNob3RbXCJhZGRyZXNzLWxpbmUxXCJdIHx8IFwiXCIpO1xuICB9XG4gIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcImFkZHJlc3MtbGluZTJcIl0gfHwgXCJcIik7XG4gIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcImFkZHJlc3MtbGluZTNcIl0gfHwgXCJcIik7XG4gIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcImFkZHJlc3MtbGV2ZWwzXCJdIHx8IFwiXCIpO1xuICBzZWFyY2hUZXh0LnB1c2goc25hcHNob3RbXCJhZGRyZXNzLWxldmVsMlwiXSB8fCBcIlwiKTtcbiAgc2VhcmNoVGV4dC5wdXNoKHNuYXBzaG90W1wiYWRkcmVzcy1sZXZlbDFcIl0gfHwgXCJcIik7XG4gIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcInBvc3RhbC1jb2RlXCJdIHx8IFwiXCIpO1xuICBpZiAoc25hcHNob3RbXCJjb3VudHJ5LW5hbWVcIl0pIHtcbiAgICBzZWFyY2hUZXh0LnB1c2goc25hcHNob3RbXCJjb3VudHJ5LW5hbWVcIl0pO1xuICB9IGVsc2Uge1xuICAgIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcImNvdW50cnlcIl0gfHwgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFRleHQuZmlsdGVyKChwYXJ0KSA9PiBCb29sZWFuKHBhcnQpKS5tYXAoKHBhcnQpID0+IHBhcnQudHJpbSgpKS5qb2luKFwiLCBcIik7XG59XG5mdW5jdGlvbiBmaWxsRm9ybVdpdGhGZWF0dXJlKGZlYXR1cmUsIGlucHV0KSB7XG4gIGNvbnN0IGZvcm0gPSBmaW5kUGFyZW50Rm9ybShpbnB1dCk7XG4gIGlmICghZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdWdnZXN0aW9uID0gZmVhdHVyZVRvU3VnZ2VzdGlvbihmZWF0dXJlKTtcbiAgc2V0Rm9ybUF1dG9maWxsVmFsdWVzKGZvcm0sIGlucHV0LCBzdWdnZXN0aW9uKTtcbiAgY29uc3QgaW5wdXRNYXAgPSBmaW5kQWRkcmVzc0F1dG9maWxsSW5wdXRzKGZvcm0sIGlucHV0KTtcbiAgaWYgKGlucHV0TWFwW1wiYWRkcmVzcy1saW5lMlwiXSAmJiAhc3VnZ2VzdGlvbi5hZGRyZXNzX2xpbmUyKSB7XG4gICAgaW5wdXRNYXBbXCJhZGRyZXNzLWxpbmUyXCJdLmZvY3VzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZlYXR1cmVUb0F1dG9maWxsVmFsdWVNYXAoZmVhdHVyZSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHZhbHVlcyA9IHt9O1xuICBjb25zdCBzdHJlZXRBZGRyZXNzID0gW1xuICAgIGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUxLFxuICAgIGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUyLFxuICAgIGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUzXG4gIF0uZmlsdGVyKChwYXJ0KSA9PiBCb29sZWFuKHBhcnQpKS5qb2luKFwiLCBcIik7XG4gIHZhbHVlc1tcInN0cmVldC1hZGRyZXNzXCJdID0gc3RyZWV0QWRkcmVzcztcbiAgdmFsdWVzW1wiYWRkcmVzcy1saW5lMVwiXSA9IGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUxO1xuICB2YWx1ZXNbXCJhZGRyZXNzLWxpbmUyXCJdID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmFkZHJlc3NfbGluZTI7XG4gIHZhbHVlc1tcImFkZHJlc3MtbGluZTNcIl0gPSBmZWF0dXJlLnByb3BlcnRpZXMuYWRkcmVzc19saW5lMztcbiAgdmFsdWVzW1wiYWRkcmVzcy1sZXZlbDFcIl0gPSBmZWF0dXJlLnByb3BlcnRpZXMuYWRkcmVzc19sZXZlbDE7XG4gIHZhbHVlc1tcImFkZHJlc3MtbGV2ZWwyXCJdID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmFkZHJlc3NfbGV2ZWwyO1xuICB2YWx1ZXNbXCJhZGRyZXNzLWxldmVsM1wiXSA9IGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xldmVsMztcbiAgdmFsdWVzW1wiY291bnRyeVwiXSA9IChfYSA9IGZlYXR1cmUucHJvcGVydGllcy5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlzb18zMTY2XzE7XG4gIHZhbHVlc1tcImNvdW50cnktbmFtZVwiXSA9IGZlYXR1cmUucHJvcGVydGllcy5jb3VudHJ5O1xuICB2YWx1ZXNbXCJwb3N0YWwtY29kZVwiXSA9IGZlYXR1cmUucHJvcGVydGllcy5wb3N0Y29kZTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGNoZWNrQXV0b2ZpbGxWYWx1ZXNDaGFuZ2VkKHRhcmdldE1hcCwgcmVmZXJlbmNlTWFwKSB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRhcmdldE1hcCkpIHtcbiAgICBpZiAocmVmZXJlbmNlTWFwW2tleV0gIT09IHZhbHVlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIGRpc3RpbmN0RXhhY3RTdHJlZXRSZXN1bHRzID0gKHN1Z2dlc3Rpb25zKSA9PiB7XG4gIHJldHVybiBzdWdnZXN0aW9ucy5maWx0ZXIoKGl0ZW0xLCBpZHgsIGFycikgPT4ge1xuICAgIGNvbnN0IHRpdGxlID0gZ2V0U3VnZ2VzdGlvblRpdGxlKGl0ZW0xLCAwIC8qIEFkZHJlc3NBdXRvZmlsbCAqLyk7XG4gICAgcmV0dXJuIGl0ZW0xLmFjY3VyYWN5ICE9PSBcInN0cmVldFwiIHx8IGFyci5maW5kSW5kZXgoKGl0ZW0yKSA9PiB0aXRsZSA9PT0gZ2V0U3VnZ2VzdGlvblRpdGxlKGl0ZW0yLCAwIC8qIEFkZHJlc3NBdXRvZmlsbCAqLykpID09PSBpZHg7XG4gIH0pO1xufTtcbnZhciB0b2dnbGVBdXRvY29tcGxldGlvbiA9IChpbnB1dCwgaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlLCBlbmFibGVCcm93c2VyQXV0b2NvbXBsZXRlKSA9PiB7XG4gIGNvbnN0IGRpc2FibGVWYWx1ZSA9IFwibmV3LXBhc3N3b3JkXCI7XG4gIGNvbnN0IGRlZmF1bHRGYWxsYmFja1ZhbHVlID0gXCJhZGRyZXNzLWxpbmUxXCI7XG4gIGNvbnN0IGF1dG9jb21wbGV0ZVZhbHVlID0gZW5hYmxlQnJvd3NlckF1dG9jb21wbGV0ZSA/IGluaXRpYWxBdXRvY29tcGxldGVWYWx1ZSB8fCBkZWZhdWx0RmFsbGJhY2tWYWx1ZSA6IGRpc2FibGVWYWx1ZTtcbiAgaWYgKGlucHV0KSB7XG4gICAgaW5wdXQuYXV0b2NvbXBsZXRlID0gYXV0b2NvbXBsZXRlVmFsdWU7XG4gIH1cbn07XG52YXIgaGFuZGxlU3RyZWV0U2VsZWN0aW9uID0gKGlucHV0LCBpbml0aWFsQXV0b2NvbXBsZXRlVmFsdWUsIHN1Z2dlc3Rpb24pID0+IHtcbiAgaWYgKCFpbnB1dCB8fCAhc3VnZ2VzdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB0b2dnbGVBdXRvY29tcGxldGlvbihpbnB1dCwgaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlLCB0cnVlKTtcbiAgY29uc3QgZmVhdHVyZSA9IHtcbiAgICBwcm9wZXJ0aWVzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdWdnZXN0aW9uKSwge1xuICAgICAgYWRkcmVzc19saW5lMTogc3VnZ2VzdGlvbi5hZGRyZXNzX2xpbmUxICsgXCIgXCIsXG4gICAgICBwb3N0Y29kZTogbnVsbFxuICAgIH0pXG4gIH07XG4gIGZpbGxGb3JtV2l0aEZlYXR1cmUoZmVhdHVyZSwgaW5wdXQpO1xuICB0b2dnbGVBdXRvY29tcGxldGlvbihpbnB1dCwgaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlLCBmYWxzZSk7XG4gIGlucHV0ID09IG51bGwgPyB2b2lkIDAgOiBpbnB1dC5mb2N1cygpO1xufTtcblxuLy8gc3JjL2NvbmZpcm1BZGRyZXNzLnRzXG5pbXBvcnQge1xuICBmZWF0dXJlVG9TdWdnZXN0aW9uIGFzIGZlYXR1cmVUb1N1Z2dlc3Rpb24yXG59IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL01hcGJveEFkZHJlc3NDb25maXJtYXRpb24udHNcbmltcG9ydCB7XG4gIE1hdGNoQ29kZUNvbmZpZGVuY2UsXG4gIFZhbGlkYXRpb25Db3JlXG59IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG5pbXBvcnQgbm9TY3JvbGwgZnJvbSBcIm5vLXNjcm9sbFwiO1xuaW1wb3J0IHsgY3JlYXRlRm9jdXNUcmFwIH0gZnJvbSBcImZvY3VzLXRyYXBcIjtcblxuLy8gc3JjL2NvbmZpZy50c1xuaW1wb3J0IHsgU2Vzc2lvblRva2VuIGFzIFNlc3Npb25Ub2tlbjIgfSBmcm9tIFwiQG1hcGJveC9zZWFyY2gtanMtY29yZVwiO1xudmFyIENvbmZpZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mZWVkYmFja0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuYXV0b2ZpbGxTZXNzaW9uVG9rZW4gPSBuZXcgU2Vzc2lvblRva2VuMigpO1xuICAgIHRoaXMuYXV0b2ZpbGxTZXNzaW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGV0ZWN0QnJvd3NlckF1dG9maWxsRW5hYmxlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIGNvbmZpZyA9IG5ldyBDb25maWcoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25maWcsIFwiYXV0b2ZpbGxTZXNzaW9uVG9rZW5cIiwge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2Vcbn0pO1xuXG4vLyBzcmMvY29tcG9uZW50cy9NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uLnRzXG52YXIgVEVNUExBVEUgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG48dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgPG1hcGJveC1hZGRyZXNzLWNvbmZpcm1hdGlvbi1mZWF0dXJlIGNsYXNzPVwiQ29udGVudEZlYXR1cmVcIj48L21hcGJveC1hZGRyZXNzLWNvbmZpcm1hdGlvbi1mZWF0dXJlPlxuICAgIDxtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tbm8tZmVhdHVyZSBjbGFzcz1cIkNvbnRlbnROb0ZlYXR1cmVcIj48L21hcGJveC1hZGRyZXNzLWNvbmZpcm1hdGlvbi1uby1mZWF0dXJlPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5gKTtcbnZhciBfc2hvdywgX2JpbmRpbmcyLCBfZm9jdXNUcmFwLCBfdGhlbWVJbnRlcm5hbDI7XG52YXIgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbiA9IGNsYXNzIGV4dGVuZHMgSFRNTFNjb3BlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2hvdywgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYmluZGluZzIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mb2N1c1RyYXAsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90aGVtZUludGVybmFsMiwge30pO1xuICB9XG4gIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gVEVNUExBVEU7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlU3R5bGUoKSB7XG4gICAgcmV0dXJuIHN0eWxlX2RlZmF1bHQ7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlVXNlclN0eWxlKCkge1xuICAgIHJldHVybiBnZXRUaGVtZUNTUyhcIi5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uXCIsIHRoaXMudGhlbWUpO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF90aGVtZUludGVybmFsMik7XG4gIH1cbiAgc2V0IHRoZW1lKHRoZW1lKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90aGVtZUludGVybmFsMiwgdGhlbWUpO1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMikgfHwgIXRoZW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGVtcGxhdGVVc2VyU3R5bGUoZ2V0VGhlbWVDU1MoXCIuTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvblwiLCB0aGVtZSkpO1xuICAgIGNvbnN0IHsgQ29udGVudEZlYXR1cmUsIENvbnRlbnROb0ZlYXR1cmUgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzIpO1xuICAgIENvbnRlbnRGZWF0dXJlLnRoZW1lID0gdGhlbWU7XG4gICAgQ29udGVudE5vRmVhdHVyZS50aGVtZSA9IHRoZW1lO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9iaW5kaW5nMiwgYmluZEVsZW1lbnRzKHRoaXMsIHtcbiAgICAgIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb246IFwiLk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25cIixcbiAgICAgIENvbnRlbnRGZWF0dXJlOiBcIi5Db250ZW50RmVhdHVyZVwiLFxuICAgICAgQ29udGVudE5vRmVhdHVyZTogXCIuQ29udGVudE5vRmVhdHVyZVwiXG4gICAgfSkpO1xuICAgIGNvbnN0IHsgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjogTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjIgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzIpO1xuICAgIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24yLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICBjb25zdCB0aGVtZSA9IHRoaXMudGhlbWU7XG4gICAgaWYgKHRoZW1lKSB7XG4gICAgICBjb25zdCB7IENvbnRlbnRGZWF0dXJlLCBDb250ZW50Tm9GZWF0dXJlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKTtcbiAgICAgIENvbnRlbnRGZWF0dXJlLnRoZW1lID0gdGhlbWU7XG4gICAgICBDb250ZW50Tm9GZWF0dXJlLnRoZW1lID0gdGhlbWU7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZm9jdXNUcmFwLCBudWxsKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIHZhciBfYTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Nob3csIGZhbHNlKTtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjogTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjIgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzIpO1xuICAgIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24yLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX2ZvY3VzVHJhcCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWFjdGl2YXRlKCk7XG4gICAgbm9TY3JvbGwub2ZmKCk7XG4gIH1cbiAgc2hvdyhhdXRvZmlsbFZhbHVlcywgb3B0aW9uc0FyZywgZmVhdHVyZSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzIpKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiY2FuY2VsXCIgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjogTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjIsIENvbnRlbnRGZWF0dXJlLCBDb250ZW50Tm9GZWF0dXJlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKTtcbiAgICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIG1pbmltYXAgPSBmYWxzZSwgdGhlbWUsIGZvb3RlciB9ID0gb3B0aW9uc0FyZztcbiAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcbiAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgIENvbnRlbnRGZWF0dXJlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgICBDb250ZW50Tm9GZWF0dXJlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgQ29udGVudEZlYXR1cmUubWluaW1hcCA9IG1pbmltYXA7XG4gICAgICAgIENvbnRlbnRGZWF0dXJlLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICAgIENvbnRlbnRGZWF0dXJlLmZvb3RlciA9IGZvb3RlcjtcbiAgICAgICAgQ29udGVudEZlYXR1cmUudXBkYXRlKGZlYXR1cmUsIGF1dG9maWxsVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENvbnRlbnRGZWF0dXJlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgQ29udGVudE5vRmVhdHVyZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgICAgQ29udGVudE5vRmVhdHVyZS51cGRhdGUoYXV0b2ZpbGxWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9zaG93LCB0cnVlKTtcbiAgICAgIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24yLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgbm9TY3JvbGwub24oKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUNvbnRlbnRFbGVtZW50ID0gZmVhdHVyZSA/IENvbnRlbnRGZWF0dXJlIDogQ29udGVudE5vRmVhdHVyZTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZm9jdXNUcmFwLCBjcmVhdGVGb2N1c1RyYXAoTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbjIsIHtcbiAgICAgICAgZmFsbGJhY2tGb2N1czogYWN0aXZlQ29udGVudEVsZW1lbnQsXG4gICAgICAgIGVzY2FwZURlYWN0aXZhdGVzOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZm9jdXNUcmFwKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFjdGl2YXRlKCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRIb3N0ID0gYWN0aXZlQ29udGVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGZuID0gKGUpID0+IHtcbiAgICAgICAgICBldmVudEhvc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc3VsdFwiLCBmbik7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZS5kZXRhaWw7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gXCJjaGFuZ2VcIikge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiY2hhbmdlXCIsXG4gICAgICAgICAgICAgIGZlYXR1cmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgdHlwZTogcmVzdWx0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50SG9zdC5hZGRFdmVudExpc3RlbmVyKFwicmVzdWx0XCIsIGZuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHRyeVNob3coYXV0b2ZpbGxWYWx1ZXMsIG9wdGlvbnNBcmcpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImNhbmNlbFwiIH07XG4gICAgICB9XG4gICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCBvcHRpb25zID0ge30gfSA9IG9wdGlvbnNBcmc7XG4gICAgICBjb25zdCB2YWxpZGF0ZSA9IG5ldyBWYWxpZGF0aW9uQ29yZShfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIGFjY2Vzc1Rva2VuXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgICBjb25zdCBzZWFyY2hUZXh0ID0gZ2V0QXV0b2ZpbGxTZWFyY2hUZXh0KGF1dG9maWxsVmFsdWVzKTtcbiAgICAgIGNvbnN0IGZlYXR1cmVDb2xsZWN0aW9uID0geWllbGQgdmFsaWRhdGUudmFsaWRhdGUoc2VhcmNoVGV4dCwge1xuICAgICAgICBzZXNzaW9uVG9rZW46IGNvbmZpZy5hdXRvZmlsbFNlc3Npb25Ub2tlblxuICAgICAgfSk7XG4gICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbMF07XG4gICAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsaWRhdGlvbiA9IChmZWF0dXJlMikgPT4gZmVhdHVyZTIucHJvcGVydGllcy5tYXRjaF9jb2RlLmNvbmZpZGVuY2UgPT09IE1hdGNoQ29kZUNvbmZpZGVuY2UuZXhhY3Q7XG4gICAgICAgIGNvbnN0IHsgc2tpcENvbmZpcm1Nb2RhbCA9IGRlZmF1bHRWYWxpZGF0aW9uIH0gPSBvcHRpb25zQXJnO1xuICAgICAgICBpZiAoc2tpcENvbmZpcm1Nb2RhbChmZWF0dXJlKSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9jaGFuZ2VcIiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geWllbGQgdGhpcy5zaG93KGF1dG9maWxsVmFsdWVzLCBvcHRpb25zQXJnLCBmZWF0dXJlKTtcbiAgICB9KTtcbiAgfVxufTtcbl9zaG93ID0gbmV3IFdlYWtNYXAoKTtcbl9iaW5kaW5nMiA9IG5ldyBXZWFrTWFwKCk7XG5fZm9jdXNUcmFwID0gbmV3IFdlYWtNYXAoKTtcbl90aGVtZUludGVybmFsMiA9IG5ldyBXZWFrTWFwKCk7XG53aW5kb3cuTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbiA9IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb247XG5pZiAoIXdpbmRvdy5jdXN0b21FbGVtZW50cy5nZXQoXCJtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb25cIikpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uXCIsIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24pO1xufVxuXG4vLyBzcmMvY29uZmlybUFkZHJlc3MudHNcbnZhciBjb25maXJtYXRpb24gPSBuZXcgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbigpO1xuZnVuY3Rpb24gY29uZmlybUFkZHJlc3MoXzApIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKGZvcm0sIG9wdGlvbnNBcmcgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHNlY3Rpb25zID0gW10gfSA9IG9wdGlvbnNBcmc7XG4gICAgaWYgKCFjb25maXJtYXRpb24ucGFyZW50Tm9kZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb25maXJtYXRpb24pO1xuICAgIH1cbiAgICBsZXQgY29sbGVjdGVkUmVzdWx0ID0geyB0eXBlOiBcIm5vY2hhbmdlXCIgfTtcbiAgICBjb25zdCBpbnB1dHMgPSBmaW5kQWRkcmVzc0lucHV0cyhmb3JtKTtcbiAgICBjb25zdCBzdHJ1Y3R1cmUgPSBwYXJzZUZvcm1TdHJ1Y3R1cmUoZm9ybSk7XG4gICAgY29uc3QgbGlzdGJveENvbXBvbmVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJtYXBib3gtc2VhcmNoLWxpc3Rib3hcIikpO1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBpZiAoc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdHVyZVJlZiA9IHN0cnVjdHVyZS5maW5kKChzKSA9PiBzLmlucHV0ID09PSBpbnB1dCk7XG4gICAgICAgIGlmICghc3RydWN0dXJlUmVmKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWN0aW9ucy5pbmNsdWRlcyhzdHJ1Y3R1cmVSZWYuc2VjdGlvbikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYXV0b2ZpbGxWYWx1ZXMgPSBnZXRGb3JtQXV0b2ZpbGxWYWx1ZXMoZm9ybSwgaW5wdXQpO1xuICAgICAgY29uc3QgbGlzdGJveCA9IGxpc3Rib3hDb21wb25lbnRzLmZpbmQoKGxiKSA9PiBsYi5pbnB1dCA9PT0gaW5wdXQpO1xuICAgICAgY29uc3QgYXV0b2ZpbGwyID0gbGlzdGJveCA9PSBudWxsID8gdm9pZCAwIDogbGlzdGJveC5hdXRvZmlsbEhvc3Q7XG4gICAgICBpZiAoYXV0b2ZpbGwyKSB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXRyaWV2ZWRGZWF0dXJlID0gYXV0b2ZpbGwyLnJldHJpZXZlRmVhdHVyZTtcbiAgICAgICAgaWYgKGxhc3RSZXRyaWV2ZWRGZWF0dXJlKSB7XG4gICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBmZWF0dXJlVG9BdXRvZmlsbFZhbHVlTWFwKGxhc3RSZXRyaWV2ZWRGZWF0dXJlKTtcbiAgICAgICAgICBpZiAoIWNoZWNrQXV0b2ZpbGxWYWx1ZXNDaGFuZ2VkKGF1dG9maWxsVmFsdWVzLCBzbmFwc2hvdCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBvcHRpb25zQXJnLmFjY2Vzc1Rva2VuIHx8IGNvbmZpZy5hY2Nlc3NUb2tlbjtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGNvbmZpcm1hdGlvbi50cnlTaG93KGF1dG9maWxsVmFsdWVzLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zQXJnKSwge1xuICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgfSkpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImNoYW5nZVwiKSB7XG4gICAgICAgIGNvbnN0IGlucHV0TWFwID0gZmluZEFkZHJlc3NBdXRvZmlsbElucHV0cyhmb3JtLCBpbnB1dCk7XG4gICAgICAgIGlmICgoX2EgPSBpbnB1dE1hcFtcImFkZHJlc3MtbGluZTJcIl0pID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5mZWF0dXJlLnByb3BlcnRpZXMuYWRkcmVzc19saW5lMiA9IGlucHV0TWFwW1wiYWRkcmVzcy1saW5lMlwiXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGJveCkge1xuICAgICAgICAgIGF1dG9maWxsMi5zaW11bGF0ZVJldHJpZXZlKHJlc3VsdC5mZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5kYXRhc2V0W1wibWFwYm94U3VjY2Vzc1wiXSA9IFwidHJ1ZVwiO1xuICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBmZWF0dXJlVG9TdWdnZXN0aW9uMihyZXN1bHQuZmVhdHVyZSk7XG4gICAgICAgICAgc2V0Rm9ybUF1dG9maWxsVmFsdWVzKGZvcm0sIGlucHV0LCBzdWdnZXN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImNoYW5nZVwiICYmIGNvbGxlY3RlZFJlc3VsdC50eXBlICE9PSBcImNhbmNlbFwiKSB7XG4gICAgICAgIGNvbGxlY3RlZFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJjYW5jZWxcIikge1xuICAgICAgICBjb2xsZWN0ZWRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0ZWRSZXN1bHQ7XG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbHMvY29uZmlybWF0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBZGRyZXNzRWxlbWVudChhdXRvZmlsbFZhbHVlcywgYmFzZUFkZHJlc3MsIGZlYXR1cmVOYW1lLCBmZWF0dXJlRGVzY3JpcHRpb24sIGlzU2Vjb25kYXJ5KSB7XG4gIGlmIChiYXNlQWRkcmVzcykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG4gICAgICAgIDxzcGFuPlxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIGApO1xuICAgIGNvbnN0IFtmaXJzdExpbmUsIGxhc3RMaW5lXSA9IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3BhbiA+IHNwYW5cIikpO1xuICAgIGlmIChmZWF0dXJlTmFtZSAmJiBmZWF0dXJlRGVzY3JpcHRpb24pIHtcbiAgICAgIGZpcnN0TGluZS50ZXh0Q29udGVudCA9IGZlYXR1cmVOYW1lO1xuICAgICAgbGFzdExpbmUudGV4dENvbnRlbnQgPSBmZWF0dXJlRGVzY3JpcHRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYmFzZUFkZHJlc3Muc3BsaXQoXCIsXCIpO1xuICAgICAgZmlyc3RMaW5lLnRleHRDb250ZW50ID0gcGFydHNbMF0udHJpbSgpO1xuICAgICAgbGFzdExpbmUudGV4dENvbnRlbnQgPSBwYXJ0cy5zbGljZSgxKS5qb2luKFwiLFwiKS50cmltKCk7XG4gICAgfVxuICAgIGlmICghaXNTZWNvbmRhcnkpIHtcbiAgICAgIGlmIChhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGluZTJcIl0pIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gYXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxpbmUyXCJdO1xuICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShzcGFuLCBsYXN0TGluZSk7XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSwgbGFzdExpbmUpO1xuICAgICAgfVxuICAgICAgaWYgKGF1dG9maWxsVmFsdWVzW1wiYWRkcmVzcy1saW5lM1wiXSkge1xuICAgICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGluZTNcIl07XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNwYW4sIGxhc3RMaW5lKTtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpLCBsYXN0TGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZpcnN0TGluZSA9IGF1dG9maWxsVmFsdWVzW1wic3RyZWV0LWFkZHJlc3NcIl0gfHwgYXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxpbmUxXCJdIHx8IFwiXCI7XG4gICAgY29uc3QgbGluZTIgPSBhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGluZTJcIl07XG4gICAgY29uc3QgbGluZTMgPSBhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGluZTNcIl07XG4gICAgY29uc3QgbGFzdExpbmUgPSBbXG4gICAgICBhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGV2ZWw0XCJdIHx8IFwiXCIsXG4gICAgICBhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGV2ZWwzXCJdIHx8IFwiXCIsXG4gICAgICBhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGV2ZWwyXCJdIHx8IFwiXCIsXG4gICAgICBgJHthdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGV2ZWwxXCJdIHx8IFwiXCJ9ICR7YXV0b2ZpbGxWYWx1ZXNbXCJwb3N0YWwtY29kZVwiXSB8fCBcIlwifWAsXG4gICAgICBhdXRvZmlsbFZhbHVlcy5jb3VudHJ5IHx8IGF1dG9maWxsVmFsdWVzW1wiY291bnRyeS1uYW1lXCJdIHx8IFwiXCJcbiAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgYWRkcmVzc0xpbmVzID0gW2ZpcnN0TGluZSwgbGluZTIsIGxpbmUzLCBsYXN0TGluZV0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IGFkZHJlc3NMaW5lc0h0bWwgPSBhZGRyZXNzTGluZXMubWFwKCh2YWwpID0+IGA8c3Bhbj4ke3ZhbH08L3NwYW4+YCkuam9pbihcIjxiciAvPlwiKTtcbiAgICBjb25zdCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuICAgICAgICA8c3Bhbj4ke2FkZHJlc3NMaW5lc0h0bWx9PC9zcGFuPlxuICAgICAgYCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeUNvbmZpcm1Ccm93c2VyQXV0b2ZpbGwoaW5wdXQsIGV2ZW50LCBjb25maXJtT25Ccm93c2VyQXV0b2ZpbGwsIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCFjb25maXJtT25Ccm93c2VyQXV0b2ZpbGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcGFyZW50Rm9ybSA9IGZpbmRQYXJlbnRGb3JtKGlucHV0KTtcbiAgICBjb25zdCBmb3JtRWxlbWVudHMgPSBPYmplY3QudmFsdWVzKGZpbmRBZGRyZXNzQXV0b2ZpbGxJbnB1dHMocGFyZW50Rm9ybSwgaW5wdXQpKTtcbiAgICBpZiAoIWV2ZW50LmRldGFpbC5lbGVtZW50cy5zb21lKChlbCkgPT4gZm9ybUVsZW1lbnRzLmluY2x1ZGVzKGVsKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0dXJlID0gcGFyc2VGb3JtU3RydWN0dXJlKHBhcmVudEZvcm0pO1xuICAgIGNvbnN0IHN0cnVjdHVyZVJlZiA9IHN0cnVjdHVyZS5maW5kKChzKSA9PiBzLmlucHV0ID09PSBpbnB1dCk7XG4gICAgY29uc3QgYXV0b2ZpbGxJbnN0YW5jZVNlY3Rpb24gPSBzdHJ1Y3R1cmVSZWYuc2VjdGlvbjtcbiAgICBjb25zdCBicm93c2VyQXV0b2ZpbGxlZFNlY3Rpb25zID0gQXJyYXkuZnJvbShuZXcgU2V0KHN0cnVjdHVyZS5maWx0ZXIoKHMpID0+IGV2ZW50LmRldGFpbC5lbGVtZW50cy5pbmNsdWRlcyhzLmlucHV0KSkubWFwKChzKSA9PiBzLnNlY3Rpb24pKSk7XG4gICAgaWYgKCFicm93c2VyQXV0b2ZpbGxlZFNlY3Rpb25zLmluY2x1ZGVzKGF1dG9maWxsSW5zdGFuY2VTZWN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zU2VjdGlvbnMgPSB0eXBlb2YgY29uZmlybU9uQnJvd3NlckF1dG9maWxsID09PSBcIm9iamVjdFwiICYmIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbC5zZWN0aW9ucyB8fCBbXTtcbiAgICBpZiAob3B0aW9uc1NlY3Rpb25zLmxlbmd0aCAmJiAhb3B0aW9uc1NlY3Rpb25zLnNvbWUoKHNlY3Rpb24pID0+IGJyb3dzZXJBdXRvZmlsbGVkU2VjdGlvbnMuaW5jbHVkZXMoc2VjdGlvbikpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBvcHRpb25zQXJnID0gdHlwZW9mIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbCA9PT0gXCJvYmplY3RcIiA/IGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbCA6IHt9O1xuICAgIG9wdGlvbnNBcmcgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zQXJnKSwge1xuICAgICAgYWNjZXNzVG9rZW4sXG4gICAgICBzZWN0aW9uczogW2F1dG9maWxsSW5zdGFuY2VTZWN0aW9uXVxuICAgIH0pO1xuICAgIHlpZWxkIGNvbmZpcm1BZGRyZXNzKHBhcmVudEZvcm0sIG9wdGlvbnNBcmcpO1xuICB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbnRyaWJ1dGUudHNcbnZhciBDT05UUklCVVRFX0FQSV9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9jb250cmlidXRlLWFwaS5tYXBib3guY29tL3YxXCI7XG52YXIgQ09OVFJJQlVURV9BUElfU1RBR0lOR19CQVNFX1VSTCA9IFwiaHR0cHM6Ly9jb250cmlidXRlLWFwaS1zdGFnaW5nLnRpbGVzdHJlYW0ubmV0L3YxXCI7XG52YXIgRURJVF9TVUdHRVNUSU9OX0VORFBPSU5UID0gXCJlZGl0LXN1Z2dlc3Rpb25cIjtcbmZ1bmN0aW9uIHNlbmRGZWVkYmFjayhhY2Nlc3NUb2tlbiwgZmVlZGJhY2tBcmdzKSB7XG4gIGlmICghY29uZmlnLmZlZWRiYWNrRW5hYmxlZClcbiAgICByZXR1cm47XG4gIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICBjb25zdCBCQVNFX1VSTCA9IGlzTG9jYWxTZXJ2ZXIoaG9zdG5hbWUpIHx8IGlzTWFwYm94RG9tYWluKGhvc3RuYW1lKSA/IENPTlRSSUJVVEVfQVBJX1NUQUdJTkdfQkFTRV9VUkwgOiBDT05UUklCVVRFX0FQSV9CQVNFX1VSTDtcbiAgY29uc3QgdXJsID0gYCR7QkFTRV9VUkx9LyR7RURJVF9TVUdHRVNUSU9OX0VORFBPSU5UfS9hZGRyZXNzP2FjY2Vzc190b2tlbj0ke2FjY2Vzc1Rva2VufWA7XG4gIGNvbnN0IHsgb3JpZ2luYWxDb29yZGluYXRlLCBvcmlnaW5hbEFkZHJlc3MsIGNoYW5nZXMgfSA9IGZlZWRiYWNrQXJncztcbiAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICBhY3Rpb246IFwidXBkYXRlXCIsXG4gICAgcmVhc29uOiBcImluY29ycmVjdF9hZGRyZXNzXCIsXG4gICAgbG9jYXRpb246IHtcbiAgICAgIGxvbmdpdHVkZTogb3JpZ2luYWxDb29yZGluYXRlWzBdLFxuICAgICAgbGF0aXR1ZGU6IG9yaWdpbmFsQ29vcmRpbmF0ZVsxXVxuICAgIH0sXG4gICAgdXNlckVtYWlsOiBcIm5vLXJlcGx5LWF1dG9maWxsQG1hcGJveC5jb21cIixcbiAgICBjaGFuZ2VzLFxuICAgIHBsYWNlTmFtZTogb3JpZ2luYWxBZGRyZXNzXG4gIH07XG4gIGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoe1xuICAgICAgXCJVc2VyLUFnZW50XCI6IGBtYXBib3gtc2VhcmNoLWpzLiR7dmVyc2lvbn0uJHtuYXZpZ2F0b3IudXNlckFnZW50fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0pLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gIH0pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZS50c1xudmFyIFRFTVBMQVRFMiA9IGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGBcbjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25GZWF0dXJlXCI+XG4gICAgPGRpdiBjbGFzcz1cIk1vZGFsXCIgYXJpYS1tb2RhbD1cInRydWVcIiByb2xlPVwiZGlhbG9nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxIZWFkZXJcIj5cbiAgICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDE4IDE4XCIgY2xhc3M9XCJJY29uIEljb25RdWVzdGlvblwiPjwvc3ZnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxIZWFkZXJUaXRsZVwiPkRpZCB5b3UgbWVhbj88L2Rpdj5cbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMTggMThcIlxuICAgICAgICAgIGNsYXNzPVwiSWNvbiBJY29uQ2xvc2VcIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgdGl0bGU9XCJDbG9zZVwiXG4gICAgICAgICAgYXJpYS1sYWJlbD1cIkNsb3NlXCJcbiAgICAgICAgICBhcmlhLWV4cGFuZGVkPVwidHJ1ZVwiXG4gICAgICAgID48L3N2Zz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxBZGRyZXNzIE1vZGFsQWRkcmVzc0FwcHJvdmVcIj48L2Rpdj5cbiAgICAgICAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsTWFwXCI+XG4gICAgICAgIDxtYXBib3gtYWRkcmVzcy1taW5pbWFwIGNsYXNzPVwiTWluaW1hcFwiPjwvbWFwYm94LWFkZHJlc3MtbWluaW1hcD5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiQnV0dG9uIEJ1dHRvblByaW1hcnkgQnV0dG9uQXBwcm92ZVwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICBhcmlhLWxhYmVsPVwiWWVzXCJcbiAgICAgID5cbiAgICAgICAgWWVzXG4gICAgICA8L2Rpdj5cbiAgICAgIFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cIkJ1dHRvbiBCdXR0b25TZWNvbmRhcnkgQnV0dG9uUmVqZWN0XCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJObywgdXNlIHRoZSBhZGRyZXNzIEkgcHJvdmlkZWRcIlxuICAgICAgPlxuICAgICAgICBObywgdXNlIHRoZSBhZGRyZXNzIEkgcHJvdmlkZWRcbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxGb290ZXJcIj5cbiAgICAgICAgICBZb3VyIGNvbmZpcm1hdGlvbiBoZWxwcyBpbXByb3ZlIGFkZHJlc3MgZGF0YSBhY2N1cmFjeS5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5gKTtcbnZhciBfYmluZGluZzMsIF90aGVtZUludGVybmFsMywgX2ZlYXR1cmUsIF9mb3JtVmFsdWVzLCBfaGFuZGxlQ2xvc2UsIF9tb2RhbElELCBfbW9kYWxIZWFkZXJUaXRsZUlELCBfbW9kYWxBZGRyZXNzQXBwcm92ZUlEO1xudmFyIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb25GZWF0dXJlID0gY2xhc3MgZXh0ZW5kcyBIVE1MU2NvcGVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9iaW5kaW5nMywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3RoZW1lSW50ZXJuYWwzLCB7fSk7XG4gICAgdGhpcy5taW5pbWFwID0gZmFsc2U7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mZWF0dXJlLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZm9ybVZhbHVlcywgdm9pZCAwKTtcbiAgICB0aGlzLnVwZGF0ZSA9IChmZWF0dXJlLCBhdXRvZmlsbFZhbHVlcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9mZWF0dXJlLCBmZWF0dXJlKTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZm9ybVZhbHVlcywgYXV0b2ZpbGxWYWx1ZXMpO1xuICAgICAgY29uc3QgeyBNb2RhbE1hcCwgTWluaW1hcCwgTW9kYWxBZGRyZXNzQXBwcm92ZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMyk7XG4gICAgICBpZiAodGhpcy5taW5pbWFwKSB7XG4gICAgICAgIE1vZGFsTWFwLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgICBNaW5pbWFwLmFjY2Vzc1Rva2VuID0gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1pbmltYXAgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBjb25zdCB7IGRlZmF1bHRNYXBTdHlsZSwgdGhlbWUsIG1hcFN0eWxlTW9kZSwgc2F0ZWxsaXRlVG9nZ2xlIH0gPSB0aGlzLm1pbmltYXA7XG4gICAgICAgICAgZGVmYXVsdE1hcFN0eWxlICYmIChNaW5pbWFwLmRlZmF1bHRNYXBTdHlsZSA9IHRoaXMubWluaW1hcC5kZWZhdWx0TWFwU3R5bGUpO1xuICAgICAgICAgIHRoZW1lICYmIChNaW5pbWFwLnRoZW1lID0gdGhpcy5taW5pbWFwLnRoZW1lKTtcbiAgICAgICAgICBtYXBTdHlsZU1vZGUgJiYgKE1pbmltYXAubWFwU3R5bGVNb2RlID0gbWFwU3R5bGVNb2RlKTtcbiAgICAgICAgICBzYXRlbGxpdGVUb2dnbGUgIT09IHZvaWQgMCAmJiAoTWluaW1hcC5zYXRlbGxpdGVUb2dnbGUgPSBzYXRlbGxpdGVUb2dnbGUpO1xuICAgICAgICB9XG4gICAgICAgIE1pbmltYXAuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBNb2RhbE1hcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhcHByb3ZlQWRkcmVzcyA9IGZlYXR1cmUucHJvcGVydGllcy5wbGFjZV9uYW1lIHx8IGZlYXR1cmUucHJvcGVydGllcy5mdWxsX2FkZHJlc3MgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmFkZHJlc3M7XG4gICAgICBNb2RhbEFkZHJlc3NBcHByb3ZlLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICBNb2RhbEFkZHJlc3NBcHByb3ZlLmFwcGVuZENoaWxkKGNyZWF0ZUFkZHJlc3NFbGVtZW50KGF1dG9maWxsVmFsdWVzLCBhcHByb3ZlQWRkcmVzcywgZmVhdHVyZS5wcm9wZXJ0aWVzLmZlYXR1cmVfbmFtZSwgZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLCAoKF9hID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnBsYWNlX3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSkgPT09IFwic2Vjb25kYXJ5X2FkZHJlc3NcIikpO1xuICAgIH07XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVDbG9zZSwgKCkgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoXCJyZXN1bHRcIiwgXCJjYW5jZWxcIikpO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwcm92ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmVzdWx0XCIsIFwiY2hhbmdlXCIpKTtcbiAgICB9O1xuICAgIHRoaXMucmVqZWN0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoXCJyZXN1bHRcIiwgXCJub2NoYW5nZVwiKSk7XG4gICAgICBzZW5kRmVlZGJhY2sodGhpcy5hY2Nlc3NUb2tlbiwge1xuICAgICAgICBvcmlnaW5hbENvb3JkaW5hdGU6IF9fcHJpdmF0ZUdldCh0aGlzLCBfZmVhdHVyZSkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXG4gICAgICAgIG9yaWdpbmFsQWRkcmVzczogX19wcml2YXRlR2V0KHRoaXMsIF9mZWF0dXJlKS5wcm9wZXJ0aWVzLmZ1bGxfYWRkcmVzcyxcbiAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgIGFkZHJlc3M6IGdldEF1dG9maWxsU2VhcmNoVGV4dChfX3ByaXZhdGVHZXQodGhpcywgX2Zvcm1WYWx1ZXMpKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbW9kYWxJRCwgcmFuZG9tVmFsaWRJRCgpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21vZGFsSGVhZGVyVGl0bGVJRCwgcmFuZG9tVmFsaWRJRCgpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21vZGFsQWRkcmVzc0FwcHJvdmVJRCwgcmFuZG9tVmFsaWRJRCgpKTtcbiAgfVxuICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIFRFTVBMQVRFMjtcbiAgfVxuICBnZXQgdGVtcGxhdGVTdHlsZSgpIHtcbiAgICByZXR1cm4gc3R5bGVfZGVmYXVsdDtcbiAgfVxuICBnZXQgdGVtcGxhdGVVc2VyU3R5bGUoKSB7XG4gICAgcmV0dXJuIGdldFRoZW1lQ1NTKFwiLk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25GZWF0dXJlXCIsIHRoaXMudGhlbWUpO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF90aGVtZUludGVybmFsMyk7XG4gIH1cbiAgc2V0IHRoZW1lKHRoZW1lKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90aGVtZUludGVybmFsMywgdGhlbWUpO1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMykgfHwgIXRoZW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGVtcGxhdGVVc2VyU3R5bGUoZ2V0VGhlbWVDU1MoXCIuTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbkZlYXR1cmVcIiwgdGhlbWUpKTtcbiAgICBjb25zdCB7IEljb25RdWVzdGlvbiwgSWNvbkNsb3NlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmczKTtcbiAgICBJY29uUXVlc3Rpb24uaW5uZXJIVE1MID0gZ2V0SWNvbihcInF1ZXN0aW9uXCIsIHRoZW1lKTtcbiAgICBJY29uQ2xvc2UuaW5uZXJIVE1MID0gZ2V0SWNvbihcImNsb3NlXCIsIHRoZW1lKTtcbiAgfVxuICBzZXQgZm9vdGVyKHZhbCkge1xuICAgIGlmICh2YWwgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmb290ZXJFbCA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5Nb2RhbEZvb3RlclwiKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9vdGVyRWwudGV4dENvbnRlbnQgPSB2YWw7XG4gICAgICBmb290ZXJFbC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICB9IGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgIGZvb3RlckVsLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9vdGVyRWwucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9iaW5kaW5nMywgYmluZEVsZW1lbnRzKHRoaXMsIHtcbiAgICAgIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb25GZWF0dXJlOiBcIi5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZVwiLFxuICAgICAgTW9kYWw6IFwiLk1vZGFsXCIsXG4gICAgICBNb2RhbEhlYWRlclRpdGxlOiBcIi5Nb2RhbEhlYWRlclRpdGxlXCIsXG4gICAgICBNb2RhbE1hcDogXCIuTW9kYWxNYXBcIixcbiAgICAgIE1pbmltYXA6IFwiLk1pbmltYXBcIixcbiAgICAgIEljb25RdWVzdGlvbjogXCIuSWNvblF1ZXN0aW9uXCIsXG4gICAgICBJY29uQ2xvc2U6IFwiLkljb25DbG9zZVwiLFxuICAgICAgQnV0dG9uQXBwcm92ZTogXCIuQnV0dG9uQXBwcm92ZVwiLFxuICAgICAgQnV0dG9uUmVqZWN0OiBcIi5CdXR0b25SZWplY3RcIixcbiAgICAgIE1vZGFsQWRkcmVzc0FwcHJvdmU6IFwiLk1vZGFsQWRkcmVzc0FwcHJvdmVcIlxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBNb2RhbCxcbiAgICAgIE1vZGFsSGVhZGVyVGl0bGUsXG4gICAgICBJY29uQ2xvc2UsXG4gICAgICBCdXR0b25BcHByb3ZlLFxuICAgICAgQnV0dG9uUmVqZWN0LFxuICAgICAgTW9kYWxBZGRyZXNzQXBwcm92ZVxuICAgIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmczKTtcbiAgICBNb2RhbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbEhlYWRlclRpdGxlSUQpKTtcbiAgICBNb2RhbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbW9kYWxBZGRyZXNzQXBwcm92ZUlEKSk7XG4gICAgSWNvbkNsb3NlLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbElEKSk7XG4gICAgTW9kYWwuaWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsSUQpO1xuICAgIE1vZGFsSGVhZGVyVGl0bGUuaWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsSGVhZGVyVGl0bGVJRCk7XG4gICAgTW9kYWxBZGRyZXNzQXBwcm92ZS5pZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbW9kYWxBZGRyZXNzQXBwcm92ZUlEKTtcbiAgICBjb25zdCBidXR0b25zID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwiYnV0dG9uXCJdJykpO1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIGJ1dHRvbnMpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBhcmlhQnV0dG9uS2V5RG93bik7XG4gICAgfVxuICAgIEljb25DbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbG9zZSkpO1xuICAgIEJ1dHRvbkFwcHJvdmUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuYXBwcm92ZSk7XG4gICAgQnV0dG9uUmVqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnJlamVjdCk7XG4gICAgY29uc3QgdGhlbWUgPSB0aGlzLnRoZW1lO1xuICAgIGlmICh0aGVtZSkge1xuICAgICAgY29uc3QgeyBJY29uUXVlc3Rpb24sIEljb25DbG9zZTogSWNvbkNsb3NlMiB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMyk7XG4gICAgICBJY29uUXVlc3Rpb24uaW5uZXJIVE1MID0gZ2V0SWNvbihcInF1ZXN0aW9uXCIsIHRoZW1lKTtcbiAgICAgIEljb25DbG9zZTIuaW5uZXJIVE1MID0gZ2V0SWNvbihcImNsb3NlXCIsIHRoZW1lKTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29uc3QgeyBJY29uQ2xvc2UsIEJ1dHRvbkFwcHJvdmUgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzMpO1xuICAgIEljb25DbG9zZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbG9zZSkpO1xuICAgIEJ1dHRvbkFwcHJvdmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuYXBwcm92ZSk7XG4gIH1cbn07XG5fYmluZGluZzMgPSBuZXcgV2Vha01hcCgpO1xuX3RoZW1lSW50ZXJuYWwzID0gbmV3IFdlYWtNYXAoKTtcbl9mZWF0dXJlID0gbmV3IFdlYWtNYXAoKTtcbl9mb3JtVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVDbG9zZSA9IG5ldyBXZWFrTWFwKCk7XG5fbW9kYWxJRCA9IG5ldyBXZWFrTWFwKCk7XG5fbW9kYWxIZWFkZXJUaXRsZUlEID0gbmV3IFdlYWtNYXAoKTtcbl9tb2RhbEFkZHJlc3NBcHByb3ZlSUQgPSBuZXcgV2Vha01hcCgpO1xud2luZG93Lk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25GZWF0dXJlID0gTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbkZlYXR1cmU7XG5pZiAoIXdpbmRvdy5jdXN0b21FbGVtZW50cy5nZXQoXCJtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tZmVhdHVyZVwiKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tZmVhdHVyZVwiLCBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL01hcGJveEFkZHJlc3NDb25maXJtYXRpb25Ob0ZlYXR1cmUudHNcbnZhciBURU1QTEFURTMgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG48dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uTm9GZWF0dXJlXCI+XG4gICAgPGRpdiBjbGFzcz1cIk1vZGFsXCIgYXJpYS1tb2RhbD1cInRydWVcIiByb2xlPVwiZGlhbG9nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxIZWFkZXJcIj5cbiAgICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDE4IDE4XCIgY2xhc3M9XCJJY29uIEljb25RdWVzdGlvblwiPjwvc3ZnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxIZWFkZXJUaXRsZVwiPkNvbmZpcm0gYWRkcmVzczwvZGl2PlxuICAgICAgICA8c3ZnXG4gICAgICAgICAgdmlld0JveD1cIjAgMCAxOCAxOFwiXG4gICAgICAgICAgY2xhc3M9XCJJY29uIEljb25DbG9zZVwiXG4gICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICB0aXRsZT1cIkNsb3NlXCJcbiAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9XCJ0cnVlXCJcbiAgICAgICAgPjwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxEZXNjcmlwdGlvblwiPlxuICAgICAgICBXZSBjb3VsZG4ndCB2ZXJpZnkgdGhpcyBhZGRyZXNzLiBQbGVhc2UgY2hlY2sgdGhhdCB5b3VyIGluZm9ybWF0aW9uIGlzIGNvcnJlY3QgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICA8L2Rpdj5cbiAgICAgIDxiciAvPlxuICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsU3ViaGVhZGVyXCI+XG4gICAgICAgIFlvdSBlbnRlcmVkXG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJNb2RhbEFkZHJlc3NcIj48L2Rpdj5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJCdXR0b24gQnV0dG9uUHJpbWFyeVwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICBhcmlhLWxhYmVsPVwiVXNlIHRoZSBhZGRyZXNzIEkgcHJvdmlkZWRcIlxuICAgICAgPlxuICAgICAgICBVc2UgdGhlIGFkZHJlc3MgSSBwcm92aWRlZFxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIF9iaW5kaW5nNCwgX3RoZW1lSW50ZXJuYWw0LCBfaGFuZGxlQ2xvc2UyLCBfbW9kYWxJRDIsIF9tb2RhbEhlYWRlclRpdGxlSUQyLCBfbW9kYWxBZGRyZXNzSUQ7XG52YXIgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbk5vRmVhdHVyZSA9IGNsYXNzIGV4dGVuZHMgSFRNTFNjb3BlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYmluZGluZzQsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90aGVtZUludGVybmFsNCwge30pO1xuICAgIHRoaXMudXBkYXRlID0gKGF1dG9maWxsVmFsdWVzKSA9PiB7XG4gICAgICBjb25zdCB7IE1vZGFsQWRkcmVzcyB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNCk7XG4gICAgICBNb2RhbEFkZHJlc3MuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIE1vZGFsQWRkcmVzcy5hcHBlbmRDaGlsZChjcmVhdGVBZGRyZXNzRWxlbWVudChhdXRvZmlsbFZhbHVlcykpO1xuICAgIH07XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVDbG9zZTIsICgpID0+IHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmVzdWx0XCIsIFwiY2FuY2VsXCIpKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlamVjdCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmVzdWx0XCIsIFwibm9jaGFuZ2VcIikpO1xuICAgIH07XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tb2RhbElEMiwgcmFuZG9tVmFsaWRJRCgpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21vZGFsSGVhZGVyVGl0bGVJRDIsIHJhbmRvbVZhbGlkSUQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tb2RhbEFkZHJlc3NJRCwgcmFuZG9tVmFsaWRJRCgpKTtcbiAgfVxuICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIFRFTVBMQVRFMztcbiAgfVxuICBnZXQgdGVtcGxhdGVTdHlsZSgpIHtcbiAgICByZXR1cm4gc3R5bGVfZGVmYXVsdDtcbiAgfVxuICBnZXQgdGVtcGxhdGVVc2VyU3R5bGUoKSB7XG4gICAgcmV0dXJuIGdldFRoZW1lQ1NTKFwiLk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25Ob0ZlYXR1cmVcIiwgdGhpcy50aGVtZSk7XG4gIH1cbiAgZ2V0IHRoZW1lKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3RoZW1lSW50ZXJuYWw0KTtcbiAgfVxuICBzZXQgdGhlbWUodGhlbWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3RoZW1lSW50ZXJuYWw0LCB0aGVtZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc0KSB8fCAhdGhlbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUZW1wbGF0ZVVzZXJTdHlsZShnZXRUaGVtZUNTUyhcIi5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uTm9GZWF0dXJlXCIsIHRoZW1lKSk7XG4gICAgY29uc3QgeyBJY29uUXVlc3Rpb24sIEljb25DbG9zZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNCk7XG4gICAgSWNvblF1ZXN0aW9uLmlubmVySFRNTCA9IGdldEljb24oXCJxdWVzdGlvblwiLCB0aGVtZSk7XG4gICAgSWNvbkNsb3NlLmlubmVySFRNTCA9IGdldEljb24oXCJjbG9zZVwiLCB0aGVtZSk7XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2JpbmRpbmc0LCBiaW5kRWxlbWVudHModGhpcywge1xuICAgICAgTW9kYWw6IFwiLk1vZGFsXCIsXG4gICAgICBNb2RhbEhlYWRlclRpdGxlOiBcIi5Nb2RhbEhlYWRlclRpdGxlXCIsXG4gICAgICBJY29uUXVlc3Rpb246IFwiLkljb25RdWVzdGlvblwiLFxuICAgICAgSWNvbkNsb3NlOiBcIi5JY29uQ2xvc2VcIixcbiAgICAgIE1vZGFsQWRkcmVzczogXCIuTW9kYWxBZGRyZXNzXCIsXG4gICAgICBCdXR0b25SZWplY3Q6IFwiLkJ1dHRvblwiXG4gICAgfSkpO1xuICAgIGNvbnN0IHsgTW9kYWwsIE1vZGFsSGVhZGVyVGl0bGUsIEljb25DbG9zZSwgTW9kYWxBZGRyZXNzLCBCdXR0b25SZWplY3QgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzQpO1xuICAgIE1vZGFsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsSGVhZGVyVGl0bGVJRDIpKTtcbiAgICBNb2RhbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbW9kYWxBZGRyZXNzSUQpKTtcbiAgICBJY29uQ2xvc2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsSUQyKSk7XG4gICAgTW9kYWwuaWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsSUQyKTtcbiAgICBNb2RhbEhlYWRlclRpdGxlLmlkID0gX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbEhlYWRlclRpdGxlSUQyKTtcbiAgICBNb2RhbEFkZHJlc3MuaWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsQWRkcmVzc0lEKTtcbiAgICBjb25zdCBidXR0b25zID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwiYnV0dG9uXCJdJykpO1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIGJ1dHRvbnMpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBhcmlhQnV0dG9uS2V5RG93bik7XG4gICAgfVxuICAgIEljb25DbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbG9zZTIpKTtcbiAgICBCdXR0b25SZWplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMucmVqZWN0KTtcbiAgICBjb25zdCB0aGVtZSA9IHRoaXMudGhlbWU7XG4gICAgaWYgKHRoZW1lKSB7XG4gICAgICBjb25zdCB7IEljb25RdWVzdGlvbiwgSWNvbkNsb3NlOiBJY29uQ2xvc2UyIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc0KTtcbiAgICAgIEljb25RdWVzdGlvbi5pbm5lckhUTUwgPSBnZXRJY29uKFwicXVlc3Rpb25cIiwgdGhlbWUpO1xuICAgICAgSWNvbkNsb3NlMi5pbm5lckhUTUwgPSBnZXRJY29uKFwiY2xvc2VcIiwgdGhlbWUpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25zdCB7IEljb25DbG9zZSwgQnV0dG9uUmVqZWN0IH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc0KTtcbiAgICBJY29uQ2xvc2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQ2xvc2UyKSk7XG4gICAgQnV0dG9uUmVqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnJlamVjdCk7XG4gIH1cbn07XG5fYmluZGluZzQgPSBuZXcgV2Vha01hcCgpO1xuX3RoZW1lSW50ZXJuYWw0ID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVDbG9zZTIgPSBuZXcgV2Vha01hcCgpO1xuX21vZGFsSUQyID0gbmV3IFdlYWtNYXAoKTtcbl9tb2RhbEhlYWRlclRpdGxlSUQyID0gbmV3IFdlYWtNYXAoKTtcbl9tb2RhbEFkZHJlc3NJRCA9IG5ldyBXZWFrTWFwKCk7XG53aW5kb3cuTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbk5vRmVhdHVyZSA9IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb25Ob0ZlYXR1cmU7XG5pZiAoIXdpbmRvdy5jdXN0b21FbGVtZW50cy5nZXQoXCJtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tbm8tZmVhdHVyZVwiKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tbm8tZmVhdHVyZVwiLCBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uTm9GZWF0dXJlKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94QWRkcmVzc0F1dG9maWxsLnRzXG5pbXBvcnQge1xuICBBZGRyZXNzQXV0b2ZpbGxDb3JlLFxuICBTZWFyY2hTZXNzaW9uXG59IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG5cbi8vIHNyYy91dGlscy9kZXRlY3RfYnJvd3Nlcl9hdXRvZmlsbC50c1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tIFwiQG1hcGJveC9zZWFyY2gtanMtY29yZVwiO1xuXG4vLyBzcmMvdXRpbHMvZGV0ZWN0X2Jyb3dzZXJfYXV0b2ZpbGwuY3NzXG52YXIgZGV0ZWN0X2Jyb3dzZXJfYXV0b2ZpbGxfZGVmYXVsdCA9ICdpbnB1dDotd2Via2l0LWF1dG9maWxsLHNlbGVjdDotd2Via2l0LWF1dG9maWxsLHRleHRhcmVhOi13ZWJraXQtYXV0b2ZpbGx7YW5pbWF0aW9uLW5hbWU6b25icm93c2VyYXV0b2ZpbGxzdGFydH1pbnB1dDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLHNlbGVjdDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLHRleHRhcmVhOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCl7YW5pbWF0aW9uLW5hbWU6b25icm93c2VyYXV0b2ZpbGxjYW5jZWx9QGtleWZyYW1lcyBvbmJyb3dzZXJhdXRvZmlsbHN0YXJ0ezAle2FuaW1hdGlvbi1uYW1lOlwib25icm93c2VyYXV0b2ZpbGxzdGFydFwifXRve2FuaW1hdGlvbi1uYW1lOlwib25icm93c2VyYXV0b2ZpbGxzdGFydFwifX1Aa2V5ZnJhbWVzIG9uYnJvd3NlcmF1dG9maWxsY2FuY2VsezAle2FuaW1hdGlvbi1uYW1lOlwib25icm93c2VyYXV0b2ZpbGxjYW5jZWxcIn10b3thbmltYXRpb24tbmFtZTpcIm9uYnJvd3NlcmF1dG9maWxsY2FuY2VsXCJ9fSc7XG5cbi8vIHNyYy91dGlscy9kZXRlY3RfYnJvd3Nlcl9hdXRvZmlsbC50c1xudmFyIEFUVFJfTkFNRSA9IFwiYnJvd3Nlci1hdXRvZmlsbGVkXCI7XG52YXIgQVVUT0ZJTExFRF9FTEVNRU5UUyA9IFtdO1xuZnVuY3Rpb24gZGlzcGF0Y2hCcm93c2VyQXV0b2ZpbGxFdmVudCgpIHtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IHdpbmRvdy5DdXN0b21FdmVudChcImJyb3dzZXJhdXRvZmlsbFwiLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIGRldGFpbDogeyBlbGVtZW50czogQVVUT0ZJTExFRF9FTEVNRU5UUyB9XG4gIH0pKTtcbiAgQVVUT0ZJTExFRF9FTEVNRU5UUyA9IFtdO1xufVxudmFyIGRlYm91bmNlZEF1dG9maWxsID0gZGVib3VuY2UoZGlzcGF0Y2hCcm93c2VyQXV0b2ZpbGxFdmVudCwgNSk7XG5mdW5jdGlvbiBicm93c2VyQXV0b2ZpbGwoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSlcbiAgICByZXR1cm47XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFUVFJfTkFNRSwgXCJcIik7XG4gIEFVVE9GSUxMRURfRUxFTUVOVFMucHVzaChlbGVtZW50KTtcbiAgZGVib3VuY2VkQXV0b2ZpbGwoKTtcbn1cbmZ1bmN0aW9uIGNhbmNlbEJyb3dzZXJBdXRvZmlsbChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSlcbiAgICByZXR1cm47XG4gIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKEFUVFJfTkFNRSk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblN0YXJ0KGV2ZW50KSB7XG4gIGV2ZW50LmFuaW1hdGlvbk5hbWUgPT09IFwib25icm93c2VyYXV0b2ZpbGxzdGFydFwiID8gYnJvd3NlckF1dG9maWxsKGV2ZW50LnRhcmdldCkgOiBjYW5jZWxCcm93c2VyQXV0b2ZpbGwoZXZlbnQudGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIG9uSW5wdXQoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0RWwgPSBldmVudC50YXJnZXQ7XG4gIHRhcmdldEVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwic2VsZWN0XCIgJiYgIWV2ZW50LnNpbXVsYXRlZCAmJiAhKGV2ZW50IGluc3RhbmNlb2YgTWFwYm94SFRNTEV2ZW50KSAmJiAoZXZlbnQuaW5wdXRUeXBlID09PSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiIHx8ICEoXCJkYXRhXCIgaW4gZXZlbnQpKSA/IGJyb3dzZXJBdXRvZmlsbCh0YXJnZXRFbCkgOiBjYW5jZWxCcm93c2VyQXV0b2ZpbGwodGFyZ2V0RWwpO1xufVxuZnVuY3Rpb24gaW5pdERldGVjdEJyb3dzZXJBdXRvZmlsbCgpIHtcbiAgaWYgKGNvbmZpZy5kZXRlY3RCcm93c2VyQXV0b2ZpbGxFbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5kZXRlY3RCcm93c2VyQXV0b2ZpbGxFbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBhZGREb2N1bWVudFN0eWxlKGRldGVjdF9icm93c2VyX2F1dG9maWxsX2RlZmF1bHQpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc3RhcnRcIiwgb25BbmltYXRpb25TdGFydCwgdHJ1ZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBvbklucHV0LCB0cnVlKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94QWRkcmVzc0F1dG9maWxsLnRzXG52YXIgX2F1dG9maWxsLCBfc2Vzc2lvbiwgX2lucHV0LCBfbGlzdGJveCwgX2luaXRpYWxBdXRvY29tcGxldGVWYWx1ZSwgX2Jyb3dzZXJBdXRvZmlsbEVuYWJsZWQsIF9oYW5kbGVTdWdnZXN0LCBfaGFuZGxlU3VnZ2VzdEVycm9yLCBfaGFuZGxlUmV0cmlldmUsIF9oYW5kbGVPYnNlcnZlLCBfb2JzZXJ2ZXIsIF9oYW5kbGVCcm93c2VyQXV0b2ZpbGwsIF9vbkhhbmRsZUlucHV0LCBfb25IYW5kbGVTZWxlY3QsIF9vbkhhbmRsZUJsdXIsIF9vbkhhbmRsZUZvY3VzO1xudmFyIE1hcGJveEFkZHJlc3NBdXRvZmlsbCA9IGNsYXNzIGV4dGVuZHMgSFRNTFNjb3BlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYXV0b2ZpbGwsIG5ldyBBZGRyZXNzQXV0b2ZpbGxDb3JlKCkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2Vzc2lvbiwgbmV3IFNlYXJjaFNlc3Npb24oX19wcml2YXRlR2V0KHRoaXMsIF9hdXRvZmlsbCkpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lucHV0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGlzdGJveCwgbmV3IE1hcGJveFNlYXJjaExpc3Rib3goKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9pbml0aWFsQXV0b2NvbXBsZXRlVmFsdWUsIHZvaWQgMCk7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPSBmYWxzZTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Jyb3dzZXJBdXRvZmlsbEVuYWJsZWQsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVN1Z2dlc3QsIChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkU3VnZ2VzdGlvbnMgPSAocmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiByZXN1bHQuc3VnZ2VzdGlvbnMpID8gZGlzdGluY3RFeGFjdFN0cmVldFJlc3VsdHMocmVzdWx0LnN1Z2dlc3Rpb25zKSA6IG51bGw7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmhhbmRsZVN1Z2dlc3QoZmlsdGVyZWRTdWdnZXN0aW9ucyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChcInN1Z2dlc3RcIiwgcmVzdWx0KSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3IsIChlcnJvcikgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5oYW5kbGVFcnJvcigpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoXCJzdWdnZXN0ZXJyb3JcIiwgZXJyb3IpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVJldHJpZXZlLCAocmVzdWx0KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChcInJldHJpZXZlXCIsIHJlc3VsdCkpO1xuICAgICAgdGhpcy5yZXRyaWV2ZUZlYXR1cmUgPSAoX2EgPSByZXN1bHQuZmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXN1bHQ7XG4gICAgICBpZiAoIWZlYXR1cmVDb2xsZWN0aW9uIHx8ICFmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcyB8fCAhZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZpbGxGb3JtV2l0aEZlYXR1cmUoZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbMF0sIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZU9ic2VydmUsICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gKF9hID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW5wdXQsIGlucHV0KTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5pbnB1dCA9IGlucHV0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lucHV0LCBudWxsKTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5pbnB1dCA9IG51bGw7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlIHx8IGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb2JzZXJ2ZXIsIG5ldyBNdXRhdGlvbk9ic2VydmVyKF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlT2JzZXJ2ZSkpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUJyb3dzZXJBdXRvZmlsbCwgKGUpID0+IHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkuYmx1cigpO1xuICAgICAgdHJ5Q29uZmlybUJyb3dzZXJBdXRvZmlsbChfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0KSwgZSwgdGhpcy5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwsIHRoaXMuYWNjZXNzVG9rZW4pO1xuICAgIH0pO1xuICAgIHRoaXMucmV0cmlldmVGZWF0dXJlID0gbnVsbDtcbiAgICB0aGlzLmludGVyY2VwdFNlYXJjaCA9IG51bGw7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vbkhhbmRsZUlucHV0LCAoZSkgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUuY2xvbmUoKSk7XG4gICAgICBjb25zdCBpbnB1dFRleHQgPSBlLmRldGFpbDtcbiAgICAgIGNvbnN0IGVuYWJsZUJyb3dzZXJBdXRvY29tcGxldGUgPSB0aGlzLmJyb3dzZXJBdXRvZmlsbEVuYWJsZWQgPT09IHRydWUgJiYgKGlucHV0VGV4dCA9PSBudWxsID8gdm9pZCAwIDogaW5wdXRUZXh0Lmxlbmd0aCkgPD0gMjtcbiAgICAgIHRvZ2dsZUF1dG9jb21wbGV0aW9uKF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQpLCBfX3ByaXZhdGVHZXQodGhpcywgX2luaXRpYWxBdXRvY29tcGxldGVWYWx1ZSksIGVuYWJsZUJyb3dzZXJBdXRvY29tcGxldGUpO1xuICAgICAgY29uc3QgYWx0ZXJlZFRleHQgPSB0aGlzLmludGVyY2VwdFNlYXJjaCAmJiB0aGlzLmludGVyY2VwdFNlYXJjaChpbnB1dFRleHQpO1xuICAgICAgY29uc3Qgc2VhcmNoVGV4dCA9IHRoaXMuaW50ZXJjZXB0U2VhcmNoID8gYWx0ZXJlZFRleHQgOiBpbnB1dFRleHQ7XG4gICAgICBpZiAodGhpcy5pbnRlcmNlcHRTZWFyY2ggJiYgIWFsdGVyZWRUZXh0IHx8IChzZWFyY2hUZXh0ID09IG51bGwgPyB2b2lkIDAgOiBzZWFyY2hUZXh0Lmxlbmd0aCkgPD0gMikge1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmhhbmRsZVN1Z2dlc3QobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbikuc3VnZ2VzdChzZWFyY2hUZXh0LCB0aGlzLm9wdGlvbnMpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25IYW5kbGVTZWxlY3QsIChlKSA9PiB7XG4gICAgICBjb25zdCBzdWdnZXN0aW9uID0gZS5kZXRhaWw7XG4gICAgICBpZiAoZS5kZXRhaWwuYWNjdXJhY3kgIT09IFwic3RyZWV0XCIpIHtcbiAgICAgICAgdG9nZ2xlQXV0b2NvbXBsZXRpb24oX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbikucmV0cmlldmUoc3VnZ2VzdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVN0cmVldFNlbGVjdGlvbihfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0KSwgX19wcml2YXRlR2V0KHRoaXMsIF9pbml0aWFsQXV0b2NvbXBsZXRlVmFsdWUpLCBzdWdnZXN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uSGFuZGxlQmx1ciwgKCkgPT4ge1xuICAgICAgdG9nZ2xlQXV0b2NvbXBsZXRpb24oX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlKSwgdHJ1ZSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24pLmFib3J0KCk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vbkhhbmRsZUZvY3VzLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBlbmFibGVCcm93c2VyQXV0b2NvbXBsZXRlID0gdGhpcy5icm93c2VyQXV0b2ZpbGxFbmFibGVkID09PSB0cnVlICYmICgoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0KS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPD0gMjtcbiAgICAgIHRvZ2dsZUF1dG9jb21wbGV0aW9uKF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQpLCBfX3ByaXZhdGVHZXQodGhpcywgX2luaXRpYWxBdXRvY29tcGxldGVWYWx1ZSksIGVuYWJsZUJyb3dzZXJBdXRvY29tcGxldGUpO1xuICAgIH0pO1xuICB9XG4gIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9hdXRvZmlsbCkuYWNjZXNzVG9rZW47XG4gIH1cbiAgc2V0IGFjY2Vzc1Rva2VuKG5ld1Rva2VuKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9hdXRvZmlsbCkuYWNjZXNzVG9rZW4gPSBuZXdUb2tlbjtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQpO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS50aGVtZTtcbiAgfVxuICBzZXQgdGhlbWUodGhlbWUpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLnRoZW1lID0gdGhlbWU7XG4gIH1cbiAgZ2V0IHBvcG92ZXJPcHRpb25zKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLnBvcG92ZXJPcHRpb25zO1xuICB9XG4gIHNldCBwb3BvdmVyT3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5wb3BvdmVyT3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gIH1cbiAgZ2V0IGJyb3dzZXJBdXRvZmlsbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfYnJvd3NlckF1dG9maWxsRW5hYmxlZCk7XG4gIH1cbiAgc2V0IGJyb3dzZXJBdXRvZmlsbEVuYWJsZWQoZW5hYmxlKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9icm93c2VyQXV0b2ZpbGxFbmFibGVkLCBlbmFibGUpO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBfYTtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIGNvbmZpZy5hdXRvZmlsbFNlc3Npb25FbmFibGVkID0gdHJ1ZTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24pLnNlc3Npb25Ub2tlbiA9IGNvbmZpZy5hdXRvZmlsbFNlc3Npb25Ub2tlbjtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmF1dG9maWxsSG9zdCA9IHRoaXM7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5zZWFyY2hTZXJ2aWNlID0gMCAvKiBBZGRyZXNzQXV0b2ZpbGwgKi87XG4gICAgY29uc3QgaW5wdXQgPSAoX2EgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKSkgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX29ic2VydmVyKS5vYnNlcnZlKHRoaXMsIHtcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZU9ic2VydmUpLmNhbGwodGhpcyk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZUlucHV0KSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVTZWxlY3QpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVCbHVyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZUZvY3VzKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uKS5hZGRFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3QpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24pLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3IpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24pLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVJldHJpZXZlKSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpKTtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0Lmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWJlZ2luXCIsIGNyZWF0ZUFyaWFMaXZlRWxlbWVudChfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmRhdGFTZWVkKSk7XG4gICAgICBzdXBwcmVzc0V4dGVuc2lvbnNBdXRvY29tcGxldGUoaW5wdXQpO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9pbml0aWFsQXV0b2NvbXBsZXRlVmFsdWUsIGlucHV0LmF1dG9jb21wbGV0ZSk7XG4gICAgfVxuICAgIGluaXREZXRlY3RCcm93c2VyQXV0b2ZpbGwoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJyb3dzZXJhdXRvZmlsbFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUJyb3dzZXJBdXRvZmlsbCkpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkucmVtb3ZlKCk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZUlucHV0KSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVTZWxlY3QpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVCbHVyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZUZvY3VzKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3QpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24pLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3IpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24pLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVJldHJpZXZlKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9vYnNlcnZlcikuZGlzY29ubmVjdCgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYnJvd3NlcmF1dG9maWxsXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQnJvd3NlckF1dG9maWxsKSk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcImFjY2Vzcy10b2tlblwiKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2F1dG9maWxsKS5hY2Nlc3NUb2tlbiA9IG5ld1ZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJicm93c2VyLWF1dG9maWxsLWVuYWJsZWRcIikge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9icm93c2VyQXV0b2ZpbGxFbmFibGVkLCBCb29sZWFuKG5ld1ZhbHVlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInRoZW1lXCIpIHtcbiAgICAgIHRoaXMudGhlbWUgPSB0cnlQYXJzZUpTT04obmV3VmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJwb3BvdmVyLW9wdGlvbnNcIikge1xuICAgICAgdGhpcy5wb3BvdmVyT3B0aW9ucyA9IHRyeVBhcnNlSlNPTihuZXdWYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBuYW1lLnNwbGl0KFwiLVwiKS5qb2luKFwiX1wiKTtcbiAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICBkZWxldGUgdGhpcy5vcHRpb25zW29wdGlvbk5hbWVdO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnNbb3B0aW9uTmFtZV0gPSBuZXdWYWx1ZTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmZvY3VzKCk7XG4gIH1cbiAgc2ltdWxhdGVSZXRyaWV2ZShmZWF0dXJlKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgaW5wdXQuZGF0YXNldFtcIm1hcGJveFN1Y2Nlc3NcIl0gPSBcInRydWVcIjtcbiAgICB9XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5oaWRlUmVzdWx0cygpO1xuICAgIGNvbnN0IHNpbVJlc3VsdCA9IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGZlYXR1cmVzOiBbZmVhdHVyZV0sXG4gICAgICB1cmw6IFwiXCJcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlUmV0cmlldmUpLmNhbGwodGhpcywgc2ltUmVzdWx0KTtcbiAgfVxufTtcbl9hdXRvZmlsbCA9IG5ldyBXZWFrTWFwKCk7XG5fc2Vzc2lvbiA9IG5ldyBXZWFrTWFwKCk7XG5faW5wdXQgPSBuZXcgV2Vha01hcCgpO1xuX2xpc3Rib3ggPSBuZXcgV2Vha01hcCgpO1xuX2luaXRpYWxBdXRvY29tcGxldGVWYWx1ZSA9IG5ldyBXZWFrTWFwKCk7XG5fYnJvd3NlckF1dG9maWxsRW5hYmxlZCA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU3VnZ2VzdCA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU3VnZ2VzdEVycm9yID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVSZXRyaWV2ZSA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlT2JzZXJ2ZSA9IG5ldyBXZWFrTWFwKCk7XG5fb2JzZXJ2ZXIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUJyb3dzZXJBdXRvZmlsbCA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVJbnB1dCA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVTZWxlY3QgPSBuZXcgV2Vha01hcCgpO1xuX29uSGFuZGxlQmx1ciA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVGb2N1cyA9IG5ldyBXZWFrTWFwKCk7XG5NYXBib3hBZGRyZXNzQXV0b2ZpbGwub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gW1xuICBcImFjY2Vzcy10b2tlblwiLFxuICBcImJyb3dzZXItYXV0b2ZpbGwtZW5hYmxlZFwiLFxuICBcInRoZW1lXCIsXG4gIFwicG9wb3Zlci1vcHRpb25zXCIsXG4gIFwiY3NzLXRleHRcIixcbiAgXCJsYW5ndWFnZVwiLFxuICBcImNvdW50cnlcIixcbiAgXCJiYm94XCIsXG4gIFwibGltaXRcIixcbiAgXCJwcm94aW1pdHlcIixcbiAgXCJzdHJlZXRzXCJcbl07XG53aW5kb3cuTWFwYm94QWRkcmVzc0F1dG9maWxsID0gTWFwYm94QWRkcmVzc0F1dG9maWxsO1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LWFkZHJlc3MtYXV0b2ZpbGxcIikpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWFwYm94LWFkZHJlc3MtYXV0b2ZpbGxcIiwgTWFwYm94QWRkcmVzc0F1dG9maWxsKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94U2VhcmNoQm94LnRzXG5pbXBvcnQge1xuICBmZWF0dXJlVG9TdWdnZXN0aW9uIGFzIGZlYXR1cmVUb1N1Z2dlc3Rpb24zLFxuICBMbmdMYXRCb3VuZHMsXG4gIFNlYXJjaFNlc3Npb24gYXMgU2VhcmNoU2Vzc2lvbjIsXG4gIFNlYXJjaEJveENvcmVcbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbmltcG9ydCBzdWJ0YWcgZnJvbSBcInN1YnRhZ1wiO1xuXG4vLyBzcmMvdXRpbHMvbG9jYWxpemF0aW9uLnRzXG52YXIgcGxhY2Vob2xkZXIgPSB7XG4gIGRlOiBcIlN1Y2hlXCIsXG4gIGl0OiBcIlJpY2VyY2FcIixcbiAgZW46IFwiU2VhcmNoXCIsXG4gIG5sOiBcIlpvZWtlblwiLFxuICBmcjogXCJDaGVyY2hlclwiLFxuICBjYTogXCJDZXJjYVwiLFxuICBoZTogXCJcXHUwNURDXFx1MDVEN1xcdTA1RTRcXHUwNUU5XCIsXG4gIGphOiBcIlxcdTMwQjVcXHUzMEZDXFx1MzBDMVwiLFxuICBsdjogXCJNZWtsXFx1MDExM3RcIixcbiAgcHQ6IFwiUHJvY3VyYXJcIixcbiAgc3I6IFwiXFx1MDQxRlxcdTA0NDBcXHUwNDM1XFx1MDQ0MlxcdTA0NDBcXHUwNDMwXFx1MDQzM1xcdTA0MzBcIixcbiAgemg6IFwiXFx1NjQxQ1xcdTdEMjJcIixcbiAgY3M6IFwiVnlobGVkXFx4RTF2XFx4RTFuXFx4RURcIixcbiAgaHU6IFwiS2VyZXNcXHhFOXNcIixcbiAga2E6IFwiXFx1MTBFQlxcdTEwRDhcXHUxMEQ0XFx1MTBEMVxcdTEwRDBcIixcbiAgbmI6IFwiU1xceEY4a2VcIixcbiAgc2s6IFwiVnloXFx1MDEzRWFkXFx4RTF2YW5pZVwiLFxuICB0aDogXCJcXHUwRTA0XFx1MEU0OVxcdTBFMTlcXHUwRTJCXFx1MEUzMlwiLFxuICBmaTogXCJIYWVcIixcbiAgaXM6IFwiTGVpdGFcIixcbiAga286IFwiXFx1QzIxOFxcdUMwQzlcIixcbiAgcGw6IFwiU3p1a2FqXCIsXG4gIHNsOiBcIklza2FuamVcIixcbiAgZmE6IFwiXFx1MDYyQ1xcdTA2MzNcXHUwNjJBXFx1MDYyQ1xcdTA2NDhcIixcbiAgcnU6IFwiXFx1MDQxRlxcdTA0M0VcXHUwNDM4XFx1MDQ0MVxcdTA0M0FcIlxufTtcbnZhciBsb2NhbGl6YXRpb25fZGVmYXVsdCA9IHsgcGxhY2Vob2xkZXIgfTtcblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94U2VhcmNoQm94LnRzXG52YXIgTUFYX1pPT00gPSA5O1xudmFyIF9iaW5kaW5nNSwgX3NlYXJjaCwgX3Nlc3Npb24yLCBfbWFwLCBfaW5wdXQyLCBfbGlzdGJveDIsIF9nZXREZWZhdWx0UGxhY2Vob2xkZXIsIGdldERlZmF1bHRQbGFjZWhvbGRlcl9mbiwgX3BsYWNlaG9sZGVyLCBfaGFuZGxlU3VnZ2VzdDIsIF9oYW5kbGVTdWdnZXN0RXJyb3IyLCBfaGFuZGxlUmV0cmlldmUyLCBfbWFwTWFya2VyLCBfcmVtb3ZlTWFya2VyLCBfaGFuZGxlTWFya2VyLCBfb25IYW5kbGVJbnB1dDIsIF9vbkhhbmRsZVNlbGVjdDIsIF9vbkhhbmRsZUJsdXIyLCBfc2V0QWN0aW9uSWNvbnMsIF9oYW5kbGVDbGVhciwgX2hhbmRsZU1vdmVFbmQ7XG52YXIgTWFwYm94U2VhcmNoQm94ID0gY2xhc3MgZXh0ZW5kcyBIVE1MU2NvcGVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXREZWZhdWx0UGxhY2Vob2xkZXIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYmluZGluZzUsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZWFyY2gsIG5ldyBTZWFyY2hCb3hDb3JlKHt9KSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXNzaW9uMiwgbmV3IFNlYXJjaFNlc3Npb24yKF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VhcmNoKSkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWFwLCBudWxsKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lucHV0Miwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2xpc3Rib3gyLCBuZXcgTWFwYm94U2VhcmNoTGlzdGJveCgpKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3BsYWNlaG9sZGVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3VnZ2VzdDIsIChyZXN1bHQpID0+IHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2V0QWN0aW9uSWNvbnMpLmNhbGwodGhpcyk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5oYW5kbGVTdWdnZXN0KChyZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3VsdC5zdWdnZXN0aW9ucykgfHwgbnVsbCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChcInN1Z2dlc3RcIiwgcmVzdWx0KSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3IyLCAoZXJyb3IpID0+IHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2V0QWN0aW9uSWNvbnMpLmNhbGwodGhpcyk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5oYW5kbGVFcnJvcigpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoXCJzdWdnZXN0ZXJyb3JcIiwgZXJyb3IpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVJldHJpZXZlMiwgKHJlc3VsdCkgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXRBY3Rpb25JY29ucykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmV0cmlldmVcIiwgcmVzdWx0KSk7XG4gICAgICBjb25zdCBmZWF0dXJlQ29sbGVjdGlvbiA9IHJlc3VsdDtcbiAgICAgIGlmICghZmVhdHVyZUNvbGxlY3Rpb24gfHwgIWZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdWdnZXN0aW9uID0gZmVhdHVyZVRvU3VnZ2VzdGlvbjMoZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbMF0pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDIpLnZhbHVlID0gc3VnZ2VzdGlvbi5uYW1lO1xuICAgICAgY29uc3QgbWFwID0gX19wcml2YXRlR2V0KHRoaXMsIF9tYXApO1xuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzWzBdO1xuICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlVHlwZSA9IGZlYXR1cmUucHJvcGVydGllcy5mZWF0dXJlX3R5cGU7XG4gICAgICBjb25zdCBib3VuZHMgPSBmZWF0dXJlLnByb3BlcnRpZXMuYmJveDtcbiAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgbWFwLmZseVRvKGJib3hWaWV3cG9ydChtYXAsIExuZ0xhdEJvdW5kcy5jb252ZXJ0KGJvdW5kcykudG9GbGF0QXJyYXkoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgY29uc3Qgem9vbSA9IGdldE1heFpvb20ocGxhY2VUeXBlKTtcbiAgICAgICAgbWFwLmZseVRvKHtcbiAgICAgICAgICBjZW50ZXIsXG4gICAgICAgICAgem9vbSxcbiAgICAgICAgICBzcGVlZDogRkxZX1RPX1NQRUVEXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWFya2VyICYmIHRoaXMubWFwYm94Z2wpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVNYXJrZXIpLmNhbGwodGhpcywgZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tYXBNYXJrZXIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yZW1vdmVNYXJrZXIsICgpID0+IHtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX21hcE1hcmtlcikpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXBNYXJrZXIpLnJlbW92ZSgpO1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21hcE1hcmtlciwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVNYXJrZXIsIChmZWF0dXJlKSA9PiB7XG4gICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3JlbW92ZU1hcmtlcikuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghZmVhdHVyZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZGVmYXVsdE1hcmtlck9wdGlvbnMgPSB7XG4gICAgICAgIGNvbG9yOiBcIiM0NjY4RjJcIlxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1hcmtlck9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdE1hcmtlck9wdGlvbnMpLCB0eXBlb2YgdGhpcy5tYXJrZXIgPT09IFwib2JqZWN0XCIgJiYgdGhpcy5tYXJrZXIpO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tYXBNYXJrZXIsIG5ldyB0aGlzLm1hcGJveGdsLk1hcmtlcihtYXJrZXJPcHRpb25zKSk7XG4gICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeSAmJiBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgJiYgZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIgJiYgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcykge1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcE1hcmtlcikuc2V0TG5nTGF0KGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpLmFkZFRvKF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5pbnRlcmNlcHRTZWFyY2ggPSBudWxsO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25IYW5kbGVJbnB1dDIsIChlKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZS5jbG9uZSgpKTtcbiAgICAgIGNvbnN0IGlucHV0VGV4dCA9IGUuZGV0YWlsO1xuICAgICAgaWYgKCFpbnB1dFRleHQpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbGVhcikuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWx0ZXJlZFRleHQgPSB0aGlzLmludGVyY2VwdFNlYXJjaCAmJiB0aGlzLmludGVyY2VwdFNlYXJjaChpbnB1dFRleHQpO1xuICAgICAgY29uc3Qgc2VhcmNoVGV4dCA9IHRoaXMuaW50ZXJjZXB0U2VhcmNoID8gYWx0ZXJlZFRleHQgOiBpbnB1dFRleHQ7XG4gICAgICBpZiAodGhpcy5pbnRlcmNlcHRTZWFyY2ggJiYgIWFsdGVyZWRUZXh0KSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLmhpZGVSZXN1bHRzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjIpLnN1Z2dlc3Qoc2VhcmNoVGV4dCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2V0QWN0aW9uSWNvbnMpLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vbkhhbmRsZVNlbGVjdDIsIChlKSA9PiB7XG4gICAgICBjb25zdCBzdWdnZXN0aW9uID0gZS5kZXRhaWw7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24yKS5yZXRyaWV2ZShzdWdnZXN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXRBY3Rpb25JY29ucykuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uSGFuZGxlQmx1cjIsICgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjIpLmFib3J0KCk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXRBY3Rpb25JY29ucywgKGxvYWRpbmcgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkuQ2xlYXJCdG4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KS5Mb2FkaW5nSWNvbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkuTG9hZGluZ0ljb24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KS5DbGVhckJ0bi5zdHlsZS5kaXNwbGF5ID0gdGhpcy52YWx1ZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlQ2xlYXIsICgpID0+IHtcbiAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXRBY3Rpb25JY29ucykuY2FsbCh0aGlzKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlTWFya2VyKS5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikuaGFuZGxlU3VnZ2VzdChudWxsKTtcbiAgICB9KTtcbiAgICB0aGlzLm1hcmtlciA9IHRydWU7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVNb3ZlRW5kLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSBfX3ByaXZhdGVHZXQodGhpcywgX21hcCk7XG4gICAgICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICBpZiAobWFwLmdldFpvb20oKSA8PSBNQVhfWk9PTSkge1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5wcm94aW1pdHk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIHByb3hpbWl0eTogY2VudGVyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VhcmNoKS5hY2Nlc3NUb2tlbjtcbiAgfVxuICBzZXQgYWNjZXNzVG9rZW4obmV3VG9rZW4pIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NlYXJjaCkuYWNjZXNzVG9rZW4gPSBuZXdUb2tlbjtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQyKS52YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0MikudmFsdWUgPSBuZXdWYWx1ZTtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQyKTtcbiAgfVxuICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIFNFQVJDSEJPWF9URU1QTEFURTtcbiAgfVxuICBnZXQgdGVtcGxhdGVTdHlsZSgpIHtcbiAgICByZXR1cm4gc3R5bGVfZGVmYXVsdDtcbiAgfVxuICBnZXQgdGVtcGxhdGVVc2VyU3R5bGUoKSB7XG4gICAgcmV0dXJuIGdldFRoZW1lQ1NTKFwiLlNlYXJjaEJveFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS50aGVtZSk7XG4gIH1cbiAgZ2V0IHRoZW1lKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS50aGVtZTtcbiAgfVxuICBzZXQgdGhlbWUodGhlbWUpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS50aGVtZSA9IHRoZW1lO1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkgfHwgIXRoZW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGVtcGxhdGVVc2VyU3R5bGUoZ2V0VGhlbWVDU1MoXCIuU2VhcmNoQm94XCIsIHRoZW1lKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikudXBkYXRlUG9wb3ZlcigpO1xuICAgIGNvbnN0IHsgU2VhcmNoSWNvbiB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSk7XG4gICAgU2VhcmNoSWNvbi5pbm5lckhUTUwgPSBnZXRJY29uKFwic2VhcmNoXCIsIHRoZW1lKTtcbiAgfVxuICBnZXQgcG9wb3Zlck9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLnBvcG92ZXJPcHRpb25zO1xuICB9XG4gIHNldCBwb3BvdmVyT3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikucG9wb3Zlck9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICB9XG4gIGdldCBwbGFjZWhvbGRlcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9wbGFjZWhvbGRlcikgfHwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXREZWZhdWx0UGxhY2Vob2xkZXIsIGdldERlZmF1bHRQbGFjZWhvbGRlcl9mbikuY2FsbCh0aGlzKTtcbiAgfVxuICBzZXQgcGxhY2Vob2xkZXIodGV4dCkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGxhY2Vob2xkZXIsIHRleHQpO1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0MikpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQyKS5wbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXI7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0Mikuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2JpbmRpbmc1LCBiaW5kRWxlbWVudHModGhpcywge1xuICAgICAgU2VhcmNoQm94OiBcIi5TZWFyY2hCb3hcIixcbiAgICAgIFNlYXJjaEljb246IFwiLlNlYXJjaEljb25cIixcbiAgICAgIElucHV0OiBcIi5JbnB1dFwiLFxuICAgICAgQ2xlYXJCdG46IFwiLkNsZWFyQnRuXCIsXG4gICAgICBMb2FkaW5nSWNvbjogXCIuTG9hZGluZ0ljb25cIlxuICAgIH0pKTtcbiAgICB0aGlzLnRoZW1lID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMudGhlbWUpO1xuICAgIGNvbnN0IHsgSW5wdXQsIENsZWFyQnRuIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lucHV0MiwgSW5wdXQpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLmlucHV0ID0gSW5wdXQ7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94Mikuc2VhcmNoU2VydmljZSA9IDIgLyogU2VhcmNoQm94ICovO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlSW5wdXQyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlU2VsZWN0MikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVCbHVyMikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjIpLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdDIpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24yKS5hZGRFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yMikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjIpLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVJldHJpZXZlMikpO1xuICAgIENsZWFyQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUNsZWFyKSk7XG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcGxhY2Vob2xkZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikpO1xuICAgIGlmIChJbnB1dCkge1xuICAgICAgaWYgKElucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaGFzQXR0cmlidXRlKFwiYXJpYS1saXZlXCIpKSB7XG4gICAgICAgIElucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBJbnB1dC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmViZWdpblwiLCBjcmVhdGVBcmlhTGl2ZUVsZW1lbnQoX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikuZGF0YVNlZWQpKTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikucmVtb3ZlKCk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikuaW5wdXQgPSBudWxsO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlSW5wdXQyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlU2VsZWN0MikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVCbHVyMikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdDIpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24yKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yMikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVJldHJpZXZlMikpO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJhY2Nlc3MtdG9rZW5cIikge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZWFyY2gpLmFjY2Vzc1Rva2VuID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInRoZW1lXCIpIHtcbiAgICAgIHRoaXMudGhlbWUgPSB0cnlQYXJzZUpTT04obmV3VmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJwb3BvdmVyLW9wdGlvbnNcIikge1xuICAgICAgdGhpcy5wb3BvdmVyT3B0aW9ucyA9IHRyeVBhcnNlSlNPTihuZXdWYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInBsYWNlaG9sZGVyXCIpIHtcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uTmFtZSA9IG5hbWUuc3BsaXQoXCItXCIpLmpvaW4oXCJfXCIpO1xuICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgfVxuICAgIHRoaXMub3B0aW9uc1tvcHRpb25OYW1lXSA9IG5ld1ZhbHVlO1xuICAgIGlmIChvcHRpb25OYW1lID09PSBcImxhbmd1YWdlXCIpIHtcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBfX3ByaXZhdGVHZXQodGhpcywgX3BsYWNlaG9sZGVyKTtcbiAgICB9XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikuZm9jdXMoKTtcbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHRoaXMudmFsdWUgPSB0ZXh0O1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVJbnB1dDIpLmNhbGwodGhpcywgbmV3IE1hcGJveEhUTUxFdmVudChcImlucHV0XCIsIHRleHQpKTtcbiAgfVxuICBiaW5kTWFwKG1hcCkge1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX21hcCkpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKS5vZmYoXCJtb3ZlZW5kXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlTW92ZUVuZCkpO1xuICAgIH1cbiAgICBpZiAobWFwKSB7XG4gICAgICBtYXAub24oXCJtb3ZlZW5kXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlTW92ZUVuZCkpO1xuICAgIH1cbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX21hcCwgbWFwKTtcbiAgfVxuICB1bmJpbmRNYXAoKSB7XG4gICAgdGhpcy5iaW5kTWFwKG51bGwpO1xuICB9XG4gIG9uQWRkKG1hcCkge1xuICAgIHRoaXMuYmluZE1hcChtYXApO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJtYXBib3hnbC1jdHJsXCI7XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gXCIzMDBweFwiO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIG9uUmVtb3ZlKCkge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgdGhpcy51bmJpbmRNYXAoKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3JlbW92ZU1hcmtlcikuY2FsbCh0aGlzKTtcbiAgfVxuICBnZXREZWZhdWx0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIFwidG9wLXJpZ2h0XCI7XG4gIH1cbn07XG5fYmluZGluZzUgPSBuZXcgV2Vha01hcCgpO1xuX3NlYXJjaCA9IG5ldyBXZWFrTWFwKCk7XG5fc2Vzc2lvbjIgPSBuZXcgV2Vha01hcCgpO1xuX21hcCA9IG5ldyBXZWFrTWFwKCk7XG5faW5wdXQyID0gbmV3IFdlYWtNYXAoKTtcbl9saXN0Ym94MiA9IG5ldyBXZWFrTWFwKCk7XG5fZ2V0RGVmYXVsdFBsYWNlaG9sZGVyID0gbmV3IFdlYWtTZXQoKTtcbmdldERlZmF1bHRQbGFjZWhvbGRlcl9mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmxhbmd1YWdlKSB7XG4gICAgY29uc3QgZmlyc3RMYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5sYW5ndWFnZS5zcGxpdChcIixcIilbMF07XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBzdWJ0YWcubGFuZ3VhZ2UoZmlyc3RMYW5ndWFnZSk7XG4gICAgY29uc3QgbG9jYWxpemVkVmFsdWUgPSBsb2NhbGl6YXRpb25fZGVmYXVsdC5wbGFjZWhvbGRlcltsYW5ndWFnZV07XG4gICAgaWYgKGxvY2FsaXplZFZhbHVlKVxuICAgICAgcmV0dXJuIGxvY2FsaXplZFZhbHVlO1xuICB9XG4gIHJldHVybiBcIlNlYXJjaFwiO1xufTtcbl9wbGFjZWhvbGRlciA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU3VnZ2VzdDIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN1Z2dlc3RFcnJvcjIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVJldHJpZXZlMiA9IG5ldyBXZWFrTWFwKCk7XG5fbWFwTWFya2VyID0gbmV3IFdlYWtNYXAoKTtcbl9yZW1vdmVNYXJrZXIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZU1hcmtlciA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVJbnB1dDIgPSBuZXcgV2Vha01hcCgpO1xuX29uSGFuZGxlU2VsZWN0MiA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVCbHVyMiA9IG5ldyBXZWFrTWFwKCk7XG5fc2V0QWN0aW9uSWNvbnMgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUNsZWFyID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVNb3ZlRW5kID0gbmV3IFdlYWtNYXAoKTtcbk1hcGJveFNlYXJjaEJveC5vYnNlcnZlZEF0dHJpYnV0ZXMgPSBbXG4gIFwiYWNjZXNzLXRva2VuXCIsXG4gIFwidGhlbWVcIixcbiAgXCJwb3BvdmVyLW9wdGlvbnNcIixcbiAgXCJwbGFjZWhvbGRlclwiLFxuICBcImxhbmd1YWdlXCIsXG4gIFwiY291bnRyeVwiLFxuICBcImJib3hcIixcbiAgXCJsaW1pdFwiLFxuICBcIm5hdmlnYXRpb24tcHJvZmlsZVwiLFxuICBcIm9yaWdpblwiLFxuICBcInByb3hpbWl0eVwiLFxuICBcImV0YS10eXBlXCIsXG4gIFwidHlwZXNcIlxuXTtcbndpbmRvdy5NYXBib3hTZWFyY2hCb3ggPSBNYXBib3hTZWFyY2hCb3g7XG5pZiAoIXdpbmRvdy5jdXN0b21FbGVtZW50cy5nZXQoXCJtYXBib3gtc2VhcmNoLWJveFwiKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtYXBib3gtc2VhcmNoLWJveFwiLCBNYXBib3hTZWFyY2hCb3gpO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9NYXBib3hHZW9jb2Rlci50c1xuaW1wb3J0IHtcbiAgTG5nTGF0Qm91bmRzIGFzIExuZ0xhdEJvdW5kczIsXG4gIFNlYXJjaFNlc3Npb24gYXMgU2VhcmNoU2Vzc2lvbjMsXG4gIEdlb2NvZGluZ0NvcmVcbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbmltcG9ydCBzdWJ0YWcyIGZyb20gXCJzdWJ0YWdcIjtcbnZhciBNQVhfWk9PTTIgPSA5O1xudmFyIF9iaW5kaW5nNiwgX3NlYXJjaDIsIF9zZXNzaW9uMywgX21hcDIsIF9pbnB1dDMsIF9saXN0Ym94MywgX2dldERlZmF1bHRQbGFjZWhvbGRlcjIsIGdldERlZmF1bHRQbGFjZWhvbGRlcl9mbjIsIF9wbGFjZWhvbGRlcjIsIF9oYW5kbGVTdWdnZXN0MywgX2hhbmRsZVN1Z2dlc3RFcnJvcjMsIF9oYW5kbGVSZXRyaWV2ZTMsIF9tYXBNYXJrZXIyLCBfcmVtb3ZlTWFya2VyMiwgX2hhbmRsZU1hcmtlcjIsIF9vbkhhbmRsZUlucHV0MywgX29uSGFuZGxlU2VsZWN0MywgX29uSGFuZGxlQmx1cjMsIF9zZXRBY3Rpb25JY29uczIsIF9oYW5kbGVDbGVhcjIsIF9oYW5kbGVNb3ZlRW5kMjtcbnZhciBNYXBib3hHZW9jb2RlciA9IGNsYXNzIGV4dGVuZHMgSFRNTFNjb3BlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZ2V0RGVmYXVsdFBsYWNlaG9sZGVyMik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9iaW5kaW5nNiwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NlYXJjaDIsIG5ldyBHZW9jb2RpbmdDb3JlKHt9KSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXNzaW9uMywgbmV3IFNlYXJjaFNlc3Npb24zKF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VhcmNoMikpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21hcDIsIG51bGwpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaW5wdXQzLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGlzdGJveDMsIG5ldyBNYXBib3hTZWFyY2hMaXN0Ym94KCkpO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcGxhY2Vob2xkZXIyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3VnZ2VzdDMsIChyZXN1bHQpID0+IHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2V0QWN0aW9uSWNvbnMyKS5jYWxsKHRoaXMpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykuaGFuZGxlU3VnZ2VzdCgocmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiByZXN1bHQuZmVhdHVyZXMpIHx8IG51bGwpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoXCJzdWdnZXN0XCIsIHJlc3VsdCkpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yMywgKGVycm9yKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NldEFjdGlvbkljb25zMikuY2FsbCh0aGlzKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpLmhhbmRsZUVycm9yKCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChcInN1Z2dlc3RlcnJvclwiLCBlcnJvcikpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlUmV0cmlldmUzLCAocmVzdWx0KSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NldEFjdGlvbkljb25zMikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmV0cmlldmVcIiwgcmVzdWx0KSk7XG4gICAgICBjb25zdCBmZWF0dXJlID0gcmVzdWx0O1xuICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQzKS52YWx1ZSA9IGZlYXR1cmUucHJvcGVydGllcy5mdWxsX2FkZHJlc3M7XG4gICAgICBjb25zdCBtYXAgPSBfX3ByaXZhdGVHZXQodGhpcywgX21hcDIpO1xuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VUeXBlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmZlYXR1cmVfdHlwZTtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGZlYXR1cmUucHJvcGVydGllcy5iYm94O1xuICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICBtYXAuZmx5VG8oYmJveFZpZXdwb3J0KG1hcCwgTG5nTGF0Qm91bmRzMi5jb252ZXJ0KGJvdW5kcykudG9GbGF0QXJyYXkoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgY29uc3Qgem9vbSA9IGdldE1heFpvb20ocGxhY2VUeXBlKTtcbiAgICAgICAgbWFwLmZseVRvKHtcbiAgICAgICAgICBjZW50ZXIsXG4gICAgICAgICAgem9vbSxcbiAgICAgICAgICBzcGVlZDogRkxZX1RPX1NQRUVEXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWFya2VyICYmIHRoaXMubWFwYm94Z2wpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVNYXJrZXIyKS5jYWxsKHRoaXMsIGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWFwTWFya2VyMiwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3JlbW92ZU1hcmtlcjIsICgpID0+IHtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX21hcE1hcmtlcjIpKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwTWFya2VyMikucmVtb3ZlKCk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWFwTWFya2VyMiwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVNYXJrZXIyLCAoZmVhdHVyZSkgPT4ge1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX21hcDIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVtb3ZlTWFya2VyMikuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghZmVhdHVyZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZGVmYXVsdE1hcmtlck9wdGlvbnMgPSB7XG4gICAgICAgIGNvbG9yOiBcIiM0NjY4RjJcIlxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1hcmtlck9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdE1hcmtlck9wdGlvbnMpLCB0eXBlb2YgdGhpcy5tYXJrZXIgPT09IFwib2JqZWN0XCIgJiYgdGhpcy5tYXJrZXIpO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tYXBNYXJrZXIyLCBuZXcgdGhpcy5tYXBib3hnbC5NYXJrZXIobWFya2VyT3B0aW9ucykpO1xuICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgJiYgZmVhdHVyZS5nZW9tZXRyeS50eXBlICYmIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2ludFwiICYmIGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXBNYXJrZXIyKS5zZXRMbmdMYXQoZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcykuYWRkVG8oX19wcml2YXRlR2V0KHRoaXMsIF9tYXAyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5pbnRlcmNlcHRTZWFyY2ggPSBudWxsO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25IYW5kbGVJbnB1dDMsIChlKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZS5jbG9uZSgpKTtcbiAgICAgIGNvbnN0IGlucHV0VGV4dCA9IGUuZGV0YWlsO1xuICAgICAgaWYgKCFpbnB1dFRleHQpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDbGVhcjIpLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsdGVyZWRUZXh0ID0gdGhpcy5pbnRlcmNlcHRTZWFyY2ggJiYgdGhpcy5pbnRlcmNlcHRTZWFyY2goaW5wdXRUZXh0KTtcbiAgICAgIGNvbnN0IHNlYXJjaFRleHQgPSB0aGlzLmludGVyY2VwdFNlYXJjaCA/IGFsdGVyZWRUZXh0IDogaW5wdXRUZXh0O1xuICAgICAgaWYgKHRoaXMuaW50ZXJjZXB0U2VhcmNoICYmICFhbHRlcmVkVGV4dCkge1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gzKS5oaWRlUmVzdWx0cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24zKS5zdWdnZXN0KHNlYXJjaFRleHQsIHRoaXMub3B0aW9ucyk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NldEFjdGlvbkljb25zMikuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uSGFuZGxlU2VsZWN0MywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBlLmRldGFpbDtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjMpLnJldHJpZXZlKHN1Z2dlc3Rpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NldEFjdGlvbkljb25zMikuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uSGFuZGxlQmx1cjMsICgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjMpLmFib3J0KCk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXRBY3Rpb25JY29uczIsIChsb2FkaW5nID0gZmFsc2UpID0+IHtcbiAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzYpLkNsZWFyQnRuLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNikuTG9hZGluZ0ljb24uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzYpLkxvYWRpbmdJY29uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNikuQ2xlYXJCdG4uc3R5bGUuZGlzcGxheSA9IHRoaXMudmFsdWUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUNsZWFyMiwgKCkgPT4ge1xuICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NldEFjdGlvbkljb25zMikuY2FsbCh0aGlzKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlTWFya2VyMikuY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpLmhhbmRsZVN1Z2dlc3QobnVsbCk7XG4gICAgfSk7XG4gICAgdGhpcy5tYXJrZXIgPSB0cnVlO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlTW92ZUVuZDIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwMik7XG4gICAgICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICBpZiAobWFwLmdldFpvb20oKSA8PSBNQVhfWk9PTTIpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucHJveGltaXR5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgICBwcm94aW1pdHk6IGNlbnRlclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3NlYXJjaDIpLmFjY2Vzc1Rva2VuO1xuICB9XG4gIHNldCBhY2Nlc3NUb2tlbihuZXdUb2tlbikge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VhcmNoMikuYWNjZXNzVG9rZW4gPSBuZXdUb2tlbjtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQzKS52YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0MykudmFsdWUgPSBuZXdWYWx1ZTtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQzKTtcbiAgfVxuICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIEdFT0NPREVSX1RFTVBMQVRFO1xuICB9XG4gIGdldCB0ZW1wbGF0ZVN0eWxlKCkge1xuICAgIHJldHVybiBzdHlsZV9kZWZhdWx0O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVVzZXJTdHlsZSgpIHtcbiAgICByZXR1cm4gZ2V0VGhlbWVDU1MoXCIuR2VvY29kZXJcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykudGhlbWUpO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykudGhlbWU7XG4gIH1cbiAgc2V0IHRoZW1lKHRoZW1lKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykudGhlbWUgPSB0aGVtZTtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzYpIHx8ICF0aGVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlVXNlclN0eWxlKGdldFRoZW1lQ1NTKFwiLkdlb2NvZGVyXCIsIHRoZW1lKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykudXBkYXRlUG9wb3ZlcigpO1xuICAgIGNvbnN0IHsgU2VhcmNoSWNvbiB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNik7XG4gICAgU2VhcmNoSWNvbi5pbm5lckhUTUwgPSBnZXRJY29uKFwic2VhcmNoXCIsIHRoZW1lKTtcbiAgfVxuICBnZXQgcG9wb3Zlck9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpLnBvcG92ZXJPcHRpb25zO1xuICB9XG4gIHNldCBwb3BvdmVyT3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykucG9wb3Zlck9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICB9XG4gIGdldCBwbGFjZWhvbGRlcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9wbGFjZWhvbGRlcjIpIHx8IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0RGVmYXVsdFBsYWNlaG9sZGVyMiwgZ2V0RGVmYXVsdFBsYWNlaG9sZGVyX2ZuMikuY2FsbCh0aGlzKTtcbiAgfVxuICBzZXQgcGxhY2Vob2xkZXIodGV4dCkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGxhY2Vob2xkZXIyLCB0ZXh0KTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDMpKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0MykucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDMpLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5wbGFjZWhvbGRlcik7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9iaW5kaW5nNiwgYmluZEVsZW1lbnRzKHRoaXMsIHtcbiAgICAgIEdlb2NvZGVyOiBcIi5HZW9jb2RlclwiLFxuICAgICAgU2VhcmNoSWNvbjogXCIuU2VhcmNoSWNvblwiLFxuICAgICAgSW5wdXQ6IFwiLklucHV0XCIsXG4gICAgICBDbGVhckJ0bjogXCIuQ2xlYXJCdG5cIixcbiAgICAgIExvYWRpbmdJY29uOiBcIi5Mb2FkaW5nSWNvblwiXG4gICAgfSkpO1xuICAgIHRoaXMudGhlbWUgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy50aGVtZSk7XG4gICAgY29uc3QgeyBJbnB1dCwgQ2xlYXJCdG4gfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzYpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW5wdXQzLCBJbnB1dCk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykuaW5wdXQgPSBJbnB1dDtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gzKS5zZWFyY2hTZXJ2aWNlID0gMSAvKiBHZW9jb2RpbmcgKi87XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVJbnB1dDMpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gzKS5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVTZWxlY3QzKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZUJsdXIzKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uMykuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0MykpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjMpLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3IzKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uMykuYWRkRXZlbnRMaXN0ZW5lcihcInJldHJpZXZlXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlUmV0cmlldmUzKSk7XG4gICAgQ2xlYXJCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQ2xlYXIyKSk7XG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcGxhY2Vob2xkZXIyKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpKTtcbiAgICBpZiAoSW5wdXQpIHtcbiAgICAgIGlmIChJbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmhhc0F0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKSkge1xuICAgICAgICBJbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgSW5wdXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYmVmb3JlYmVnaW5cIiwgY3JlYXRlQXJpYUxpdmVFbGVtZW50KF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpLmRhdGFTZWVkKSk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpLnJlbW92ZSgpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpLmlucHV0ID0gbnVsbDtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gzKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZUlucHV0MykpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDMpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3RcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZVNlbGVjdDMpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gzKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlQmx1cjMpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24zKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3QzKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uMykucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3RFcnJvcjMpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24zKS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVSZXRyaWV2ZTMpKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiYWNjZXNzLXRva2VuXCIpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VhcmNoMikuYWNjZXNzVG9rZW4gPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwidGhlbWVcIikge1xuICAgICAgdGhpcy50aGVtZSA9IHRyeVBhcnNlSlNPTihuZXdWYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInBvcG92ZXItb3B0aW9uc1wiKSB7XG4gICAgICB0aGlzLnBvcG92ZXJPcHRpb25zID0gdHJ5UGFyc2VKU09OKG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwicGxhY2Vob2xkZXJcIikge1xuICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG5ld1ZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25OYW1lID0gbmFtZS5zcGxpdChcIi1cIikuam9pbihcIl9cIik7XG4gICAgaWYgKCFuZXdWYWx1ZSkge1xuICAgICAgZGVsZXRlIHRoaXMub3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zW29wdGlvbk5hbWVdID0gbmV3VmFsdWU7XG4gICAgaWYgKG9wdGlvbk5hbWUgPT09IFwibGFuZ3VhZ2VcIikge1xuICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcGxhY2Vob2xkZXIyKTtcbiAgICB9XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MykuZm9jdXMoKTtcbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHRoaXMudmFsdWUgPSB0ZXh0O1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVJbnB1dDMpLmNhbGwodGhpcywgbmV3IE1hcGJveEhUTUxFdmVudChcImlucHV0XCIsIHRleHQpKTtcbiAgfVxuICBiaW5kTWFwKG1hcCkge1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX21hcDIpKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcDIpLm9mZihcIm1vdmVlbmRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVNb3ZlRW5kMikpO1xuICAgIH1cbiAgICBpZiAobWFwKSB7XG4gICAgICBtYXAub24oXCJtb3ZlZW5kXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlTW92ZUVuZDIpKTtcbiAgICB9XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tYXAyLCBtYXApO1xuICB9XG4gIHVuYmluZE1hcCgpIHtcbiAgICB0aGlzLmJpbmRNYXAobnVsbCk7XG4gIH1cbiAgb25BZGQobWFwKSB7XG4gICAgdGhpcy5iaW5kTWFwKG1hcCk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcIm1hcGJveGdsLWN0cmxcIjtcbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBcIjMwMHB4XCI7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgb25SZW1vdmUoKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzLnVuYmluZE1hcCgpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVtb3ZlTWFya2VyMikuY2FsbCh0aGlzKTtcbiAgfVxuICBnZXREZWZhdWx0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIFwidG9wLXJpZ2h0XCI7XG4gIH1cbn07XG5fYmluZGluZzYgPSBuZXcgV2Vha01hcCgpO1xuX3NlYXJjaDIgPSBuZXcgV2Vha01hcCgpO1xuX3Nlc3Npb24zID0gbmV3IFdlYWtNYXAoKTtcbl9tYXAyID0gbmV3IFdlYWtNYXAoKTtcbl9pbnB1dDMgPSBuZXcgV2Vha01hcCgpO1xuX2xpc3Rib3gzID0gbmV3IFdlYWtNYXAoKTtcbl9nZXREZWZhdWx0UGxhY2Vob2xkZXIyID0gbmV3IFdlYWtTZXQoKTtcbmdldERlZmF1bHRQbGFjZWhvbGRlcl9mbjIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5sYW5ndWFnZSkge1xuICAgIGNvbnN0IGZpcnN0TGFuZ3VhZ2UgPSB0aGlzLm9wdGlvbnMubGFuZ3VhZ2Uuc3BsaXQoXCIsXCIpWzBdO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gc3VidGFnMi5sYW5ndWFnZShmaXJzdExhbmd1YWdlKTtcbiAgICBjb25zdCBsb2NhbGl6ZWRWYWx1ZSA9IGxvY2FsaXphdGlvbl9kZWZhdWx0LnBsYWNlaG9sZGVyW2xhbmd1YWdlXTtcbiAgICBpZiAobG9jYWxpemVkVmFsdWUpXG4gICAgICByZXR1cm4gbG9jYWxpemVkVmFsdWU7XG4gIH1cbiAgcmV0dXJuIFwiU2VhcmNoXCI7XG59O1xuX3BsYWNlaG9sZGVyMiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU3VnZ2VzdDMgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN1Z2dlc3RFcnJvcjMgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVJldHJpZXZlMyA9IG5ldyBXZWFrTWFwKCk7XG5fbWFwTWFya2VyMiA9IG5ldyBXZWFrTWFwKCk7XG5fcmVtb3ZlTWFya2VyMiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlTWFya2VyMiA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVJbnB1dDMgPSBuZXcgV2Vha01hcCgpO1xuX29uSGFuZGxlU2VsZWN0MyA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVCbHVyMyA9IG5ldyBXZWFrTWFwKCk7XG5fc2V0QWN0aW9uSWNvbnMyID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVDbGVhcjIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZU1vdmVFbmQyID0gbmV3IFdlYWtNYXAoKTtcbk1hcGJveEdlb2NvZGVyLm9ic2VydmVkQXR0cmlidXRlcyA9IFtcbiAgXCJhY2Nlc3MtdG9rZW5cIixcbiAgXCJ0aGVtZVwiLFxuICBcInBvcG92ZXItb3B0aW9uc1wiLFxuICBcInBsYWNlaG9sZGVyXCIsXG4gIFwiYXV0b2NvbXBsZXRlXCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJjb3VudHJ5XCIsXG4gIFwiYmJveFwiLFxuICBcImxpbWl0XCIsXG4gIFwicHJveGltaXR5XCIsXG4gIFwidHlwZXNcIixcbiAgXCJ3b3JsZHZpZXdcIixcbiAgXCJwZXJtYW5lbnRcIlxuXTtcbndpbmRvdy5NYXBib3hHZW9jb2RlciA9IE1hcGJveEdlb2NvZGVyO1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LWdlb2NvZGVyXCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1hcGJveC1nZW9jb2RlclwiLCBNYXBib3hHZW9jb2Rlcik7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL01hcGJveEFkZHJlc3NNaW5pbWFwLnRzXG5pbXBvcnQgeyBMbmdMYXQgfSBmcm9tIFwiQG1hcGJveC9zZWFyY2gtanMtY29yZVwiO1xuXG4vLyBzcmMvdXRpbHMvbWluaW1hcC50c1xuaW1wb3J0IFNwaGVyaWNhbE1lcmNhdG9yIGZyb20gXCJAbWFwYm94L3NwaGVyaWNhbG1lcmNhdG9yXCI7XG52YXIgbWVyYyA9IG5ldyBTcGhlcmljYWxNZXJjYXRvcih7IHNpemU6IDUxMiwgYW50aW1lcmlkaWFuOiB0cnVlIH0pO1xudmFyIE1BWF9JTUFHRV9ESU0gPSAxMjgwO1xuZnVuY3Rpb24gZ2V0QW5jaG9yT2Zmc2V0KG1hcmtlciwgYW5jaG9yKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RWxlbWVudFNpemUobWFya2VyLCB0cnVlKTtcbiAgc3dpdGNoIChhbmNob3IpIHtcbiAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIHJldHVybiBbMCwgaGVpZ2h0IC8gMl07XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIFswLCAtMSAqIGhlaWdodCAvIDJdO1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByZXR1cm4gW3dpZHRoIC8gMiwgMF07XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByZXR1cm4gWy0xICogd2lkdGggLyAyLCAwXTtcbiAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgIHJldHVybiBbd2lkdGggLyAyLCBoZWlnaHQgLyAyXTtcbiAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICByZXR1cm4gWy0xICogd2lkdGggLyAyLCBoZWlnaHQgLyAyXTtcbiAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgIHJldHVybiBbd2lkdGggLyAyLCAtMSAqIGhlaWdodCAvIDJdO1xuICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgIHJldHVybiBbLTEgKiB3aWR0aCAvIDIsIC0xICogaGVpZ2h0IC8gMl07XG4gIH1cbn1cbnZhciBfYW5jaG9yLCBfaGFuZGxlQW5jaG9yUmVzaXplLCBfbWFya2VyVHJhbnNmb3JtLCBfaXNBY3RpdmUsIF9vcmlnaW5hbENvb3JkaW5hdGUsIF9vblBvaW50ZXJEb3duTWFya2VyLCBfb25Qb2ludGVyVXBNYXJrZXIsIF9vblBvaW50ZXJNb3ZlTWFya2VyLCBfb25Qb2ludGVyRG93bkltYWdlLCBfb25Qb2ludGVyVXBJbWFnZSwgX29uUG9pbnRlck1vdmVJbWFnZSwgX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbiwgX3VwZGF0ZU1hcmtlclRyYW5zZm9ybSwgX3VwZGF0ZU1hcmtlckNvcnJlY3Rpb247XG52YXIgTWFya2VyQ29udHJvbGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW1hZ2VDb250YWluZXIsIGltYWdlRWxlbWVudCwgbWFya2VyLCBrZWVwTWFya2VyQ2VudGVyZWQsIHpvb20sIGFuY2hvcikge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYW5jaG9yLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlQW5jaG9yUmVzaXplLCAoKSA9PiB7XG4gICAgICBbdGhpcy5hbmNob3JPZmZzZXRYLCB0aGlzLmFuY2hvck9mZnNldFldID0gZ2V0QW5jaG9yT2Zmc2V0KHRoaXMubWFya2VyRWxlbWVudCwgdGhpcy5hbmNob3IpO1xuICAgICAgdGhpcy5tYXJrZXJUcmFuc2Zvcm0gPSB7XG4gICAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yT2Zmc2V0WCxcbiAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JPZmZzZXRZXG4gICAgICB9O1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWFya2VyVHJhbnNmb3JtLCB7XG4gICAgICBhbmNob3JYOiAwLFxuICAgICAgYW5jaG9yWTogMCxcbiAgICAgIGdsb2JhbFg6IDAsXG4gICAgICBnbG9iYWxZOiAwLFxuICAgICAgY29ycmVjdGlvblg6IDAsXG4gICAgICBjb3JyZWN0aW9uWTogMFxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaXNBY3RpdmUsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29yaWdpbmFsQ29vcmRpbmF0ZSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlckRvd25NYXJrZXIsIChtKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG0ucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG0uc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbikuY2FsbCh0aGlzLCBtKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vblBvaW50ZXJNb3ZlTWFya2VyKSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlclVwTWFya2VyKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vblBvaW50ZXJVcE1hcmtlciwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlck1vdmVNYXJrZXIpKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25Qb2ludGVyVXBNYXJrZXIpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlck1vdmVNYXJrZXIsIChtKSA9PiB7XG4gICAgICBtLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3QgZGlmZlggPSB0aGlzLmN1clBvaW50ZXJYUG9zIC0gbS5wYWdlWDtcbiAgICAgIGNvbnN0IGRpZmZZID0gdGhpcy5jdXJQb2ludGVyWVBvcyAtIG0ucGFnZVk7XG4gICAgICB0aGlzLm1hcmtlckRlbHRhWCArPSBkaWZmWDtcbiAgICAgIHRoaXMubWFya2VyRGVsdGFZIC09IGRpZmZZO1xuICAgICAgdGhpcy5tYXJrZXJEZWx0YVggPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLmltZ0VsZW1lbnQud2lkdGggLyAyLCB0aGlzLm1hcmtlckRlbHRhWCksIHRoaXMuaW1nRWxlbWVudC53aWR0aCAvIDIgKiAtMSk7XG4gICAgICB0aGlzLm1hcmtlckRlbHRhWSA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLyAyLCB0aGlzLm1hcmtlckRlbHRhWSksIHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLyAyICogLTEpO1xuICAgICAgY29uc3QgaW1hZ2VPZmZzZXRYID0gdGhpcy5pbWdDZW50ZXJQeFswXSAtIHRoaXMuaW1nQ2VudGVyQWRqdXN0ZWRQeFswXTtcbiAgICAgIGNvbnN0IGltYWdlT2Zmc2V0WSA9IHRoaXMuaW1nQ2VudGVyUHhbMV0gLSB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHhbMV07XG4gICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1hcmtlckRlbHRhWCAtIGltYWdlT2Zmc2V0WDtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IHRoaXMubWFya2VyRGVsdGFZICsgaW1hZ2VPZmZzZXRZO1xuICAgICAgdGhpcy5tYXJrZXJUcmFuc2Zvcm0gPSB7IGdsb2JhbFg6IGRlbHRhWCwgZ2xvYmFsWTogZGVsdGFZIH07XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbikuY2FsbCh0aGlzLCBtKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlckRvd25JbWFnZSwgKG0pID0+IHtcbiAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlUG9pbnRlclBvc2l0aW9uKS5jYWxsKHRoaXMsIG0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlck1vdmVJbWFnZSkpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vblBvaW50ZXJVcEltYWdlKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vblBvaW50ZXJVcEltYWdlLCAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25Qb2ludGVyTW92ZUltYWdlKSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlclVwSW1hZ2UpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlck1vdmVJbWFnZSwgKG0pID0+IHtcbiAgICAgIG0ucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCB0b3AgPSBNYXRoLnJvdW5kKHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxUb3AgKyAodGhpcy5jdXJQb2ludGVyWVBvcyAtIG0ucGFnZVkpKTtcbiAgICAgIHRvcCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLSB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0LCB0b3ApLCAwKTtcbiAgICAgIGxldCBsZWZ0ID0gTWF0aC5yb3VuZCh0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuc2Nyb2xsTGVmdCArICh0aGlzLmN1clBvaW50ZXJYUG9zIC0gbS5wYWdlWCkpO1xuICAgICAgbGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuaW1nRWxlbWVudC53aWR0aCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCwgbGVmdCksIDApO1xuICAgICAgdGhpcy5pbWdDb250YWluZXJFbGVtZW50LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIGNvbnN0IGRpZmZYID0gTWF0aC5yb3VuZChsZWZ0IC0gKHRoaXMuaW1nRWxlbWVudC53aWR0aCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCkgLyAyKTtcbiAgICAgIGNvbnN0IGRpZmZZID0gTWF0aC5yb3VuZCgodGhpcy5pbWdFbGVtZW50LmhlaWdodCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRIZWlnaHQpIC8gMiAtIHRvcCk7XG4gICAgICB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHggPSBbXG4gICAgICAgIHRoaXMuaW1nQ2VudGVyUHhbMF0gKyBkaWZmWCxcbiAgICAgICAgdGhpcy5pbWdDZW50ZXJQeFsxXSAtIGRpZmZZXG4gICAgICBdO1xuICAgICAgaWYgKCF0aGlzLmtlZXBNYXJrZXJDZW50ZXJlZCkge1xuICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1hcmtlckRlbHRhWCArIGRpZmZYO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLm1hcmtlckRlbHRhWSArIGRpZmZZO1xuICAgICAgICB0aGlzLm1hcmtlclRyYW5zZm9ybSA9IHsgZ2xvYmFsWDogZGVsdGFYLCBnbG9iYWxZOiBkZWx0YVkgfTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlTWFya2VyQ29ycmVjdGlvbikuY2FsbCh0aGlzLCBsZWZ0LCB0b3ApO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF91cGRhdGVQb2ludGVyUG9zaXRpb24pLmNhbGwodGhpcywgbSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF91cGRhdGVQb2ludGVyUG9zaXRpb24sIChtKSA9PiB7XG4gICAgICB0aGlzLmN1clBvaW50ZXJYUG9zID0gbS5wYWdlWDtcbiAgICAgIHRoaXMuY3VyUG9pbnRlcllQb3MgPSBtLnBhZ2VZO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXBkYXRlTWFya2VyVHJhbnNmb3JtLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IGFuY2hvclgsIGFuY2hvclksIGdsb2JhbFgsIGdsb2JhbFksIGNvcnJlY3Rpb25YLCBjb3JyZWN0aW9uWSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgdHJhbnNmb3JtWCA9IGFuY2hvclggLSBnbG9iYWxYICsgY29ycmVjdGlvblg7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1ZID0gYW5jaG9yWSArIGdsb2JhbFkgKyBjb3JyZWN0aW9uWTtcbiAgICAgIHRoaXMubWFya2VyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKGNhbGMoLTUwJSArICR7dHJhbnNmb3JtWH1weCksIGNhbGMoLTUwJSArICR7dHJhbnNmb3JtWX1weCkpYDtcbiAgICB9KTtcbiAgICB0aGlzLnJlQ2VudGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgdG9wID0gKHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLSB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0KSAvIDI7XG4gICAgICBjb25zdCBsZWZ0ID0gKHRoaXMuaW1nRWxlbWVudC53aWR0aCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCkgLyAyO1xuICAgICAgdGhpcy5pbWdDb250YWluZXJFbGVtZW50LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIHRoaXMuaW1nQ2VudGVyQWRqdXN0ZWRQeCA9IHRoaXMuaW1nQ2VudGVyUHg7XG4gICAgICB0aGlzLm1hcmtlckRlbHRhWCA9IHRoaXMubWFya2VyRGVsdGFZID0gMDtcbiAgICAgIHRoaXMubWFya2VyVHJhbnNmb3JtID0ge1xuICAgICAgICBnbG9iYWxYOiAwLFxuICAgICAgICBnbG9iYWxZOiAwLFxuICAgICAgICBjb3JyZWN0aW9uWDogMCxcbiAgICAgICAgY29ycmVjdGlvblk6IDBcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZU1pbmltYXBSZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW1nRWxlbWVudC5oZWlnaHQgfHwgIXRoaXMuaW1nRWxlbWVudC53aWR0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WCA9IHRoaXMuaW1nQ2VudGVyT2Zmc2V0Lng7XG4gICAgICBjb25zdCBjZW50ZXJPZmZzZXRZID0gdGhpcy5pbWdDZW50ZXJPZmZzZXQueTtcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmltZ0VsZW1lbnQud2lkdGggLyAyIC0gY2VudGVyT2Zmc2V0WCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCAvIDI7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLmltZ0VsZW1lbnQuaGVpZ2h0IC8gMiAtIGNlbnRlck9mZnNldFkgLSB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZU1hcmtlckNvcnJlY3Rpb24pLmNhbGwodGhpcywgbGVmdCwgdG9wKTtcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXBkYXRlTWFya2VyQ29ycmVjdGlvbiwgKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkgPT4ge1xuICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WCA9IHRoaXMuaW1nQ2VudGVyT2Zmc2V0Lng7XG4gICAgICBjb25zdCBjZW50ZXJPZmZzZXRZID0gdGhpcy5pbWdDZW50ZXJPZmZzZXQueTtcbiAgICAgIGNvbnN0IHsgY29ycmVjdGlvblgsIGNvcnJlY3Rpb25ZIH0gPSB0aGlzLm1hcmtlclRyYW5zZm9ybTtcbiAgICAgIGNvbnN0IGNvcnJlY3Rpb25zID0ge307XG4gICAgICBpZiAoc2Nyb2xsTGVmdCAvIDIgPCBjZW50ZXJPZmZzZXRYICogLTEpIHtcbiAgICAgICAgY29uc3QgbWFya2VyVHJhbnNsYXRlWCA9IGNlbnRlck9mZnNldFggKiAtMSAtIHNjcm9sbExlZnQgLyAyO1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWCA9IG1hcmtlclRyYW5zbGF0ZVggKiAyO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxMZWZ0IDwgMCkge1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWCA9IHNjcm9sbExlZnQ7XG4gICAgICB9IGVsc2UgaWYgKGNvcnJlY3Rpb25YICE9PSAwKSB7XG4gICAgICAgIGNvcnJlY3Rpb25zLmNvcnJlY3Rpb25YID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxUb3AgLyAyIDwgY2VudGVyT2Zmc2V0WSAqIC0xKSB7XG4gICAgICAgIGNvbnN0IG1hcmtlclRyYW5zbGF0ZVkgPSBjZW50ZXJPZmZzZXRZICogLTEgLSBzY3JvbGxUb3AgLyAyO1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWSA9IG1hcmtlclRyYW5zbGF0ZVkgKiAyO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AgPCAwKSB7XG4gICAgICAgIGNvcnJlY3Rpb25zLmNvcnJlY3Rpb25ZID0gc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIGlmIChjb3JyZWN0aW9uWSAhPT0gMCkge1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcmtlclRyYW5zZm9ybSA9IGNvcnJlY3Rpb25zO1xuICAgIH0pO1xuICAgIHRoaXMubWFya2VyRWxlbWVudCA9IG1hcmtlcjtcbiAgICB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQgPSBpbWFnZUNvbnRhaW5lcjtcbiAgICB0aGlzLmltZ0VsZW1lbnQgPSBpbWFnZUVsZW1lbnQ7XG4gICAgdGhpcy5rZWVwTWFya2VyQ2VudGVyZWQgPSBrZWVwTWFya2VyQ2VudGVyZWQ7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmN1clBvaW50ZXJYUG9zID0gMDtcbiAgICB0aGlzLmN1clBvaW50ZXJZUG9zID0gMDtcbiAgICB0aGlzLm1hcmtlckRlbHRhWCA9IDA7XG4gICAgdGhpcy5tYXJrZXJEZWx0YVkgPSAwO1xuICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vblBvaW50ZXJEb3duSW1hZ2UpKTtcbiAgICBpZiAoIXRoaXMua2VlcE1hcmtlckNlbnRlcmVkKSB7XG4gICAgICB0aGlzLm1hcmtlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25Qb2ludGVyRG93bk1hcmtlcikpO1xuICAgIH1cbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUFuY2hvclJlc2l6ZSkpO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5tYXJrZXJFbGVtZW50KTtcbiAgfVxuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2FuY2hvcik7XG4gIH1cbiAgc2V0IGFuY2hvcihuZXdBbmNob3IpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2FuY2hvciwgbmV3QW5jaG9yKTtcbiAgICBbdGhpcy5hbmNob3JPZmZzZXRYLCB0aGlzLmFuY2hvck9mZnNldFldID0gZ2V0QW5jaG9yT2Zmc2V0KHRoaXMubWFya2VyRWxlbWVudCwgbmV3QW5jaG9yKTtcbiAgICB0aGlzLm1hcmtlclRyYW5zZm9ybSA9IHtcbiAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yT2Zmc2V0WCxcbiAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yT2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgZ2V0IG1hcmtlclRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJUcmFuc2Zvcm0pO1xuICB9XG4gIHNldCBtYXJrZXJUcmFuc2Zvcm0odmFsKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tYXJrZXJUcmFuc2Zvcm0sIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlclRyYW5zZm9ybSkpLCB2YWwpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZU1hcmtlclRyYW5zZm9ybSkuY2FsbCh0aGlzKTtcbiAgfVxuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaXNBY3RpdmUpO1xuICB9XG4gIHNldCBpc0FjdGl2ZSh2YWwpIHtcbiAgICB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSB2YWwgPyBcIm5vbmVcIiA6IFwiXCI7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9pc0FjdGl2ZSwgdmFsKTtcbiAgfVxuICBnZXQgY29vcmRpbmF0ZSgpIHtcbiAgICBjb25zdCBhZGp1c3RlZFB4ID0gdGhpcy5rZWVwTWFya2VyQ2VudGVyZWQgPyB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHggOiBbXG4gICAgICB0aGlzLmltZ0NlbnRlclB4WzBdIC0gdGhpcy5tYXJrZXJEZWx0YVgsXG4gICAgICB0aGlzLmltZ0NlbnRlclB4WzFdICsgdGhpcy5tYXJrZXJEZWx0YVlcbiAgICBdO1xuICAgIGlmIChkZWVwRXF1YWxzKGFkanVzdGVkUHgsIHRoaXMuaW1nQ2VudGVyUHgpKSB7XG4gICAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9vcmlnaW5hbENvb3JkaW5hdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsbmdMYXQgPSBtZXJjLmxsKGFkanVzdGVkUHgsIHRoaXMuem9vbSk7XG4gICAgICByZXR1cm4gW3JvdW5kKGxuZ0xhdFswXSwgNiksIHJvdW5kKGxuZ0xhdFsxXSwgNildO1xuICAgIH1cbiAgfVxuICBzZXQgY29vcmRpbmF0ZShsbmdMYXQpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29yaWdpbmFsQ29vcmRpbmF0ZSwgbG5nTGF0KTtcbiAgICB0aGlzLmltZ0NlbnRlclB4ID0gdGhpcy5pbWdDZW50ZXJBZGp1c3RlZFB4ID0gbWVyYy5weChsbmdMYXQsIHRoaXMuem9vbSk7XG4gIH1cbiAgZ2V0IGltZ0NlbnRlck9mZnNldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5pbWdDZW50ZXJQeFswXSAtIHRoaXMuaW1nQ2VudGVyQWRqdXN0ZWRQeFswXSxcbiAgICAgIHk6IHRoaXMuaW1nQ2VudGVyUHhbMV0gLSB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHhbMV1cbiAgICB9O1xuICB9XG59O1xuX2FuY2hvciA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlQW5jaG9yUmVzaXplID0gbmV3IFdlYWtNYXAoKTtcbl9tYXJrZXJUcmFuc2Zvcm0gPSBuZXcgV2Vha01hcCgpO1xuX2lzQWN0aXZlID0gbmV3IFdlYWtNYXAoKTtcbl9vcmlnaW5hbENvb3JkaW5hdGUgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlckRvd25NYXJrZXIgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlclVwTWFya2VyID0gbmV3IFdlYWtNYXAoKTtcbl9vblBvaW50ZXJNb3ZlTWFya2VyID0gbmV3IFdlYWtNYXAoKTtcbl9vblBvaW50ZXJEb3duSW1hZ2UgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlclVwSW1hZ2UgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlck1vdmVJbWFnZSA9IG5ldyBXZWFrTWFwKCk7XG5fdXBkYXRlUG9pbnRlclBvc2l0aW9uID0gbmV3IFdlYWtNYXAoKTtcbl91cGRhdGVNYXJrZXJUcmFuc2Zvcm0gPSBuZXcgV2Vha01hcCgpO1xuX3VwZGF0ZU1hcmtlckNvcnJlY3Rpb24gPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBzcmMvaWNvbnMvbWFwYm94Z2wtY3RybC1sb2dvLnN2Z1xudmFyIG1hcGJveGdsX2N0cmxfbG9nb19kZWZhdWx0ID0gJzxzdmcgd2lkdGg9XCI4OFwiIGhlaWdodD1cIjIzXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj48ZGVmcz48cGF0aCBpZD1cImdcIiBkPVwiTTExLjUgMi4yNWE5LjI1IDkuMjUgMCAxIDEgMCAxOC41IDkuMjUgOS4yNSAwIDAgMSAwLTE4LjV6TTcgMTUuOThjLS4wNS0uMzMtLjgzLTUuOCAyLjIzLTguODdhNC40IDQuNCAwIDAgMSAzLjEzLTEuMjhjMS4yNyAwIDIuNDkuNTEgMy4zOSAxLjQyLjkxLjkgMS40MiAyLjEyIDEuNDIgMy4zOWE0LjQgNC40IDAgMCAxLTEuMjggMy4xM0MxMi43MiAxNi45MyA3IDE2IDcgMTZ2LS4wMnptOC4zLTUuNDgtMiAuOC0uOCAyLS44LTItMi0uOCAyLS44LjgtMiAuOCAyIDIgLjh6XCIvPjxwYXRoIGlkPVwiYlwiIGQ9XCJNNTAuNjMgOGMuMTMgMCAuMjMuMS4yMy4yM1Y5Yy43LS43NiAxLjctMS4xOCAyLjczLTEuMTggMi4xNyAwIDMuOTUgMS44NSAzLjk1IDQuMTdzLTEuNzcgNC4xOS0zLjk0IDQuMTlBMy43NyAzLjc3IDAgMCAxIDUwLjg2IDE1djMuNzdjMCAuMTMtLjEuMjMtLjIzLjIzaC0xLjRhLjIzLjIzIDAgMCAxLS4yMy0uMjNWOC4yM2MwLS4xMi4xLS4yMy4yMy0uMjNoMS40em0tMy44Ni4wMS4wMS0uMDFjLjEzIDAgLjIyLjEuMjIuMjJ2Ny41NWMwIC4xMi0uMS4yMy0uMjMuMjNoLTEuNGEuMjMuMjMgMCAwIDEtLjIzLS4yM1YxNWEzLjcgMy43IDAgMCAxLTIuNzMgMS4xOWMtMi4xNyAwLTMuOTQtMS44Ny0zLjk0LTQuMTkgMC0yLjMyIDEuNzctNC4xOSAzLjk0LTQuMTkgMS4wMyAwIDIuMDIuNDMgMi43MyAxLjE4di0uNzVjMC0uMTIuMS0uMjMuMjMtLjIzaDEuNHptMjYuMzgtLjE5YTQuMjQgNC4yNCAwIDAgMC00LjE2IDMuMjkgNC4wNyA0LjA3IDAgMCAwIDAgMS43NyA0LjIzIDQuMjMgMCAwIDAgNC4xNyAzLjMgNC4yMiA0LjIyIDAgMCAwIDQuMjYtNC4xOSA0LjIgNC4yIDAgMCAwLTQuMjctNC4xN3pNNjAuNjMgNWMuMTMgMCAuMjMuMS4yMy4yM3YzLjc2Yy43LS43NiAxLjctMS4xOCAyLjczLTEuMThhNCA0IDAgMCAxIDMuODQgMy4yOGMuMTMuNTkuMTMgMS4yIDAgMS44YTQgNCAwIDAgMS0zLjg0IDMuMjlBMy43NyAzLjc3IDAgMCAxIDYwLjg2IDE1di43N2MwIC4xMi0uMS4yMy0uMjMuMjNoLTEuNGEuMjMuMjMgMCAwIDEtLjIzLS4yM1Y1LjIzYzAtLjEyLjEtLjIzLjIzLS4yM2gxLjR6bS0zNCAxMWgtMS40YS4yMy4yMyAwIDAgMS0uMjMtLjIzVjguMjJjLjAxLS4xMy4xLS4yMi4yMy0uMjJoMS40Yy4xMyAwIC4yMi4xMS4yMy4yMnYuNjhjLjUtLjY4IDEuMy0xLjA5IDIuMTYtMS4xaC4wM2MxLjA5IDAgMi4wOS42IDIuNiAxLjU1YTIuNzMgMi43MyAwIDAgMSAyLjQ0LTEuNTZjMS42MiAwIDIuOTMgMS4yNSAyLjkgMi43OGwuMDMgNS4yYzAgLjEzLS4xLjIzLS4yMy4yM2gtMS40MWEuMjMuMjMgMCAwIDEtLjIzLS4yM3YtNC41OWMwLS45OC0uNzQtMS43MS0xLjYyLTEuNzEtLjggMC0xLjQ2LjctMS41OSAxLjYybC4wMSA0LjY4YzAgLjEzLS4xMS4yMy0uMjMuMjNoLTEuNDFhLjIzLjIzIDAgMCAxLS4yMy0uMjN2LTQuNTljMC0uOTgtLjc0LTEuNzEtMS42Mi0xLjcxLS44NSAwLTEuNTQuNzktMS42IDEuOHY0LjVjMCAuMTMtLjEuMjMtLjIzLjIzem01My42MiAwaC0xLjYxYS4yNy4yNyAwIDAgMS0uMTItLjAzYy0uMS0uMDYtLjEzLS4xOS0uMDYtLjI4bDIuNDMtMy43MS0yLjQtMy42NWEuMjEuMjEgMCAwIDEtLjAyLS4xMi4yLjIgMCAwIDEgLjItLjIxaDEuNjFjLjEzIDAgLjI0LjA2LjMuMTdMODIgMTAuNTRsMS40LTIuMzdhLjM0LjM0IDAgMCAxIC4zLS4xN2gxLjZsLjEyLjAzYy4xLjA2LjEzLjE5LjA2LjI4bC0yLjM3IDMuNjUgMi40MyAzLjcuMDEuMTNhLjIuMiAwIDAgMS0uMi4yMWgtMS42MWEuMzMuMzMgMCAwIDEtLjMtLjE3bC0xLjQ0LTIuNDItMS40NCAyLjQyYS4zNC4zNCAwIDAgMS0uMy4xN3ptLTcuMTItMS40OUEyLjQ3IDIuNDcgMCAwIDEgNzAuNyAxMmEyLjQ3IDIuNDcgMCAwIDEgMi40Mi0yLjUyIDIuNDcgMi40NyAwIDAgMSAyLjQyIDIuNTEgMi40OCAyLjQ4IDAgMCAxLTIuNDIgMi41MnptLTE5Ljg3IDBhMi40OCAyLjQ4IDAgMCAxLTIuNDItMi40OHYtLjA3YTIuNDcgMi40NyAwIDAgMSAyLjQtMi40OSAyLjQ3IDIuNDcgMCAwIDEgMi40MSAyLjUxIDIuNDcgMi40NyAwIDAgMS0yLjM5IDIuNTN6bS04LjExLTIuNDhjLS4wMSAxLjM3LTEuMDkgMi40Ny0yLjQxIDIuNDdzLTIuNDItMS4xMi0yLjQyLTIuNTFhMi40NyAyLjQ3IDAgMCAxIDIuNC0yLjUyIDIuNDYgMi40NiAwIDAgMSAyLjQxIDIuNDhsLjAyLjA4em0xOC4xMiAyLjQ3YTIuNDcgMi40NyAwIDAgMS0yLjQxLTIuNDh2LS4wNmMuMDItMS4zOCAxLjA5LTIuNDggMi40MS0yLjQ4czIuNDIgMS4xMiAyLjQyIDIuNTFhMi40NyAyLjQ3IDAgMCAxLTIuNDIgMi41MXpcIi8+PC9kZWZzPjxtYXNrIGlkPVwiY1wiPjxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmaWxsPVwiI2ZmZlwiLz48dXNlIHhsaW5rOmhyZWY9XCIjZ1wiLz48dXNlIHhsaW5rOmhyZWY9XCIjYlwiLz48L21hc2s+PGcgb3BhY2l0eT1cIi4zXCIgc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjNcIj48Y2lyY2xlIG1hc2s9XCJ1cmwoI2MpXCIgY3g9XCIxMS41XCIgY3k9XCIxMS41XCIgcj1cIjkuMjVcIi8+PHVzZSB4bGluazpocmVmPVwiI2JcIiBtYXNrPVwidXJsKCNjKVwiLz48L2c+PGcgb3BhY2l0eT1cIi45XCIgZmlsbD1cIiNmZmZcIj48dXNlIHhsaW5rOmhyZWY9XCIjZ1wiLz48dXNlIHhsaW5rOmhyZWY9XCIjYlwiLz48L2c+PC9zdmc+JztcblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94QWRkcmVzc01pbmltYXAudHNcbnZhciBaT09NID0gMTY7XG52YXIgVEVNUExBVEU0ID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiTWFwYm94QWRkcmVzc01pbmltYXBcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICA8ZGl2IGNsYXNzPVwiTWluaW1hcEltYWdlQ29udGFpbmVyXCI+XG4gICAgICA8aW1nIGNsYXNzPVwiTWluaW1hcEltYWdlXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj48L2ltZz5cbiAgICAgIDxkaXYgY2xhc3M9XCJNaW5pbWFwSW5uZXJGcmFtZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiTWluaW1hcE1hcmtlclwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiTWluaW1hcEF0dHJpYnV0aW9uXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIk1pbmltYXBBdHRyaWJ1dGlvbkxvZ29cIj5cbiAgICAgICAgICAgIDxhIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vZm9sbG93XCIgaHJlZj1cImh0dHBzOi8vd3d3Lm1hcGJveC5jb20vXCIgYXJpYS1sYWJlbD1cIk1hcGJveCBsb2dvXCI+XG4gICAgICAgICAgICAgICR7bWFwYm94Z2xfY3RybF9sb2dvX2RlZmF1bHR9XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIk1pbmltYXBBdHRyaWJ1dGlvblRleHRcIj5cbiAgICAgICAgICAgIDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9J2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYWJvdXQvbWFwcy8nPlxceEE5IE1hcGJveDwvYT48YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPSdodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodCc+XFx4QTkgT3BlblN0cmVldE1hcDwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuYCk7XG52YXIgU1RZTEVfVE9HR0xFX1RFTVBMQVRFID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIk1pbmltYXBTdHlsZVRvZ2dsZVwiPjwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIEZPT1RFUl9URU1QTEFURSA9IGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGBcbjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIk1pbmltYXBGb290ZXJcIj5BZGp1c3QgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGlmIGl0IGRvZXNuJ3QgcHJlY2lzZWx5IG1hdGNoIHlvdXIgbG9jYXRpb24uIFRoaXMgaGVscHMgaW1wcm92ZSBhZGRyZXNzIGRhdGEgcXVhbGl0eS48L2Rpdj5cbjwvdGVtcGxhdGU+XG5gKTtcbnZhciBBREpVU1RfUElOX1RFWFQgPSBcIkFkanVzdCBwaW5cIjtcbnZhciBTQVZFX1RFWFQgPSBcIlNhdmVcIjtcbnZhciBDQU5DRUxfVEVYVCA9IFwiQ2FuY2VsXCI7XG52YXIgRURJVF9CVVRUT05TX1RFTVBMQVRFID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiTWluaW1hcEVkaXRCdXR0b25zXCI+XG4gICAgPGRpdiBjbGFzcz1cIkJ1dHRvbiBCdXR0b25QcmltYXJ5IE1pbmltYXBCdXR0b25BZGp1c3RcIj4ke0FESlVTVF9QSU5fVEVYVH08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiQnV0dG9uIEJ1dHRvblByaW1hcnkgTWluaW1hcEJ1dHRvblNhdmVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj4ke1NBVkVfVEVYVH08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiQnV0dG9uIE1pbmltYXBCdXR0b25DYW5jZWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj4ke0NBTkNFTF9URVhUfTwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5gKTtcbnZhciBfY2FuQWRqdXN0TWFya2VySW50ZXJuYWwsIF9pc0FkanVzdE1hcmtlckVkaXRpbmcsIF9pbWFnZUxvYWRlZCwgX2ZlYXR1cmUyLCBfdXJsLCBfd2lkdGgsIF9oZWlnaHQsIF9iaW5kaW5nNywgX21hcmtlckNvbnRyb2xsZXIsIF9hY2Nlc3NUb2tlbiwgX3RoZW1lSW50ZXJuYWw1LCBfc2F0ZWxsaXRlVG9nZ2xlSW50ZXJuYWwsIF9tYXBTdHlsZU1vZGUsIF9hZGp1c3RCdG5UZXh0LCBfc2F2ZUJ0blRleHQsIF9jYW5jZWxCdG5UZXh0LCBfZGVmYXVsdE1hcFN0eWxlLCBfZm9vdGVyLCBfY29udGFpbmVyLCBfdG9nZ2xlTWFya2VyRWRpdGluZywgX2hhbmRsZVN0YXJ0TWFya2VyRWRpdGluZywgX2hhbmRsZVNhdmVNYXJrZXJFZGl0aW5nLCBfaGFuZGxlQ2FuY2VsTWFya2VyRWRpdGluZywgX2hhbmRsZVRvZ2dsZU1hcFN0eWxlLCBfaGFuZGxlSW1hZ2VMb2FkLCBfaGFuZGxlSW1hZ2VFcnJvciwgX2dldEltYWdlVXJsLCBfdXBkYXRlSW1hZ2VTcmMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwsIF9zZXRTaXplLCBfYWRkTWFya2VyRWRpdENvbnRyb2xzLCBfcmVtb3ZlTWFya2VyRWRpdENvbnRyb2xzLCBfYWRkU2F0ZWxsaXRlVG9nZ2xlLCBfcmVtb3ZlU2F0ZWxsaXRlVG9nZ2xlO1xudmFyIE1hcGJveEFkZHJlc3NNaW5pbWFwID0gY2xhc3MgZXh0ZW5kcyBIVE1MU2NvcGVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9jYW5BZGp1c3RNYXJrZXJJbnRlcm5hbCwgZmFsc2UpO1xuICAgIHRoaXMua2VlcE1hcmtlckNlbnRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5tYXJrZXJBbmNob3IgPSBcImJvdHRvbVwiO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaXNBZGp1c3RNYXJrZXJFZGl0aW5nLCBmYWxzZSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9pbWFnZUxvYWRlZCwgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZmVhdHVyZTIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF91cmwsIFwiXCIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfd2lkdGgsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oZWlnaHQsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9iaW5kaW5nNywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21hcmtlckNvbnRyb2xsZXIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hY2Nlc3NUb2tlbiwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3RoZW1lSW50ZXJuYWw1LCB7fSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zYXRlbGxpdGVUb2dnbGVJbnRlcm5hbCwgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWFwU3R5bGVNb2RlLCBcImRlZmF1bHRcIik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hZGp1c3RCdG5UZXh0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2F2ZUJ0blRleHQsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9jYW5jZWxCdG5UZXh0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZGVmYXVsdE1hcFN0eWxlLCBbXCJtYXBib3hcIiwgXCJzdHJlZXRzLXYxMVwiXSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mb290ZXIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9jb250YWluZXIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90b2dnbGVNYXJrZXJFZGl0aW5nLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IEltYWdlQ29udGFpbmVyLCBCdXR0b25BZGp1c3QsIEJ1dHRvblNhdmUsIEJ1dHRvbkNhbmNlbCB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNyk7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9pc0FkanVzdE1hcmtlckVkaXRpbmcpKSB7XG4gICAgICAgIEltYWdlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5kYXRhc2V0LnNlZWR9LS1kcmFnZ2FibGVgKTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIEJ1dHRvbkFkanVzdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIEJ1dHRvblNhdmUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgICAgIEJ1dHRvbkNhbmNlbC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEltYWdlQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoYCR7dGhpcy5kYXRhc2V0LnNlZWR9LS1kcmFnZ2FibGVgKTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBCdXR0b25BZGp1c3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgICAgIEJ1dHRvblNhdmUuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICBCdXR0b25DYW5jZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3RhcnRNYXJrZXJFZGl0aW5nLCAoKSA9PiB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lzQWRqdXN0TWFya2VyRWRpdGluZywgdHJ1ZSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3RvZ2dsZU1hcmtlckVkaXRpbmcpLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTYXZlTWFya2VyRWRpdGluZywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZS5wcm9wZXJ0aWVzLmZ1bGxfYWRkcmVzcyAmJiAhZGVlcEVxdWFscyh0aGlzLmZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikuY29vcmRpbmF0ZSkpIHtcbiAgICAgICAgY29uc3QgW2xuZywgbGF0XSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikuY29vcmRpbmF0ZTtcbiAgICAgICAgc2VuZEZlZWRiYWNrKHRoaXMuYWNjZXNzVG9rZW4sIHtcbiAgICAgICAgICBvcmlnaW5hbENvb3JkaW5hdGU6IHRoaXMuZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgICAgICBvcmlnaW5hbEFkZHJlc3M6IHRoaXMuZmVhdHVyZS5wcm9wZXJ0aWVzLmZ1bGxfYWRkcmVzcyxcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogeyBsb25naXR1ZGU6IGxuZywgbGF0aXR1ZGU6IGxhdCB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9uU2F2ZU1hcmtlckxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMub25TYXZlTWFya2VyTG9jYXRpb24oX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5jb29yZGluYXRlKTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaXNBZGp1c3RNYXJrZXJFZGl0aW5nLCBmYWxzZSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3RvZ2dsZU1hcmtlckVkaXRpbmcpLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVDYW5jZWxNYXJrZXJFZGl0aW5nLCAoKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpLnJlQ2VudGVyKCk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lzQWRqdXN0TWFya2VyRWRpdGluZywgZmFsc2UpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF90b2dnbGVNYXJrZXJFZGl0aW5nKS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlVG9nZ2xlTWFwU3R5bGUsICgpID0+IHtcbiAgICAgIHRoaXMubWFwU3R5bGVNb2RlID0gdGhpcy5tYXBTdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzYXRlbGxpdGVcIiA6IFwiZGVmYXVsdFwiO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlSW1hZ2VMb2FkLCAoKSA9PiB7XG4gICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfaW1hZ2VMb2FkZWQpKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikucmVDZW50ZXIoKTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW1hZ2VMb2FkZWQsIHRydWUpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpLmhhbmRsZU1pbmltYXBSZXNpemUoKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUltYWdlRXJyb3IsICgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW1hZ2VMb2FkZWQsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldEltYWdlVXJsLCAobG5nTGF0TGlrZSkgPT4ge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpID09PSAwIHx8IF9fcHJpdmF0ZUdldCh0aGlzLCBfaGVpZ2h0KSA9PT0gMClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBjb25zdCBbdXNlcm5hbWUsIHN0eWxlSWRdID0gdGhpcy5kZWZhdWx0TWFwU3R5bGU7XG4gICAgICBjb25zdCBkZWZhdWx0QmFzZVVybCA9IGdldFN0YXRpY0Jhc2VVcmwodXNlcm5hbWUsIHN0eWxlSWQpO1xuICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMubWFwU3R5bGVNb2RlID09PSBcImRlZmF1bHRcIiA/IGRlZmF1bHRCYXNlVXJsIDogU1RBVElDX0JBU0VfVVJMX1NBVEVMTElURTtcbiAgICAgIGNvbnN0IHNrdVRva2VuID0gQVVUT0ZJTExfU0tVX1RPS0VOX1BSRUZJWCArIGNvbmZpZy5hdXRvZmlsbFNlc3Npb25Ub2tlbi50b1N0cmluZygpO1xuICAgICAgbGV0IGltZ1VybCA9IGJhc2VVcmwgKyBMbmdMYXQuY29udmVydChsbmdMYXRMaWtlKS50b0FycmF5KCkuam9pbihcIixcIikgKyBcIixcIiArIFpPT00gKyBcIiwwL1wiICsgTWF0aC5taW4oX19wcml2YXRlR2V0KHRoaXMsIF93aWR0aCkgKiAyLCBNQVhfSU1BR0VfRElNKSArIFwieFwiICsgTWF0aC5taW4oX19wcml2YXRlR2V0KHRoaXMsIF9oZWlnaHQpICogMiwgTUFYX0lNQUdFX0RJTSkgKyBcIj9hY2Nlc3NfdG9rZW49XCIgKyB0aGlzLmFjY2Vzc1Rva2VuICsgXCImYXR0cmlidXRpb249ZmFsc2UmbG9nbz1mYWxzZVwiO1xuICAgICAgaWYgKGNvbmZpZy5hdXRvZmlsbFNlc3Npb25FbmFibGVkKSB7XG4gICAgICAgIGltZ1VybCArPSBgJnNrdT0ke3NrdVRva2VufWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nVXJsO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXBkYXRlSW1hZ2VTcmMsICgpID0+IHtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKSkge1xuICAgICAgICBjb25zdCBsbmdMYXQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF91cmwsIF9fcHJpdmF0ZUdldCh0aGlzLCBfZ2V0SW1hZ2VVcmwpLmNhbGwodGhpcywgbG5nTGF0KSk7XG4gICAgICAgIGNvbnN0IHsgSW1hZ2UgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzcpO1xuICAgICAgICBJbWFnZS5zcmMgPSBfX3ByaXZhdGVHZXQodGhpcywgX3VybCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwsIChzdHlsZU1vZGUpID0+IHtcbiAgICAgIHJldHVybiBgdXJsKFwiJHtnZXRJbWFnZShzdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzdHlsZVRvZ2dsZURlZmF1bHRcIiA6IFwic3R5bGVUb2dnbGVTYXRlbGxpdGVcIiwgdGhpcy50aGVtZSl9XCIpYDtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NldFNpemUsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgTWFwYm94QWRkcmVzc01pbmltYXA6IE1hcGJveEFkZHJlc3NNaW5pbWFwMiwgSW1hZ2VDb250YWluZXIsIEltYWdlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc3KTtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RWxlbWVudFNpemUodGhpcy5jb250YWluZXIpO1xuICAgICAgY29uc3QgW29sZFdpZHRoLCBvbGRIZWlnaHRdID0gW19fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpLCBfX3ByaXZhdGVHZXQodGhpcywgX2hlaWdodCldO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF93aWR0aCwgTWF0aC5taW4od2lkdGgsIE1BWF9JTUFHRV9ESU0pKTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGVpZ2h0LCBNYXRoLm1pbihoZWlnaHQsIE1BWF9JTUFHRV9ESU0pKTtcbiAgICAgIE1hcGJveEFkZHJlc3NNaW5pbWFwMi5zdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIGAke19fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpfXB4YCk7XG4gICAgICBNYXBib3hBZGRyZXNzTWluaW1hcDIuc3R5bGUuc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgYCR7X19wcml2YXRlR2V0KHRoaXMsIF9oZWlnaHQpfXB4YCk7XG4gICAgICBJbWFnZUNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcImhlaWdodFwiLCBgJHtfX3ByaXZhdGVHZXQodGhpcywgX2hlaWdodCl9cHhgKTtcbiAgICAgIEltYWdlQ29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwid2lkdGhcIiwgYCR7X19wcml2YXRlR2V0KHRoaXMsIF93aWR0aCl9cHhgKTtcbiAgICAgIGNvbnN0IFtpbWdXaWR0aCwgaW1nSGVpZ2h0XSA9IFtJbWFnZS53aWR0aCwgSW1hZ2UuaGVpZ2h0XTtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3dpZHRoKSA+IG9sZFdpZHRoICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpID4gaW1nV2lkdGggLyAyICYmIGltZ1dpZHRoIDwgTUFYX0lNQUdFX0RJTSB8fCBfX3ByaXZhdGVHZXQodGhpcywgX2hlaWdodCkgPiBvbGRIZWlnaHQgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9oZWlnaHQpID4gaW1nSGVpZ2h0IC8gMiAmJiBpbWdIZWlnaHQgPCBNQVhfSU1BR0VfRElNKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlSW1hZ2VTcmMpLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikuaGFuZGxlTWluaW1hcFJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWRkTWFya2VyRWRpdENvbnRyb2xzLCAoKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ0Zvb3RlciA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwRm9vdGVyXCIpO1xuICAgICAgaWYgKGV4aXN0aW5nRm9vdGVyKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBmb290ZXJFbGVtZW50ID0gdGhpcy5wcmVwYXJlVGVtcGxhdGUoRk9PVEVSX1RFTVBMQVRFKTtcbiAgICAgIGNvbnN0IG1pbmltYXBFbGVtZW50ID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1hcGJveEFkZHJlc3NNaW5pbWFwXCIpO1xuICAgICAgaWYgKCFtaW5pbWFwRWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbWluaW1hcEVsZW1lbnQuYXBwZW5kQ2hpbGQoZm9vdGVyRWxlbWVudCk7XG4gICAgICBjb25zdCBleGlzdGluZ0VkaXRCdG5zID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBFZGl0QnV0dG9uc1wiKTtcbiAgICAgIGlmIChleGlzdGluZ0VkaXRCdG5zKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBlZGl0QnV0dG9uc0VsZW1lbnQgPSB0aGlzLnByZXBhcmVUZW1wbGF0ZShFRElUX0JVVFRPTlNfVEVNUExBVEUpO1xuICAgICAgY29uc3QgaW5uZXJGcmFtZSA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwSW5uZXJGcmFtZVwiKTtcbiAgICAgIGlubmVyRnJhbWUuYXBwZW5kQ2hpbGQoZWRpdEJ1dHRvbnNFbGVtZW50KTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYmluZGluZzcsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzcpKSwge1xuICAgICAgICBFZGl0QnV0dG9uczogdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBFZGl0QnV0dG9uc1wiKSxcbiAgICAgICAgQnV0dG9uQWRqdXN0OiB0aGlzLnF1ZXJ5U2VsZWN0b3IoXCIuTWluaW1hcEJ1dHRvbkFkanVzdFwiKSxcbiAgICAgICAgQnV0dG9uU2F2ZTogdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBCdXR0b25TYXZlXCIpLFxuICAgICAgICBCdXR0b25DYW5jZWw6IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwQnV0dG9uQ2FuY2VsXCIpXG4gICAgICB9KSk7XG4gICAgICBjb25zdCB7IEJ1dHRvbkFkanVzdCwgQnV0dG9uU2F2ZSwgQnV0dG9uQ2FuY2VsIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc3KTtcbiAgICAgIEJ1dHRvbkFkanVzdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdGFydE1hcmtlckVkaXRpbmcpKTtcbiAgICAgIEJ1dHRvblNhdmUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU2F2ZU1hcmtlckVkaXRpbmcpKTtcbiAgICAgIEJ1dHRvbkNhbmNlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDYW5jZWxNYXJrZXJFZGl0aW5nKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yZW1vdmVNYXJrZXJFZGl0Q29udHJvbHMsICgpID0+IHtcbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgRWRpdEJ1dHRvbnMsIEJ1dHRvbkFkanVzdCwgQnV0dG9uU2F2ZSwgQnV0dG9uQ2FuY2VsIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc3KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nRm9vdGVyID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBGb290ZXJcIik7XG4gICAgICBleGlzdGluZ0Zvb3RlciA9PSBudWxsID8gdm9pZCAwIDogZXhpc3RpbmdGb290ZXIucmVtb3ZlKCk7XG4gICAgICBFZGl0QnV0dG9ucyA9PSBudWxsID8gdm9pZCAwIDogRWRpdEJ1dHRvbnMucmVtb3ZlKCk7XG4gICAgICBpZiAoQnV0dG9uQWRqdXN0KSB7XG4gICAgICAgIEJ1dHRvbkFkanVzdC5yZW1vdmUoKTtcbiAgICAgICAgQnV0dG9uQWRqdXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN0YXJ0TWFya2VyRWRpdGluZykpO1xuICAgICAgfVxuICAgICAgaWYgKEJ1dHRvblNhdmUpIHtcbiAgICAgICAgQnV0dG9uU2F2ZS5yZW1vdmUoKTtcbiAgICAgICAgQnV0dG9uU2F2ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTYXZlTWFya2VyRWRpdGluZykpO1xuICAgICAgfVxuICAgICAgaWYgKEJ1dHRvbkNhbmNlbCkge1xuICAgICAgICBCdXR0b25DYW5jZWwucmVtb3ZlKCk7XG4gICAgICAgIEJ1dHRvbkNhbmNlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDYW5jZWxNYXJrZXJFZGl0aW5nKSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNykuRWRpdEJ1dHRvbnM7XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNykuQnV0dG9uQWRqdXN0O1xuICAgICAgZGVsZXRlIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzcpLkJ1dHRvblNhdmU7XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNykuQnV0dG9uQ2FuY2VsO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWRkU2F0ZWxsaXRlVG9nZ2xlLCAoKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ1RvZ2dsZSA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwU3R5bGVUb2dnbGVcIik7XG4gICAgICBpZiAoZXhpc3RpbmdUb2dnbGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHRvZ2dsZUVsZW1lbnQgPSB0aGlzLnByZXBhcmVUZW1wbGF0ZShTVFlMRV9UT0dHTEVfVEVNUExBVEUpO1xuICAgICAgY29uc3QgaW5uZXJGcmFtZSA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwSW5uZXJGcmFtZVwiKTtcbiAgICAgIGlmICghaW5uZXJGcmFtZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaW5uZXJGcmFtZS5hcHBlbmRDaGlsZCh0b2dnbGVFbGVtZW50KTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzcpLk1hcFN0eWxlVG9nZ2xlID0gdG9nZ2xlRWxlbWVudDtcbiAgICAgIHRvZ2dsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlVG9nZ2xlTWFwU3R5bGUpKTtcbiAgICAgIHRvZ2dsZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gX19wcml2YXRlR2V0KHRoaXMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwpLmNhbGwodGhpcywgdGhpcy5tYXBTdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzYXRlbGxpdGVcIiA6IFwiZGVmYXVsdFwiKTtcbiAgICAgIHRvZ2dsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgYFN3aXRjaCB0byAke3RoaXMubWFwU3R5bGVNb2RlID09PSBcImRlZmF1bHRcIiA/IFwiU2F0ZWxsaXRlXCIgOiBcIkRlZmF1bHRcIn1gKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3JlbW92ZVNhdGVsbGl0ZVRvZ2dsZSwgKCkgPT4ge1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBNYXBTdHlsZVRvZ2dsZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNyk7XG4gICAgICBpZiAoIU1hcFN0eWxlVG9nZ2xlKVxuICAgICAgICByZXR1cm47XG4gICAgICBNYXBTdHlsZVRvZ2dsZS5yZW1vdmUoKTtcbiAgICAgIE1hcFN0eWxlVG9nZ2xlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVRvZ2dsZU1hcFN0eWxlKSk7XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNykuTWFwU3R5bGVUb2dnbGU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGNhbkFkanVzdE1hcmtlcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9jYW5BZGp1c3RNYXJrZXJJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IGNhbkFkanVzdE1hcmtlcih2YWwpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NhbkFkanVzdE1hcmtlckludGVybmFsLCB2YWwpO1xuICAgIHZhbCA/IF9fcHJpdmF0ZUdldCh0aGlzLCBfYWRkTWFya2VyRWRpdENvbnRyb2xzKS5jYWxsKHRoaXMpIDogX19wcml2YXRlR2V0KHRoaXMsIF9yZW1vdmVNYXJrZXJFZGl0Q29udHJvbHMpLmNhbGwodGhpcyk7XG4gIH1cbiAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2FjY2Vzc1Rva2VuKSB8fCBjb25maWcuYWNjZXNzVG9rZW47XG4gIH1cbiAgc2V0IGFjY2Vzc1Rva2VuKG5ld1Rva2VuKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9hY2Nlc3NUb2tlbiwgbmV3VG9rZW4pO1xuICB9XG4gIGdldCBmZWF0dXJlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKTtcbiAgfVxuICBzZXQgZmVhdHVyZShmZWF0dXJlKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9mZWF0dXJlMiwgZmVhdHVyZSk7XG4gICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG4gIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gVEVNUExBVEU0O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVN0eWxlKCkge1xuICAgIHJldHVybiBzdHlsZV9kZWZhdWx0O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVVzZXJTdHlsZSgpIHtcbiAgICByZXR1cm4gZ2V0VGhlbWVDU1MoXCIuTWFwYm94QWRkcmVzc01pbmltYXBcIiwgdGhpcy50aGVtZSk7XG4gIH1cbiAgZ2V0IHNhdGVsbGl0ZVRvZ2dsZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zYXRlbGxpdGVUb2dnbGVJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IHNhdGVsbGl0ZVRvZ2dsZSh2YWwpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NhdGVsbGl0ZVRvZ2dsZUludGVybmFsLCB2YWwpO1xuICAgIHZhbCA/IF9fcHJpdmF0ZUdldCh0aGlzLCBfYWRkU2F0ZWxsaXRlVG9nZ2xlKS5jYWxsKHRoaXMpIDogX19wcml2YXRlR2V0KHRoaXMsIF9yZW1vdmVTYXRlbGxpdGVUb2dnbGUpLmNhbGwodGhpcyk7XG4gIH1cbiAgZ2V0IHRoZW1lKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3RoZW1lSW50ZXJuYWw1KTtcbiAgfVxuICBzZXQgdGhlbWUodGhlbWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3RoZW1lSW50ZXJuYWw1LCB0aGVtZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc3KSB8fCAhdGhlbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUZW1wbGF0ZVVzZXJTdHlsZShnZXRUaGVtZUNTUyhcIi5NYXBib3hBZGRyZXNzTWluaW1hcFwiLCB0aGVtZSkpO1xuICAgIGNvbnN0IHsgTWFya2VyLCBNYXBTdHlsZVRvZ2dsZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNyk7XG4gICAgTWFya2VyLmlubmVySFRNTCA9IGdldEljb24oXCJtYXJrZXJcIiwgdGhlbWUpO1xuICAgIGlmIChNYXBTdHlsZVRvZ2dsZSkge1xuICAgICAgTWFwU3R5bGVUb2dnbGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gX19wcml2YXRlR2V0KHRoaXMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwpLmNhbGwodGhpcywgdGhpcy5tYXBTdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzYXRlbGxpdGVcIiA6IFwiZGVmYXVsdFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFkanVzdEJ0blRleHQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWRqdXN0QnRuVGV4dCkgfHwgQURKVVNUX1BJTl9URVhUO1xuICB9XG4gIHNldCBhZGp1c3RCdG5UZXh0KHZhbCkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYWRqdXN0QnRuVGV4dCwgdmFsKTtcbiAgICBjb25zdCBhZGp1c3RCdG4gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoXCIuTWluaW1hcEJ1dHRvbkFkanVzdFwiKTtcbiAgICBhZGp1c3RCdG4udGV4dENvbnRlbnQgPSB2YWwgfHwgQURKVVNUX1BJTl9URVhUO1xuICB9XG4gIGdldCBzYXZlQnRuVGV4dCgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zYXZlQnRuVGV4dCkgfHwgU0FWRV9URVhUO1xuICB9XG4gIHNldCBzYXZlQnRuVGV4dCh2YWwpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NhdmVCdG5UZXh0LCB2YWwpO1xuICAgIGNvbnN0IHNhdmVCdG4gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoXCIuTWluaW1hcEJ1dHRvblNhdmVcIik7XG4gICAgc2F2ZUJ0bi50ZXh0Q29udGVudCA9IHZhbCB8fCBTQVZFX1RFWFQ7XG4gIH1cbiAgZ2V0IGNhbmNlbEJ0blRleHQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FuY2VsQnRuVGV4dCkgfHwgQ0FOQ0VMX1RFWFQ7XG4gIH1cbiAgc2V0IGNhbmNlbEJ0blRleHQodmFsKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9jYW5jZWxCdG5UZXh0LCB2YWwpO1xuICAgIGNvbnN0IGNhbmNlbEJ0biA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwQnV0dG9uQ2FuY2VsXCIpO1xuICAgIGNhbmNlbEJ0bi50ZXh0Q29udGVudCA9IHZhbCB8fCBDQU5DRUxfVEVYVDtcbiAgfVxuICBnZXQgbWFwU3R5bGVNb2RlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX21hcFN0eWxlTW9kZSk7XG4gIH1cbiAgc2V0IG1hcFN0eWxlTW9kZShzdHlsZU1vZGUpIHtcbiAgICBjb25zdCBwcmV2U3R5bGVNb2RlID0gX19wcml2YXRlR2V0KHRoaXMsIF9tYXBTdHlsZU1vZGUpO1xuICAgIGlmIChwcmV2U3R5bGVNb2RlID09PSBzdHlsZU1vZGUpXG4gICAgICByZXR1cm47XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tYXBTdHlsZU1vZGUsIHN0eWxlTW9kZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc3KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IE1hcFN0eWxlVG9nZ2xlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc3KTtcbiAgICBpZiAoIU1hcFN0eWxlVG9nZ2xlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE1hcFN0eWxlVG9nZ2xlLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZ2V0VG9nZ2xlQmFja2dyb3VuZEltYWdlVXJsKS5jYWxsKHRoaXMsIHByZXZTdHlsZU1vZGUpO1xuICAgIE1hcFN0eWxlVG9nZ2xlLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIGBTd2l0Y2ggdG8gJHtwcmV2U3R5bGVNb2RlID09PSBcInNhdGVsbGl0ZVwiID8gXCJTYXRlbGxpdGVcIiA6IFwiRGVmYXVsdFwifWApO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlSW1hZ2VTcmMpLmNhbGwodGhpcyk7XG4gIH1cbiAgZ2V0IGRlZmF1bHRNYXBTdHlsZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9kZWZhdWx0TWFwU3R5bGUpO1xuICB9XG4gIHNldCBkZWZhdWx0TWFwU3R5bGUoc3R5bGUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2RlZmF1bHRNYXBTdHlsZSwgc3R5bGUpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlSW1hZ2VTcmMpLmNhbGwodGhpcyk7XG4gIH1cbiAgZ2V0IGZvb3RlcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9mb290ZXIpO1xuICB9XG4gIHNldCBmb290ZXIodmFsKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9mb290ZXIsIHZhbCk7XG4gICAgY29uc3QgZm9vdGVyRWwgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoXCIuTWluaW1hcEZvb3RlclwiKTtcbiAgICBpZiAoZm9vdGVyRWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvb3RlckVsLnRleHRDb250ZW50ID0gdmFsO1xuICAgICAgICBmb290ZXJFbC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbCkge1xuICAgICAgICBmb290ZXJFbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb290ZXJFbC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9jb250YWluZXIpO1xuICB9XG4gIHNldCBjb250YWluZXIobmV3Q29udGFpbmVyKSB7XG4gICAgaWYgKG5ld0NvbnRhaW5lcikge1xuICAgICAgbmV3Q29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jb250YWluZXIsIG5ld0NvbnRhaW5lcik7XG4gICAgfVxuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsbmdMYXQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpLmNvb3JkaW5hdGUgPSBsbmdMYXQ7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF91cmwsIF9fcHJpdmF0ZUdldCh0aGlzLCBfZ2V0SW1hZ2VVcmwpLmNhbGwodGhpcywgbG5nTGF0KSk7XG4gICAgY29uc3QgeyBNYXBib3hBZGRyZXNzTWluaW1hcDogTWFwYm94QWRkcmVzc01pbmltYXAyLCBJbWFnZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNyk7XG4gICAgSW1hZ2Uuc3JjID0gX19wcml2YXRlR2V0KHRoaXMsIF91cmwpO1xuICAgIE1hcGJveEFkZHJlc3NNaW5pbWFwMi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGNvbnN0IHsgTWFwYm94QWRkcmVzc01pbmltYXA6IE1hcGJveEFkZHJlc3NNaW5pbWFwMiB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNyk7XG4gICAgTWFwYm94QWRkcmVzc01pbmltYXAyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYmluZGluZzcsIGJpbmRFbGVtZW50cyh0aGlzLCB7XG4gICAgICBNYXBib3hBZGRyZXNzTWluaW1hcDogXCIuTWFwYm94QWRkcmVzc01pbmltYXBcIixcbiAgICAgIEltYWdlQ29udGFpbmVyOiBcIi5NaW5pbWFwSW1hZ2VDb250YWluZXJcIixcbiAgICAgIEltYWdlOiBcIi5NaW5pbWFwSW1hZ2VcIixcbiAgICAgIE1hcmtlcjogXCIuTWluaW1hcE1hcmtlclwiLFxuICAgICAgTWFwU3R5bGVUb2dnbGU6IFwiLk1pbmltYXBTdHlsZVRvZ2dsZVwiLFxuICAgICAgRWRpdEJ1dHRvbnM6IFwiLk1pbmltYXBFZGl0QnV0dG9uc1wiLFxuICAgICAgQnV0dG9uQWRqdXN0OiBcIi5NaW5pbWFwQnV0dG9uQWRqdXN0XCIsXG4gICAgICBCdXR0b25TYXZlOiBcIi5NaW5pbWFwQnV0dG9uU2F2ZVwiLFxuICAgICAgQnV0dG9uQ2FuY2VsOiBcIi5NaW5pbWFwQnV0dG9uQ2FuY2VsXCJcbiAgICB9KSk7XG4gICAgdGhpcy5tYXBTdHlsZU1vZGUgPSBfX3ByaXZhdGVHZXQodGhpcywgX21hcFN0eWxlTW9kZSk7XG4gICAgdGhpcy50aGVtZSA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLnRoZW1lKTtcbiAgICBpZiAodGhpcy5jYW5BZGp1c3RNYXJrZXIpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWRkTWFya2VyRWRpdENvbnRyb2xzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zYXRlbGxpdGVUb2dnbGUpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWRkU2F0ZWxsaXRlVG9nZ2xlKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfX3ByaXZhdGVHZXQodGhpcywgX3NldFNpemUpKTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY29udGFpbmVyKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NldFNpemUpLmNhbGwodGhpcyk7XG4gICAgY29uc3QgeyBNYXBib3hBZGRyZXNzTWluaW1hcDogTWFwYm94QWRkcmVzc01pbmltYXAyLCBJbWFnZUNvbnRhaW5lciwgSW1hZ2UsIE1hcmtlciB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNyk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyLCBuZXcgTWFya2VyQ29udHJvbGxlcihJbWFnZUNvbnRhaW5lciwgSW1hZ2UsIE1hcmtlciwgdGhpcy5rZWVwTWFya2VyQ2VudGVyZWQsIFpPT00sIHRoaXMubWFya2VyQW5jaG9yKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5yZUNlbnRlcigpO1xuICAgIEltYWdlLm9ubG9hZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlSW1hZ2VMb2FkKTtcbiAgICBJbWFnZS5vbmVycm9yID0gX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVJbWFnZUVycm9yKTtcbiAgICBJbWFnZS5zcmMgPSBfX3ByaXZhdGVHZXQodGhpcywgX3VybCk7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZmVhdHVyZTIpKVxuICAgICAgTWFwYm94QWRkcmVzc01pbmltYXAyLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgIGVsc2VcbiAgICAgIE1hcGJveEFkZHJlc3NNaW5pbWFwMi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcImFjY2Vzcy10b2tlblwiKSB7XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbmV3VmFsdWU7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcImNhbi1hZGp1c3QtbWFya2VyXCIpIHtcbiAgICAgIHRoaXMuY2FuQWRqdXN0TWFya2VyID0gbmV3VmFsdWUgPT09IFwidHJ1ZVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJrZWVwLW1hcmtlci1jZW50ZXJlZFwiKSB7XG4gICAgICB0aGlzLmtlZXBNYXJrZXJDZW50ZXJlZCA9IG5ld1ZhbHVlID09PSBcInRydWVcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwibWFya2VyLWFuY2hvclwiKSB7XG4gICAgICBjb25zdCBuZXdBbmNob3IgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMubWFya2VyQW5jaG9yID0gbmV3QW5jaG9yO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKSAmJiAoX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5hbmNob3IgPSBuZXdBbmNob3IpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzYXRlbGxpdGUtdG9nZ2xlXCIpIHtcbiAgICAgIHRoaXMuc2F0ZWxsaXRlVG9nZ2xlID0gbmV3VmFsdWUgPT09IFwidHJ1ZVwiO1xuICAgIH1cbiAgfVxufTtcbl9jYW5BZGp1c3RNYXJrZXJJbnRlcm5hbCA9IG5ldyBXZWFrTWFwKCk7XG5faXNBZGp1c3RNYXJrZXJFZGl0aW5nID0gbmV3IFdlYWtNYXAoKTtcbl9pbWFnZUxvYWRlZCA9IG5ldyBXZWFrTWFwKCk7XG5fZmVhdHVyZTIgPSBuZXcgV2Vha01hcCgpO1xuX3VybCA9IG5ldyBXZWFrTWFwKCk7XG5fd2lkdGggPSBuZXcgV2Vha01hcCgpO1xuX2hlaWdodCA9IG5ldyBXZWFrTWFwKCk7XG5fYmluZGluZzcgPSBuZXcgV2Vha01hcCgpO1xuX21hcmtlckNvbnRyb2xsZXIgPSBuZXcgV2Vha01hcCgpO1xuX2FjY2Vzc1Rva2VuID0gbmV3IFdlYWtNYXAoKTtcbl90aGVtZUludGVybmFsNSA9IG5ldyBXZWFrTWFwKCk7XG5fc2F0ZWxsaXRlVG9nZ2xlSW50ZXJuYWwgPSBuZXcgV2Vha01hcCgpO1xuX21hcFN0eWxlTW9kZSA9IG5ldyBXZWFrTWFwKCk7XG5fYWRqdXN0QnRuVGV4dCA9IG5ldyBXZWFrTWFwKCk7XG5fc2F2ZUJ0blRleHQgPSBuZXcgV2Vha01hcCgpO1xuX2NhbmNlbEJ0blRleHQgPSBuZXcgV2Vha01hcCgpO1xuX2RlZmF1bHRNYXBTdHlsZSA9IG5ldyBXZWFrTWFwKCk7XG5fZm9vdGVyID0gbmV3IFdlYWtNYXAoKTtcbl9jb250YWluZXIgPSBuZXcgV2Vha01hcCgpO1xuX3RvZ2dsZU1hcmtlckVkaXRpbmcgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN0YXJ0TWFya2VyRWRpdGluZyA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU2F2ZU1hcmtlckVkaXRpbmcgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUNhbmNlbE1hcmtlckVkaXRpbmcgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVRvZ2dsZU1hcFN0eWxlID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVJbWFnZUxvYWQgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUltYWdlRXJyb3IgPSBuZXcgV2Vha01hcCgpO1xuX2dldEltYWdlVXJsID0gbmV3IFdlYWtNYXAoKTtcbl91cGRhdGVJbWFnZVNyYyA9IG5ldyBXZWFrTWFwKCk7XG5fZ2V0VG9nZ2xlQmFja2dyb3VuZEltYWdlVXJsID0gbmV3IFdlYWtNYXAoKTtcbl9zZXRTaXplID0gbmV3IFdlYWtNYXAoKTtcbl9hZGRNYXJrZXJFZGl0Q29udHJvbHMgPSBuZXcgV2Vha01hcCgpO1xuX3JlbW92ZU1hcmtlckVkaXRDb250cm9scyA9IG5ldyBXZWFrTWFwKCk7XG5fYWRkU2F0ZWxsaXRlVG9nZ2xlID0gbmV3IFdlYWtNYXAoKTtcbl9yZW1vdmVTYXRlbGxpdGVUb2dnbGUgPSBuZXcgV2Vha01hcCgpO1xuTWFwYm94QWRkcmVzc01pbmltYXAub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gW1xuICBcImFjY2Vzcy10b2tlblwiLFxuICBcImNhbi1hZGp1c3QtbWFya2VyXCIsXG4gIFwia2VlcC1tYXJrZXItY2VudGVyZWRcIixcbiAgXCJtYXJrZXItYW5jaG9yXCIsXG4gIFwic2F0ZWxsaXRlLXRvZ2dsZVwiXG5dO1xud2luZG93Lk1hcGJveEFkZHJlc3NNaW5pbWFwID0gTWFwYm94QWRkcmVzc01pbmltYXA7XG5pZiAoIXdpbmRvdy5jdXN0b21FbGVtZW50cy5nZXQoXCJtYXBib3gtYWRkcmVzcy1taW5pbWFwXCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1hcGJveC1hZGRyZXNzLW1pbmltYXBcIiwgTWFwYm94QWRkcmVzc01pbmltYXApO1xufVxuXG4vLyBzcmMvYXV0b2ZpbGwudHNcbmltcG9ydCB7XG4gIEV2ZW50ZWQsXG4gIEFkZHJlc3NBdXRvZmlsbENvcmUgYXMgQWRkcmVzc0F1dG9maWxsQ29yZTIsXG4gIFNlYXJjaFNlc3Npb24gYXMgU2VhcmNoU2Vzc2lvbjRcbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbnZhciBfaW5wdXQ0LCBfY29sbGVjdGlvbiwgX3Nlc3Npb240LCBfaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlMiwgX29uSGFuZGxlSW5wdXQ0LCBfb25IYW5kbGVTZWxlY3Q0LCBfb25IYW5kbGVCbHVyNCwgX29uSGFuZGxlRm9jdXMyLCBfaGFuZGxlU3VnZ2VzdDQsIF9oYW5kbGVTdWdnZXN0RXJyb3I0LCBfaGFuZGxlUmV0cmlldmU0O1xudmFyIEFkZHJlc3NBdXRvZmlsbEluc3RhbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBpbnB1dCwgYXV0b2ZpbGxSZWYpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lucHV0NCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NvbGxlY3Rpb24sIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXNzaW9uNCwgdm9pZCAwKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLnJldHJpZXZlRmVhdHVyZSA9IG51bGw7XG4gICAgdGhpcy5saXN0Ym94ID0gbmV3IE1hcGJveFNlYXJjaExpc3Rib3goKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2luaXRpYWxBdXRvY29tcGxldGVWYWx1ZTIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vbkhhbmRsZUlucHV0NCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZS5kZXRhaWw7XG4gICAgICBjb25zdCBlbmFibGVCcm93c2VyQXV0b2NvbXBsZXRlID0gX19wcml2YXRlR2V0KHRoaXMsIF9jb2xsZWN0aW9uKS5icm93c2VyQXV0b2ZpbGxFbmFibGVkID09PSB0cnVlICYmICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUubGVuZ3RoKSA8PSAyO1xuICAgICAgdG9nZ2xlQXV0b2NvbXBsZXRpb24oX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDQpLCBfX3ByaXZhdGVHZXQodGhpcywgX2luaXRpYWxBdXRvY29tcGxldGVWYWx1ZTIpLCBlbmFibGVCcm93c2VyQXV0b2NvbXBsZXRlKTtcbiAgICAgIGlmICgodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLmxlbmd0aCkgPD0gMikge1xuICAgICAgICB0aGlzLmxpc3Rib3guaGFuZGxlU3VnZ2VzdChudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uNCkuc3VnZ2VzdCh2YWx1ZSwgdGhpcy5vcHRpb25zKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uSGFuZGxlU2VsZWN0NCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBlLmRldGFpbDtcbiAgICAgIGlmIChlLmRldGFpbC5hY2N1cmFjeSAhPT0gXCJzdHJlZXRcIikge1xuICAgICAgICB0b2dnbGVBdXRvY29tcGxldGlvbihfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0NCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlMiksIHRydWUpO1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb240KS5yZXRyaWV2ZShzdWdnZXN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlU3RyZWV0U2VsZWN0aW9uKF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQ0KSwgX19wcml2YXRlR2V0KHRoaXMsIF9pbml0aWFsQXV0b2NvbXBsZXRlVmFsdWUyKSwgc3VnZ2VzdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vbkhhbmRsZUJsdXI0LCAoKSA9PiB7XG4gICAgICB0b2dnbGVBdXRvY29tcGxldGlvbihfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0NCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlMiksIHRydWUpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uNCkuYWJvcnQoKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uSGFuZGxlRm9jdXMyLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBlbmFibGVCcm93c2VyQXV0b2NvbXBsZXRlID0gX19wcml2YXRlR2V0KHRoaXMsIF9jb2xsZWN0aW9uKS5icm93c2VyQXV0b2ZpbGxFbmFibGVkID09PSB0cnVlICYmICgoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0NCkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIDw9IDI7XG4gICAgICB0b2dnbGVBdXRvY29tcGxldGlvbihfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0NCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlMiksIGVuYWJsZUJyb3dzZXJBdXRvY29tcGxldGUpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3VnZ2VzdDQsIChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkU3VnZ2VzdGlvbnMgPSAocmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiByZXN1bHQuc3VnZ2VzdGlvbnMpID8gZGlzdGluY3RFeGFjdFN0cmVldFJlc3VsdHMocmVzdWx0LnN1Z2dlc3Rpb25zKSA6IG51bGw7XG4gICAgICB0aGlzLmxpc3Rib3guaGFuZGxlU3VnZ2VzdChmaWx0ZXJlZFN1Z2dlc3Rpb25zKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE1hcGJveEhUTUxFdmVudChcInN1Z2dlc3RcIiwgcmVzdWx0KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgXCJ0YXJnZXRcIiwgeyB2YWx1ZTogX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDQpIH0pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9jb2xsZWN0aW9uKS5maXJlKFwic3VnZ2VzdFwiLCBldmVudCk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3I0LCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMubGlzdGJveC5oYW5kbGVFcnJvcigpO1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWFwYm94SFRNTEV2ZW50KFwic3VnZ2VzdGVycm9yXCIsIGVycm9yKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgXCJ0YXJnZXRcIiwgeyB2YWx1ZTogX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDQpIH0pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9jb2xsZWN0aW9uKS5maXJlKFwic3VnZ2VzdGVycm9yXCIsIGV2ZW50KTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVJldHJpZXZlNCwgKHJlc3VsdCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWFwYm94SFRNTEV2ZW50KFwicmV0cmlldmVcIiwgcmVzdWx0KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgXCJ0YXJnZXRcIiwgeyB2YWx1ZTogX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDQpIH0pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9jb2xsZWN0aW9uKS5maXJlKFwicmV0cmlldmVcIiwgZXZlbnQpO1xuICAgICAgdGhpcy5yZXRyaWV2ZUZlYXR1cmUgPSAoX2EgPSByZXN1bHQuZmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZlYXR1cmVDb2xsZWN0aW9uID0gcmVzdWx0O1xuICAgICAgaWYgKCFmZWF0dXJlQ29sbGVjdGlvbiB8fCAhZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMgfHwgIWZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWxsRm9ybVdpdGhGZWF0dXJlKGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzWzBdLCBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0NCkpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW5wdXQ0LCBpbnB1dCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9jb2xsZWN0aW9uLCBjb2xsZWN0aW9uKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Nlc3Npb240LCBuZXcgU2VhcmNoU2Vzc2lvbjQoYXV0b2ZpbGxSZWYpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb240KS5zZXNzaW9uVG9rZW4gPSBjb25maWcuYXV0b2ZpbGxTZXNzaW9uVG9rZW47XG4gICAgdGhpcy5saXN0Ym94LmlucHV0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDQpO1xuICAgIHRoaXMubGlzdGJveC5hdXRvZmlsbEhvc3QgPSB0aGlzO1xuICAgIHRoaXMubGlzdGJveC5zZWFyY2hTZXJ2aWNlID0gMCAvKiBBZGRyZXNzQXV0b2ZpbGwgKi87XG4gICAgdGhpcy5saXN0Ym94LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlSW5wdXQ0KSk7XG4gICAgdGhpcy5saXN0Ym94LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZVNlbGVjdDQpKTtcbiAgICB0aGlzLmxpc3Rib3guYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vbkhhbmRsZUJsdXI0KSk7XG4gICAgdGhpcy5saXN0Ym94LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlRm9jdXMyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uNCkuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0NCkpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbjQpLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3I0KSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uNCkuYWRkRXZlbnRMaXN0ZW5lcihcInJldHJpZXZlXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlUmV0cmlldmU0KSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmxpc3Rib3gpO1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgaW5wdXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYmVmb3JlYmVnaW5cIiwgY3JlYXRlQXJpYUxpdmVFbGVtZW50KHRoaXMubGlzdGJveC5kYXRhU2VlZCkpO1xuICAgICAgc3VwcHJlc3NFeHRlbnNpb25zQXV0b2NvbXBsZXRlKGlucHV0KTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlMiwgaW5wdXQuYXV0b2NvbXBsZXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlucHV0KCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0NCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMubGlzdGJveC5yZW1vdmUoKTtcbiAgICB0aGlzLmxpc3Rib3gucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVJbnB1dDQpKTtcbiAgICB0aGlzLmxpc3Rib3gucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlU2VsZWN0NCkpO1xuICAgIHRoaXMubGlzdGJveC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uSGFuZGxlQmx1cjQpKTtcbiAgICB0aGlzLmxpc3Rib3gucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25IYW5kbGVGb2N1czIpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb240KS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3Q0KSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uNCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3RFcnJvcjQpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb240KS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVSZXRyaWV2ZTQpKTtcbiAgfVxuICBzaW11bGF0ZVJldHJpZXZlKGZlYXR1cmUpIHtcbiAgICBjb25zdCBpbnB1dCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQ0KTtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LmRhdGFzZXRbXCJtYXBib3hTdWNjZXNzXCJdID0gXCJ0cnVlXCI7XG4gICAgfVxuICAgIHRoaXMubGlzdGJveC5oaWRlUmVzdWx0cygpO1xuICAgIGNvbnN0IHNpbVJlc3VsdCA9IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGZlYXR1cmVzOiBbZmVhdHVyZV0sXG4gICAgICB1cmw6IFwiXCJcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlUmV0cmlldmU0KS5jYWxsKHRoaXMsIHNpbVJlc3VsdCk7XG4gIH1cbn07XG5faW5wdXQ0ID0gbmV3IFdlYWtNYXAoKTtcbl9jb2xsZWN0aW9uID0gbmV3IFdlYWtNYXAoKTtcbl9zZXNzaW9uNCA9IG5ldyBXZWFrTWFwKCk7XG5faW5pdGlhbEF1dG9jb21wbGV0ZVZhbHVlMiA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVJbnB1dDQgPSBuZXcgV2Vha01hcCgpO1xuX29uSGFuZGxlU2VsZWN0NCA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVCbHVyNCA9IG5ldyBXZWFrTWFwKCk7XG5fb25IYW5kbGVGb2N1czIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN1Z2dlc3Q0ID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVTdWdnZXN0RXJyb3I0ID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVSZXRyaWV2ZTQgPSBuZXcgV2Vha01hcCgpO1xudmFyIF9jdXJyZW50SW5wdXRzLCBfYXV0b2ZpbGwyLCBfb3B0aW9uczIsIF90aGVtZSwgX3BvcG92ZXJPcHRpb25zMiwgX2hhbmRsZU9ic2VydmUyLCBfb2JzZXJ2ZXIyLCBfaGFuZGxlQnJvd3NlckF1dG9maWxsMjtcbnZhciBBZGRyZXNzQXV0b2ZpbGxDb2xsZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBFdmVudGVkIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGFjY2Vzc1Rva2VuLFxuICAgIG9wdGlvbnMsXG4gICAgdGhlbWUsXG4gICAgcG9wb3Zlck9wdGlvbnMsXG4gICAgY29uZmlybU9uQnJvd3NlckF1dG9maWxsLFxuICAgIGJyb3dzZXJBdXRvZmlsbEVuYWJsZWRcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2N1cnJlbnRJbnB1dHMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hdXRvZmlsbDIsIG5ldyBBZGRyZXNzQXV0b2ZpbGxDb3JlMigpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29wdGlvbnMyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdGhlbWUsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wb3BvdmVyT3B0aW9uczIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmJyb3dzZXJBdXRvZmlsbEVuYWJsZWQgPSBmYWxzZTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZU9ic2VydmUyLCAoKSA9PiB7XG4gICAgICBpZiAoIWRlZXBFcXVhbHMoZmluZEFkZHJlc3NJbnB1dHMoKSwgX19wcml2YXRlR2V0KHRoaXMsIF9jdXJyZW50SW5wdXRzKSkpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29ic2VydmVyMiwgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVPYnNlcnZlMikpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUJyb3dzZXJBdXRvZmlsbDIsIChlKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4gaW5zdGFuY2UubGlzdGJveC5ibHVyKCkpO1xuICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiB0aGlzLmluc3RhbmNlcykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGluc3RhbmNlLmxpc3Rib3guaW5wdXQ7XG4gICAgICAgIHlpZWxkIHRyeUNvbmZpcm1Ccm93c2VyQXV0b2ZpbGwoaW5wdXQsIGUsIHRoaXMuY29uZmlybU9uQnJvd3NlckF1dG9maWxsLCB0aGlzLmFjY2Vzc1Rva2VuKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgaW5pdERldGVjdEJyb3dzZXJBdXRvZmlsbCgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYnJvd3NlcmF1dG9maWxsXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQnJvd3NlckF1dG9maWxsMikpO1xuICAgIGNvbmZpZy5hdXRvZmlsbFNlc3Npb25FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgY29uZmlnLmFjY2Vzc1Rva2VuO1xuICAgIG9wdGlvbnMgJiYgKHRoaXMub3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgIHRoZW1lICYmICh0aGlzLnRoZW1lID0gdGhlbWUpO1xuICAgIHBvcG92ZXJPcHRpb25zICYmICh0aGlzLnBvcG92ZXJPcHRpb25zID0gcG9wb3Zlck9wdGlvbnMpO1xuICAgIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbCAmJiAodGhpcy5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPSBjb25maXJtT25Ccm93c2VyQXV0b2ZpbGwpO1xuICAgIGJyb3dzZXJBdXRvZmlsbEVuYWJsZWQgJiYgKHRoaXMuYnJvd3NlckF1dG9maWxsRW5hYmxlZCA9IGJyb3dzZXJBdXRvZmlsbEVuYWJsZWQpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2F1dG9maWxsMikuYWNjZXNzVG9rZW47XG4gIH1cbiAgc2V0IGFjY2Vzc1Rva2VuKG5ld1Rva2VuKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9hdXRvZmlsbDIpLmFjY2Vzc1Rva2VuID0gbmV3VG9rZW47XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfb3B0aW9uczIpO1xuICB9XG4gIHNldCBvcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29wdGlvbnMyLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zMikpLCBuZXdPcHRpb25zKSk7XG4gICAgdGhpcy5pbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGluc3RhbmNlLm9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgaW5zdGFuY2Uub3B0aW9ucyksIG5ld09wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF90aGVtZSk7XG4gIH1cbiAgc2V0IHRoZW1lKG5ld1RoZW1lKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90aGVtZSwgbmV3VGhlbWUpO1xuICAgIHRoaXMuaW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICBpbnN0YW5jZS5saXN0Ym94LnRoZW1lID0gbmV3VGhlbWU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHBvcG92ZXJPcHRpb25zKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3BvcG92ZXJPcHRpb25zMik7XG4gIH1cbiAgc2V0IHBvcG92ZXJPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BvcG92ZXJPcHRpb25zMiwgbmV3T3B0aW9ucyk7XG4gICAgdGhpcy5pbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGluc3RhbmNlLmxpc3Rib3gucG9wb3Zlck9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgaW5zdGFuY2UucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9jdXJyZW50SW5wdXRzLCBmaW5kQWRkcmVzc0lucHV0cygpKTtcbiAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY3VycmVudElucHV0cykuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IGF1dG9maWxsSW5zdGFuY2UgPSBuZXcgQWRkcmVzc0F1dG9maWxsSW5zdGFuY2UodGhpcywgaW5wdXQsIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXV0b2ZpbGwyKSk7XG4gICAgICBhdXRvZmlsbEluc3RhbmNlLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBhdXRvZmlsbEluc3RhbmNlLmxpc3Rib3gudGhlbWUgPSB0aGlzLnRoZW1lO1xuICAgICAgYXV0b2ZpbGxJbnN0YW5jZS5saXN0Ym94LnBvcG92ZXJPcHRpb25zID0gdGhpcy5wb3BvdmVyT3B0aW9ucztcbiAgICAgIHRoaXMuaW5zdGFuY2VzLnB1c2goYXV0b2ZpbGxJbnN0YW5jZSk7XG4gICAgfSk7XG4gIH1cbiAgb2JzZXJ2ZSgpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX29ic2VydmVyMikub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlT2JzZXJ2ZTIpLmNhbGwodGhpcyk7XG4gIH1cbiAgdW5vYnNlcnZlKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfb2JzZXJ2ZXIyKS5kaXNjb25uZWN0KCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuaW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICBpbnN0YW5jZS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYnJvd3NlcmF1dG9maWxsXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQnJvd3NlckF1dG9maWxsMikpO1xuICB9XG59O1xuX2N1cnJlbnRJbnB1dHMgPSBuZXcgV2Vha01hcCgpO1xuX2F1dG9maWxsMiA9IG5ldyBXZWFrTWFwKCk7XG5fb3B0aW9uczIgPSBuZXcgV2Vha01hcCgpO1xuX3RoZW1lID0gbmV3IFdlYWtNYXAoKTtcbl9wb3BvdmVyT3B0aW9uczIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZU9ic2VydmUyID0gbmV3IFdlYWtNYXAoKTtcbl9vYnNlcnZlcjIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUJyb3dzZXJBdXRvZmlsbDIgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYXV0b2ZpbGwob3B0aW9uc0FyZykge1xuICByZXR1cm4gbmV3IEFkZHJlc3NBdXRvZmlsbENvbGxlY3Rpb24ob3B0aW9uc0FyZyk7XG59XG5leHBvcnQge1xuICBNYXBib3hBZGRyZXNzQXV0b2ZpbGwsXG4gIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24sXG4gIE1hcGJveEFkZHJlc3NNaW5pbWFwLFxuICBNYXBib3hHZW9jb2RlcixcbiAgTWFwYm94SFRNTEV2ZW50LFxuICBNYXBib3hTZWFyY2hCb3gsXG4gIGF1dG9maWxsLFxuICBjb25maWcsXG4gIGNvbmZpcm1BZGRyZXNzLFxuICBnZXRBdXRvZmlsbFNlYXJjaFRleHQsXG4gIGdldEZvcm1BdXRvZmlsbFZhbHVlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LWVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-web/dist/index-esm.js\n"));

/***/ }),

/***/ "./node_modules/@mapbox/sphericalmercator/sphericalmercator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@mapbox/sphericalmercator/sphericalmercator.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var SphericalMercator = (function(){\n\n// Closures including constants and other precalculated values.\nvar cache = {},\n    EPSLN = 1.0e-10,\n    D2R = Math.PI / 180,\n    R2D = 180 / Math.PI,\n    // 900913 properties.\n    A = 6378137.0,\n    MAXEXTENT = 20037508.342789244;\n\nfunction isFloat(n){\n    return Number(n) === n && n % 1 !== 0;\n}\n\n// SphericalMercator constructor: precaches calculations\n// for fast tile lookups.\nfunction SphericalMercator(options) {\n    options = options || {};\n    this.size = options.size || 256;\n    this.expansion = (options.antimeridian === true) ? 2 : 1;\n    if (!cache[this.size]) {\n        var size = this.size;\n        var c = cache[this.size] = {};\n        c.Bc = [];\n        c.Cc = [];\n        c.zc = [];\n        c.Ac = [];\n        for (var d = 0; d < 30; d++) {\n            c.Bc.push(size / 360);\n            c.Cc.push(size / (2 * Math.PI));\n            c.zc.push(size / 2);\n            c.Ac.push(size);\n            size *= 2;\n        }\n    }\n    this.Bc = cache[this.size].Bc;\n    this.Cc = cache[this.size].Cc;\n    this.zc = cache[this.size].zc;\n    this.Ac = cache[this.size].Ac;\n};\n\n// Convert lon lat to screen pixel value\n//\n// - `ll` {Array} `[lon, lat]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.px = function(ll, zoom) {\n  if (isFloat(zoom)) {\n    var size = this.size * Math.pow(2, zoom);\n    var d = size / 2;\n    var bc = (size / 360);\n    var cc = (size / (2 * Math.PI));\n    var ac = size;\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = d + ll[0] * bc;\n    var y = d + 0.5 * Math.log((1 + f) / (1 - f)) * -cc;\n    (x > ac * this.expansion) && (x = ac * this.expansion);\n    (y > ac) && (y = ac);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n  } else {\n    var d = this.zc[zoom];\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = Math.round(d + ll[0] * this.Bc[zoom]);\n    var y = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * (-this.Cc[zoom]));\n    (x > this.Ac[zoom] * this.expansion) && (x = this.Ac[zoom] * this.expansion);\n    (y > this.Ac[zoom]) && (y = this.Ac[zoom]);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n  }\n};\n\n// Convert screen pixel value to lon lat\n//\n// - `px` {Array} `[x, y]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.ll = function(px, zoom) {\n  if (isFloat(zoom)) {\n    var size = this.size * Math.pow(2, zoom);\n    var bc = (size / 360);\n    var cc = (size / (2 * Math.PI));\n    var zc = size / 2;\n    var g = (px[1] - zc) / -cc;\n    var lon = (px[0] - zc) / bc;\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n  } else {\n    var g = (px[1] - this.zc[zoom]) / (-this.Cc[zoom]);\n    var lon = (px[0] - this.zc[zoom]) / this.Bc[zoom];\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n  }\n};\n\n// Convert tile xyz value to bbox of the form `[w, s, e, n]`\n//\n// - `x` {Number} x (longitude) number.\n// - `y` {Number} y (latitude) number.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection for resulting bbox (WGS84|900913).\n// - `return` {Array} bbox array of values in form `[w, s, e, n]`.\nSphericalMercator.prototype.bbox = function(x, y, zoom, tms_style, srs) {\n    // Convert xyz into bbox with srs WGS84\n    if (tms_style) {\n        y = (Math.pow(2, zoom) - 1) - y;\n    }\n    // Use +y to make sure it's a number to avoid inadvertent concatenation.\n    var ll = [x * this.size, (+y + 1) * this.size]; // lower left\n    // Use +x to make sure it's a number to avoid inadvertent concatenation.\n    var ur = [(+x + 1) * this.size, y * this.size]; // upper right\n    var bbox = this.ll(ll, zoom).concat(this.ll(ur, zoom));\n\n    // If web mercator requested reproject to 900913.\n    if (srs === '900913') {\n        return this.convert(bbox, '900913');\n    } else {\n        return bbox;\n    }\n};\n\n// Convert bbox to xyx bounds\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection of input bbox (WGS84|900913).\n// - `@return` {Object} XYZ bounds containing minX, maxX, minY, maxY properties.\nSphericalMercator.prototype.xyz = function(bbox, zoom, tms_style, srs) {\n    // If web mercator provided reproject to WGS84.\n    if (srs === '900913') {\n        bbox = this.convert(bbox, 'WGS84');\n    }\n\n    var ll = [bbox[0], bbox[1]]; // lower left\n    var ur = [bbox[2], bbox[3]]; // upper right\n    var px_ll = this.px(ll, zoom);\n    var px_ur = this.px(ur, zoom);\n    // Y = 0 for XYZ is the top hence minY uses px_ur[1].\n    var x = [ Math.floor(px_ll[0] / this.size), Math.floor((px_ur[0] - 1) / this.size) ];\n    var y = [ Math.floor(px_ur[1] / this.size), Math.floor((px_ll[1] - 1) / this.size) ];\n    var bounds = {\n        minX: Math.min.apply(Math, x) < 0 ? 0 : Math.min.apply(Math, x),\n        minY: Math.min.apply(Math, y) < 0 ? 0 : Math.min.apply(Math, y),\n        maxX: Math.max.apply(Math, x),\n        maxY: Math.max.apply(Math, y)\n    };\n    if (tms_style) {\n        var tms = {\n            minY: (Math.pow(2, zoom) - 1) - bounds.maxY,\n            maxY: (Math.pow(2, zoom) - 1) - bounds.minY\n        };\n        bounds.minY = tms.minY;\n        bounds.maxY = tms.maxY;\n    }\n    return bounds;\n};\n\n// Convert projection of given bbox.\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `to` {String} projection of output bbox (WGS84|900913). Input bbox\n//   assumed to be the \"other\" projection.\n// - `@return` {Object} bbox with reprojected coordinates.\nSphericalMercator.prototype.convert = function(bbox, to) {\n    if (to === '900913') {\n        return this.forward(bbox.slice(0, 2)).concat(this.forward(bbox.slice(2,4)));\n    } else {\n        return this.inverse(bbox.slice(0, 2)).concat(this.inverse(bbox.slice(2,4)));\n    }\n};\n\n// Convert lon/lat values to 900913 x/y.\nSphericalMercator.prototype.forward = function(ll) {\n    var xy = [\n        A * ll[0] * D2R,\n        A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * ll[1] * D2R)))\n    ];\n    // if xy value is beyond maxextent (e.g. poles), return maxextent.\n    (xy[0] > MAXEXTENT) && (xy[0] = MAXEXTENT);\n    (xy[0] < -MAXEXTENT) && (xy[0] = -MAXEXTENT);\n    (xy[1] > MAXEXTENT) && (xy[1] = MAXEXTENT);\n    (xy[1] < -MAXEXTENT) && (xy[1] = -MAXEXTENT);\n    return xy;\n};\n\n// Convert 900913 x/y values to lon/lat.\nSphericalMercator.prototype.inverse = function(xy) {\n    return [\n        (xy[0] * R2D / A),\n        ((Math.PI*0.5) - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D\n    ];\n};\n\nreturn SphericalMercator;\n\n})();\n\nif (true) {\n    module.exports = exports = SphericalMercator;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zcGhlcmljYWxtZXJjYXRvci9zcGhlcmljYWxtZXJjYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixhQUFhLFFBQVE7QUFDckIsa0JBQWtCLFNBQVM7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixrQkFBa0IsU0FBUztBQUMzQixZQUFZLFFBQVE7QUFDcEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRCxJQUFJLElBQStEO0FBQ25FO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvc3BoZXJpY2FsbWVyY2F0b3Ivc3BoZXJpY2FsbWVyY2F0b3IuanM/NDVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSAoZnVuY3Rpb24oKXtcblxuLy8gQ2xvc3VyZXMgaW5jbHVkaW5nIGNvbnN0YW50cyBhbmQgb3RoZXIgcHJlY2FsY3VsYXRlZCB2YWx1ZXMuXG52YXIgY2FjaGUgPSB7fSxcbiAgICBFUFNMTiA9IDEuMGUtMTAsXG4gICAgRDJSID0gTWF0aC5QSSAvIDE4MCxcbiAgICBSMkQgPSAxODAgLyBNYXRoLlBJLFxuICAgIC8vIDkwMDkxMyBwcm9wZXJ0aWVzLlxuICAgIEEgPSA2Mzc4MTM3LjAsXG4gICAgTUFYRVhURU5UID0gMjAwMzc1MDguMzQyNzg5MjQ0O1xuXG5mdW5jdGlvbiBpc0Zsb2F0KG4pe1xuICAgIHJldHVybiBOdW1iZXIobikgPT09IG4gJiYgbiAlIDEgIT09IDA7XG59XG5cbi8vIFNwaGVyaWNhbE1lcmNhdG9yIGNvbnN0cnVjdG9yOiBwcmVjYWNoZXMgY2FsY3VsYXRpb25zXG4vLyBmb3IgZmFzdCB0aWxlIGxvb2t1cHMuXG5mdW5jdGlvbiBTcGhlcmljYWxNZXJjYXRvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplIHx8IDI1NjtcbiAgICB0aGlzLmV4cGFuc2lvbiA9IChvcHRpb25zLmFudGltZXJpZGlhbiA9PT0gdHJ1ZSkgPyAyIDogMTtcbiAgICBpZiAoIWNhY2hlW3RoaXMuc2l6ZV0pIHtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHZhciBjID0gY2FjaGVbdGhpcy5zaXplXSA9IHt9O1xuICAgICAgICBjLkJjID0gW107XG4gICAgICAgIGMuQ2MgPSBbXTtcbiAgICAgICAgYy56YyA9IFtdO1xuICAgICAgICBjLkFjID0gW107XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgMzA7IGQrKykge1xuICAgICAgICAgICAgYy5CYy5wdXNoKHNpemUgLyAzNjApO1xuICAgICAgICAgICAgYy5DYy5wdXNoKHNpemUgLyAoMiAqIE1hdGguUEkpKTtcbiAgICAgICAgICAgIGMuemMucHVzaChzaXplIC8gMik7XG4gICAgICAgICAgICBjLkFjLnB1c2goc2l6ZSk7XG4gICAgICAgICAgICBzaXplICo9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5CYyA9IGNhY2hlW3RoaXMuc2l6ZV0uQmM7XG4gICAgdGhpcy5DYyA9IGNhY2hlW3RoaXMuc2l6ZV0uQ2M7XG4gICAgdGhpcy56YyA9IGNhY2hlW3RoaXMuc2l6ZV0uemM7XG4gICAgdGhpcy5BYyA9IGNhY2hlW3RoaXMuc2l6ZV0uQWM7XG59O1xuXG4vLyBDb252ZXJ0IGxvbiBsYXQgdG8gc2NyZWVuIHBpeGVsIHZhbHVlXG4vL1xuLy8gLSBgbGxgIHtBcnJheX0gYFtsb24sIGxhdF1gIGFycmF5IG9mIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4vLyAtIGB6b29tYCB7TnVtYmVyfSB6b29tIGxldmVsLlxuU3BoZXJpY2FsTWVyY2F0b3IucHJvdG90eXBlLnB4ID0gZnVuY3Rpb24obGwsIHpvb20pIHtcbiAgaWYgKGlzRmxvYXQoem9vbSkpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSAqIE1hdGgucG93KDIsIHpvb20pO1xuICAgIHZhciBkID0gc2l6ZSAvIDI7XG4gICAgdmFyIGJjID0gKHNpemUgLyAzNjApO1xuICAgIHZhciBjYyA9IChzaXplIC8gKDIgKiBNYXRoLlBJKSk7XG4gICAgdmFyIGFjID0gc2l6ZTtcbiAgICB2YXIgZiA9IE1hdGgubWluKE1hdGgubWF4KE1hdGguc2luKEQyUiAqIGxsWzFdKSwgLTAuOTk5OSksIDAuOTk5OSk7XG4gICAgdmFyIHggPSBkICsgbGxbMF0gKiBiYztcbiAgICB2YXIgeSA9IGQgKyAwLjUgKiBNYXRoLmxvZygoMSArIGYpIC8gKDEgLSBmKSkgKiAtY2M7XG4gICAgKHggPiBhYyAqIHRoaXMuZXhwYW5zaW9uKSAmJiAoeCA9IGFjICogdGhpcy5leHBhbnNpb24pO1xuICAgICh5ID4gYWMpICYmICh5ID0gYWMpO1xuICAgIC8vKHggPCAwKSAmJiAoeCA9IDApO1xuICAgIC8vKHkgPCAwKSAmJiAoeSA9IDApO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGQgPSB0aGlzLnpjW3pvb21dO1xuICAgIHZhciBmID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5zaW4oRDJSICogbGxbMV0pLCAtMC45OTk5KSwgMC45OTk5KTtcbiAgICB2YXIgeCA9IE1hdGgucm91bmQoZCArIGxsWzBdICogdGhpcy5CY1t6b29tXSk7XG4gICAgdmFyIHkgPSBNYXRoLnJvdW5kKGQgKyAwLjUgKiBNYXRoLmxvZygoMSArIGYpIC8gKDEgLSBmKSkgKiAoLXRoaXMuQ2Nbem9vbV0pKTtcbiAgICAoeCA+IHRoaXMuQWNbem9vbV0gKiB0aGlzLmV4cGFuc2lvbikgJiYgKHggPSB0aGlzLkFjW3pvb21dICogdGhpcy5leHBhbnNpb24pO1xuICAgICh5ID4gdGhpcy5BY1t6b29tXSkgJiYgKHkgPSB0aGlzLkFjW3pvb21dKTtcbiAgICAvLyh4IDwgMCkgJiYgKHggPSAwKTtcbiAgICAvLyh5IDwgMCkgJiYgKHkgPSAwKTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG59O1xuXG4vLyBDb252ZXJ0IHNjcmVlbiBwaXhlbCB2YWx1ZSB0byBsb24gbGF0XG4vL1xuLy8gLSBgcHhgIHtBcnJheX0gYFt4LCB5XWAgYXJyYXkgb2YgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcy5cbi8vIC0gYHpvb21gIHtOdW1iZXJ9IHpvb20gbGV2ZWwuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUubGwgPSBmdW5jdGlvbihweCwgem9vbSkge1xuICBpZiAoaXNGbG9hdCh6b29tKSkge1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplICogTWF0aC5wb3coMiwgem9vbSk7XG4gICAgdmFyIGJjID0gKHNpemUgLyAzNjApO1xuICAgIHZhciBjYyA9IChzaXplIC8gKDIgKiBNYXRoLlBJKSk7XG4gICAgdmFyIHpjID0gc2l6ZSAvIDI7XG4gICAgdmFyIGcgPSAocHhbMV0gLSB6YykgLyAtY2M7XG4gICAgdmFyIGxvbiA9IChweFswXSAtIHpjKSAvIGJjO1xuICAgIHZhciBsYXQgPSBSMkQgKiAoMiAqIE1hdGguYXRhbihNYXRoLmV4cChnKSkgLSAwLjUgKiBNYXRoLlBJKTtcbiAgICByZXR1cm4gW2xvbiwgbGF0XTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZyA9IChweFsxXSAtIHRoaXMuemNbem9vbV0pIC8gKC10aGlzLkNjW3pvb21dKTtcbiAgICB2YXIgbG9uID0gKHB4WzBdIC0gdGhpcy56Y1t6b29tXSkgLyB0aGlzLkJjW3pvb21dO1xuICAgIHZhciBsYXQgPSBSMkQgKiAoMiAqIE1hdGguYXRhbihNYXRoLmV4cChnKSkgLSAwLjUgKiBNYXRoLlBJKTtcbiAgICByZXR1cm4gW2xvbiwgbGF0XTtcbiAgfVxufTtcblxuLy8gQ29udmVydCB0aWxlIHh5eiB2YWx1ZSB0byBiYm94IG9mIHRoZSBmb3JtIGBbdywgcywgZSwgbl1gXG4vL1xuLy8gLSBgeGAge051bWJlcn0geCAobG9uZ2l0dWRlKSBudW1iZXIuXG4vLyAtIGB5YCB7TnVtYmVyfSB5IChsYXRpdHVkZSkgbnVtYmVyLlxuLy8gLSBgem9vbWAge051bWJlcn0gem9vbS5cbi8vIC0gYHRtc19zdHlsZWAge0Jvb2xlYW59IHdoZXRoZXIgdG8gY29tcHV0ZSB1c2luZyB0bXMtc3R5bGUuXG4vLyAtIGBzcnNgIHtTdHJpbmd9IHByb2plY3Rpb24gZm9yIHJlc3VsdGluZyBiYm94IChXR1M4NHw5MDA5MTMpLlxuLy8gLSBgcmV0dXJuYCB7QXJyYXl9IGJib3ggYXJyYXkgb2YgdmFsdWVzIGluIGZvcm0gYFt3LCBzLCBlLCBuXWAuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKHgsIHksIHpvb20sIHRtc19zdHlsZSwgc3JzKSB7XG4gICAgLy8gQ29udmVydCB4eXogaW50byBiYm94IHdpdGggc3JzIFdHUzg0XG4gICAgaWYgKHRtc19zdHlsZSkge1xuICAgICAgICB5ID0gKE1hdGgucG93KDIsIHpvb20pIC0gMSkgLSB5O1xuICAgIH1cbiAgICAvLyBVc2UgK3kgdG8gbWFrZSBzdXJlIGl0J3MgYSBudW1iZXIgdG8gYXZvaWQgaW5hZHZlcnRlbnQgY29uY2F0ZW5hdGlvbi5cbiAgICB2YXIgbGwgPSBbeCAqIHRoaXMuc2l6ZSwgKCt5ICsgMSkgKiB0aGlzLnNpemVdOyAvLyBsb3dlciBsZWZ0XG4gICAgLy8gVXNlICt4IHRvIG1ha2Ugc3VyZSBpdCdzIGEgbnVtYmVyIHRvIGF2b2lkIGluYWR2ZXJ0ZW50IGNvbmNhdGVuYXRpb24uXG4gICAgdmFyIHVyID0gWygreCArIDEpICogdGhpcy5zaXplLCB5ICogdGhpcy5zaXplXTsgLy8gdXBwZXIgcmlnaHRcbiAgICB2YXIgYmJveCA9IHRoaXMubGwobGwsIHpvb20pLmNvbmNhdCh0aGlzLmxsKHVyLCB6b29tKSk7XG5cbiAgICAvLyBJZiB3ZWIgbWVyY2F0b3IgcmVxdWVzdGVkIHJlcHJvamVjdCB0byA5MDA5MTMuXG4gICAgaWYgKHNycyA9PT0gJzkwMDkxMycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydChiYm94LCAnOTAwOTEzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCBiYm94IHRvIHh5eCBib3VuZHNcbi8vXG4vLyAtIGBiYm94YCB7TnVtYmVyfSBiYm94IGluIHRoZSBmb3JtIGBbdywgcywgZSwgbl1gLlxuLy8gLSBgem9vbWAge051bWJlcn0gem9vbS5cbi8vIC0gYHRtc19zdHlsZWAge0Jvb2xlYW59IHdoZXRoZXIgdG8gY29tcHV0ZSB1c2luZyB0bXMtc3R5bGUuXG4vLyAtIGBzcnNgIHtTdHJpbmd9IHByb2plY3Rpb24gb2YgaW5wdXQgYmJveCAoV0dTODR8OTAwOTEzKS5cbi8vIC0gYEByZXR1cm5gIHtPYmplY3R9IFhZWiBib3VuZHMgY29udGFpbmluZyBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZIHByb3BlcnRpZXMuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUueHl6ID0gZnVuY3Rpb24oYmJveCwgem9vbSwgdG1zX3N0eWxlLCBzcnMpIHtcbiAgICAvLyBJZiB3ZWIgbWVyY2F0b3IgcHJvdmlkZWQgcmVwcm9qZWN0IHRvIFdHUzg0LlxuICAgIGlmIChzcnMgPT09ICc5MDA5MTMnKSB7XG4gICAgICAgIGJib3ggPSB0aGlzLmNvbnZlcnQoYmJveCwgJ1dHUzg0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGxsID0gW2Jib3hbMF0sIGJib3hbMV1dOyAvLyBsb3dlciBsZWZ0XG4gICAgdmFyIHVyID0gW2Jib3hbMl0sIGJib3hbM11dOyAvLyB1cHBlciByaWdodFxuICAgIHZhciBweF9sbCA9IHRoaXMucHgobGwsIHpvb20pO1xuICAgIHZhciBweF91ciA9IHRoaXMucHgodXIsIHpvb20pO1xuICAgIC8vIFkgPSAwIGZvciBYWVogaXMgdGhlIHRvcCBoZW5jZSBtaW5ZIHVzZXMgcHhfdXJbMV0uXG4gICAgdmFyIHggPSBbIE1hdGguZmxvb3IocHhfbGxbMF0gLyB0aGlzLnNpemUpLCBNYXRoLmZsb29yKChweF91clswXSAtIDEpIC8gdGhpcy5zaXplKSBdO1xuICAgIHZhciB5ID0gWyBNYXRoLmZsb29yKHB4X3VyWzFdIC8gdGhpcy5zaXplKSwgTWF0aC5mbG9vcigocHhfbGxbMV0gLSAxKSAvIHRoaXMuc2l6ZSkgXTtcbiAgICB2YXIgYm91bmRzID0ge1xuICAgICAgICBtaW5YOiBNYXRoLm1pbi5hcHBseShNYXRoLCB4KSA8IDAgPyAwIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgeCksXG4gICAgICAgIG1pblk6IE1hdGgubWluLmFwcGx5KE1hdGgsIHkpIDwgMCA/IDAgOiBNYXRoLm1pbi5hcHBseShNYXRoLCB5KSxcbiAgICAgICAgbWF4WDogTWF0aC5tYXguYXBwbHkoTWF0aCwgeCksXG4gICAgICAgIG1heFk6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHkpXG4gICAgfTtcbiAgICBpZiAodG1zX3N0eWxlKSB7XG4gICAgICAgIHZhciB0bXMgPSB7XG4gICAgICAgICAgICBtaW5ZOiAoTWF0aC5wb3coMiwgem9vbSkgLSAxKSAtIGJvdW5kcy5tYXhZLFxuICAgICAgICAgICAgbWF4WTogKE1hdGgucG93KDIsIHpvb20pIC0gMSkgLSBib3VuZHMubWluWVxuICAgICAgICB9O1xuICAgICAgICBib3VuZHMubWluWSA9IHRtcy5taW5ZO1xuICAgICAgICBib3VuZHMubWF4WSA9IHRtcy5tYXhZO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuLy8gQ29udmVydCBwcm9qZWN0aW9uIG9mIGdpdmVuIGJib3guXG4vL1xuLy8gLSBgYmJveGAge051bWJlcn0gYmJveCBpbiB0aGUgZm9ybSBgW3csIHMsIGUsIG5dYC5cbi8vIC0gYHRvYCB7U3RyaW5nfSBwcm9qZWN0aW9uIG9mIG91dHB1dCBiYm94IChXR1M4NHw5MDA5MTMpLiBJbnB1dCBiYm94XG4vLyAgIGFzc3VtZWQgdG8gYmUgdGhlIFwib3RoZXJcIiBwcm9qZWN0aW9uLlxuLy8gLSBgQHJldHVybmAge09iamVjdH0gYmJveCB3aXRoIHJlcHJvamVjdGVkIGNvb3JkaW5hdGVzLlxuU3BoZXJpY2FsTWVyY2F0b3IucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbihiYm94LCB0bykge1xuICAgIGlmICh0byA9PT0gJzkwMDkxMycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZChiYm94LnNsaWNlKDAsIDIpKS5jb25jYXQodGhpcy5mb3J3YXJkKGJib3guc2xpY2UoMiw0KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVyc2UoYmJveC5zbGljZSgwLCAyKSkuY29uY2F0KHRoaXMuaW52ZXJzZShiYm94LnNsaWNlKDIsNCkpKTtcbiAgICB9XG59O1xuXG4vLyBDb252ZXJ0IGxvbi9sYXQgdmFsdWVzIHRvIDkwMDkxMyB4L3kuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uKGxsKSB7XG4gICAgdmFyIHh5ID0gW1xuICAgICAgICBBICogbGxbMF0gKiBEMlIsXG4gICAgICAgIEEgKiBNYXRoLmxvZyhNYXRoLnRhbigoTWF0aC5QSSowLjI1KSArICgwLjUgKiBsbFsxXSAqIEQyUikpKVxuICAgIF07XG4gICAgLy8gaWYgeHkgdmFsdWUgaXMgYmV5b25kIG1heGV4dGVudCAoZS5nLiBwb2xlcyksIHJldHVybiBtYXhleHRlbnQuXG4gICAgKHh5WzBdID4gTUFYRVhURU5UKSAmJiAoeHlbMF0gPSBNQVhFWFRFTlQpO1xuICAgICh4eVswXSA8IC1NQVhFWFRFTlQpICYmICh4eVswXSA9IC1NQVhFWFRFTlQpO1xuICAgICh4eVsxXSA+IE1BWEVYVEVOVCkgJiYgKHh5WzFdID0gTUFYRVhURU5UKTtcbiAgICAoeHlbMV0gPCAtTUFYRVhURU5UKSAmJiAoeHlbMV0gPSAtTUFYRVhURU5UKTtcbiAgICByZXR1cm4geHk7XG59O1xuXG4vLyBDb252ZXJ0IDkwMDkxMyB4L3kgdmFsdWVzIHRvIGxvbi9sYXQuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHh5KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHh5WzBdICogUjJEIC8gQSksXG4gICAgICAgICgoTWF0aC5QSSowLjUpIC0gMi4wICogTWF0aC5hdGFuKE1hdGguZXhwKC14eVsxXSAvIEEpKSkgKiBSMkRcbiAgICBdO1xufTtcblxucmV0dXJuIFNwaGVyaWNhbE1lcmNhdG9yO1xuXG59KSgpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU3BoZXJpY2FsTWVyY2F0b3I7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/sphericalmercator/sphericalmercator.js\n"));

/***/ }),

/***/ "./node_modules/focus-trap/dist/focus-trap.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/focus-trap/dist/focus-trap.esm.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFocusTrap: function() { return /* binding */ createFocusTrap; }\n/* harmony export */ });\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tabbable */ \"./node_modules/focus-trap/node_modules/tabbable/dist/index.esm.js\");\n/*!\n* focus-trap 6.9.4\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n\n\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n          tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      optionValue = optionValue.apply(void 0, params);\n    }\n\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all\n\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.tabbable)(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n\n      var focusableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.focusable)(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);\n            });\n          }\n\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    var target = getActualTarget(e);\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n\n    get paused() {\n      return state.paused;\n    },\n\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\n\n//# sourceMappingURL=focus-trap.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9kaXN0L2ZvY3VzLXRyYXAuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0U7O0FBRXhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxtREFBbUQ7QUFDdEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUEsaUJBQWlCO0FBQ2pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsR0FBRztBQUNoQjs7O0FBR0E7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsUUFBUTtBQUN2Qiw4RUFBOEU7QUFDOUU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLDhDQUE4QztBQUM3RCxrREFBa0Q7QUFDbEQsdURBQXVEO0FBQ3ZEO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw0RkFBNEY7O0FBRTVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFRLHFDQUFxQyxrRUFBa0U7QUFDekk7O0FBRUEsMkJBQTJCLG1EQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxtQkFBbUIsU0FBUyw4Q0FBOEM7QUFDMUU7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQVU7QUFDL0IsYUFBYTtBQUNiOztBQUVBO0FBQ0EsbUJBQW1CLG9EQUFVO0FBQzdCLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0Esd0RBQXdELHFEQUFXO0FBQ25FLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsNkVBQTZFLHFEQUFXLHFDQUFxQyxvREFBVTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsNEVBQTRFLHFEQUFXLHFDQUFxQyxvREFBVTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAvZGlzdC9mb2N1cy10cmFwLmVzbS5qcz9jZjllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBmb2N1cy10cmFwIDYuOS40XG4qIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuaW1wb3J0IHsgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgaXNGb2N1c2FibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBhY3RpdmVGb2N1c1RyYXBzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhcFF1ZXVlID0gW107XG4gIHJldHVybiB7XG4gICAgYWN0aXZhdGVUcmFwOiBmdW5jdGlvbiBhY3RpdmF0ZVRyYXAodHJhcCkge1xuICAgICAgaWYgKHRyYXBRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhY3RpdmVUcmFwID0gdHJhcFF1ZXVlW3RyYXBRdWV1ZS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoYWN0aXZlVHJhcCAhPT0gdHJhcCkge1xuICAgICAgICAgIGFjdGl2ZVRyYXAucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFF1ZXVlLmluZGV4T2YodHJhcCk7XG5cbiAgICAgIGlmICh0cmFwSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRyYXBRdWV1ZS5wdXNoKHRyYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSB0aGlzIGV4aXN0aW5nIHRyYXAgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAgICB0cmFwUXVldWUuc3BsaWNlKHRyYXBJbmRleCwgMSk7XG4gICAgICAgIHRyYXBRdWV1ZS5wdXNoKHRyYXApO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGRlYWN0aXZhdGVUcmFwKHRyYXApIHtcbiAgICAgIHZhciB0cmFwSW5kZXggPSB0cmFwUXVldWUuaW5kZXhPZih0cmFwKTtcblxuICAgICAgaWYgKHRyYXBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdHJhcFF1ZXVlLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJhcFF1ZXVlW3RyYXBRdWV1ZS5sZW5ndGggLSAxXS51bnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSgpO1xuXG52YXIgaXNTZWxlY3RhYmxlSW5wdXQgPSBmdW5jdGlvbiBpc1NlbGVjdGFibGVJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzRXNjYXBlRXZlbnQgPSBmdW5jdGlvbiBpc0VzY2FwZUV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnRXNjYXBlJyB8fCBlLmtleSA9PT0gJ0VzYycgfHwgZS5rZXlDb2RlID09PSAyNztcbn07XG5cbnZhciBpc1RhYkV2ZW50ID0gZnVuY3Rpb24gaXNUYWJFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5O1xufTtcblxudmFyIGRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufTsgLy8gQXJyYXkuZmluZC9maW5kSW5kZXgoKSBhcmUgbm90IHN1cHBvcnRlZCBvbiBJRTsgdGhpcyByZXBsaWNhdGVzIGVub3VnaFxuLy8gIG9mIEFycmF5LmZpbmRJbmRleCgpIGZvciBvdXIgbmVlZHNcblxuXG52YXIgZmluZEluZGV4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFyciwgZm4pIHtcbiAgdmFyIGlkeCA9IC0xO1xuICBhcnIuZXZlcnkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgaWYgKGZuKHZhbHVlKSkge1xuICAgICAgaWR4ID0gaTtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gbmV4dFxuICB9KTtcbiAgcmV0dXJuIGlkeDtcbn07XG4vKipcbiAqIEdldCBhbiBvcHRpb24ncyB2YWx1ZSB3aGVuIGl0IGNvdWxkIGJlIGEgcGxhaW4gdmFsdWUsIG9yIGEgaGFuZGxlciB0aGF0IHByb3ZpZGVzXG4gKiAgdGhlIHZhbHVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24ncyB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7Li4uKn0gW3BhcmFtc10gQW55IHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgaGFuZGxlciwgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMgeyp9IFRoZSBgdmFsdWVgLCBvciB0aGUgaGFuZGxlcidzIHJldHVybmVkIHZhbHVlLlxuICovXG5cblxudmFyIHZhbHVlT3JIYW5kbGVyID0gZnVuY3Rpb24gdmFsdWVPckhhbmRsZXIodmFsdWUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5hcHBseSh2b2lkIDAsIHBhcmFtcykgOiB2YWx1ZTtcbn07XG5cbnZhciBnZXRBY3R1YWxUYXJnZXQgPSBmdW5jdGlvbiBnZXRBY3R1YWxUYXJnZXQoZXZlbnQpIHtcbiAgLy8gTk9URTogSWYgdGhlIHRyYXAgaXMgX2luc2lkZV8gYSBzaGFkb3cgRE9NLCBldmVudC50YXJnZXQgd2lsbCBhbHdheXMgYmUgdGhlXG4gIC8vICBzaGFkb3cgaG9zdC4gSG93ZXZlciwgZXZlbnQudGFyZ2V0LmNvbXBvc2VkUGF0aCgpIHdpbGwgYmUgYW4gYXJyYXkgb2ZcbiAgLy8gIG5vZGVzIFwiY2xpY2tlZFwiIGZyb20gaW5uZXItbW9zdCAodGhlIGFjdHVhbCBlbGVtZW50IGluc2lkZSB0aGUgc2hhZG93KSB0b1xuICAvLyAgb3V0ZXItbW9zdCAodGhlIGhvc3QgSFRNTCBkb2N1bWVudCkuIElmIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2VkUGF0aCgpLFxuICAvLyAgdGhlbiB1c2UgaXRzIGZpcnN0IGVsZW1lbnQ7IG90aGVyd2lzZSwgZmFsbCBiYWNrIHRvIGV2ZW50LnRhcmdldCAoYW5kXG4gIC8vICB0aGlzIG9ubHkgd29ya3MgZm9yIGFuIF9vcGVuXyBzaGFkb3cgRE9NOyBvdGhlcndpc2UsXG4gIC8vICBjb21wb3NlZFBhdGgoKVswXSA9PT0gZXZlbnQudGFyZ2V0IGFsd2F5cykuXG4gIHJldHVybiBldmVudC50YXJnZXQuc2hhZG93Um9vdCAmJiB0eXBlb2YgZXZlbnQuY29tcG9zZWRQYXRoID09PSAnZnVuY3Rpb24nID8gZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gOiBldmVudC50YXJnZXQ7XG59O1xuXG52YXIgY3JlYXRlRm9jdXNUcmFwID0gZnVuY3Rpb24gY3JlYXRlRm9jdXNUcmFwKGVsZW1lbnRzLCB1c2VyT3B0aW9ucykge1xuICAvLyBTU1I6IGEgbGl2ZSB0cmFwIHNob3VsZG4ndCBiZSBjcmVhdGVkIGluIHRoaXMgdHlwZSBvZiBlbnZpcm9ubWVudCBzbyB0aGlzXG4gIC8vICBzaG91bGQgYmUgc2FmZSBjb2RlIHRvIGV4ZWN1dGUgaWYgdGhlIGBkb2N1bWVudGAgb3B0aW9uIGlzbid0IHNwZWNpZmllZFxuICB2YXIgZG9jID0gKHVzZXJPcHRpb25zID09PSBudWxsIHx8IHVzZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyT3B0aW9ucy5kb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG5cbiAgdmFyIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogdHJ1ZSxcbiAgICBlc2NhcGVEZWFjdGl2YXRlczogdHJ1ZSxcbiAgICBkZWxheUluaXRpYWxGb2N1czogdHJ1ZVxuICB9LCB1c2VyT3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIC8vIGNvbnRhaW5lcnMgZ2l2ZW4gdG8gY3JlYXRlRm9jdXNUcmFwKClcbiAgICAvLyBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgIGNvbnRhaW5lcnM6IFtdLFxuICAgIC8vIGxpc3Qgb2Ygb2JqZWN0cyBpZGVudGlmeWluZyB0YWJiYWJsZSBub2RlcyBpbiBgY29udGFpbmVyc2AgaW4gdGhlIHRyYXBcbiAgICAvLyBOT1RFOiBpdCdzIHBvc3NpYmxlIHRoYXQgYSBncm91cCBoYXMgbm8gdGFiYmFibGUgbm9kZXMgaWYgbm9kZXMgZ2V0IHJlbW92ZWQgd2hpbGUgdGhlIHRyYXBcbiAgICAvLyAgaXMgYWN0aXZlLCBidXQgdGhlIHRyYXAgc2hvdWxkIG5ldmVyIGdldCB0byBhIHN0YXRlIHdoZXJlIHRoZXJlIGlzbid0IGF0IGxlYXN0IG9uZSBncm91cFxuICAgIC8vICB3aXRoIGF0IGxlYXN0IG9uZSB0YWJiYWJsZSBub2RlIGluIGl0ICh0aGF0IHdvdWxkIGxlYWQgdG8gYW4gZXJyb3IgY29uZGl0aW9uIHRoYXQgd291bGRcbiAgICAvLyAgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIHRocm93bilcbiAgICAvLyBAdHlwZSB7QXJyYXk8e1xuICAgIC8vICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgICAvLyAgIHRhYmJhYmxlTm9kZXM6IEFycmF5PEhUTUxFbGVtZW50PiwgLy8gZW1wdHkgaWYgbm9uZVxuICAgIC8vICAgZm9jdXNhYmxlTm9kZXM6IEFycmF5PEhUTUxFbGVtZW50PiwgLy8gZW1wdHkgaWYgbm9uZVxuICAgIC8vICAgZmlyc3RUYWJiYWJsZU5vZGU6IEhUTUxFbGVtZW50fG51bGwsXG4gICAgLy8gICBsYXN0VGFiYmFibGVOb2RlOiBIVE1MRWxlbWVudHxudWxsLFxuICAgIC8vICAgbmV4dFRhYmJhYmxlTm9kZTogKG5vZGU6IEhUTUxFbGVtZW50LCBmb3J3YXJkOiBib29sZWFuKSA9PiBIVE1MRWxlbWVudHx1bmRlZmluZWRcbiAgICAvLyB9Pn1cbiAgICBjb250YWluZXJHcm91cHM6IFtdLFxuICAgIC8vIHNhbWUgb3JkZXIvbGVuZ3RoIGFzIGBjb250YWluZXJzYCBsaXN0XG4gICAgLy8gcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIGBjb250YWluZXJHcm91cHNgLCBidXQgb25seSB0aG9zZSB0aGF0IGFjdHVhbGx5IGhhdmVcbiAgICAvLyAgdGFiYmFibGUgbm9kZXMgaW4gdGhlbVxuICAgIC8vIE5PVEU6IHNhbWUgb3JkZXIgYXMgYGNvbnRhaW5lcnNgIGFuZCBgY29udGFpbmVyR3JvdXBzYCwgYnV0IF9fbm90IG5lY2Vzc2FyaWx5X19cbiAgICAvLyAgdGhlIHNhbWUgbGVuZ3RoXG4gICAgdGFiYmFibGVHcm91cHM6IFtdLFxuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbjogbnVsbCxcbiAgICBtb3N0UmVjZW50bHlGb2N1c2VkTm9kZTogbnVsbCxcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIHBhdXNlZDogZmFsc2UsXG4gICAgLy8gdGltZXIgSUQgZm9yIHdoZW4gZGVsYXlJbml0aWFsRm9jdXMgaXMgdHJ1ZSBhbmQgaW5pdGlhbCBmb2N1cyBpbiB0aGlzIHRyYXBcbiAgICAvLyAgaGFzIGJlZW4gZGVsYXllZCBkdXJpbmcgYWN0aXZhdGlvblxuICAgIGRlbGF5SW5pdGlhbEZvY3VzVGltZXI6IHVuZGVmaW5lZFxuICB9O1xuICB2YXIgdHJhcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3QgLS0gc29tZSBwcml2YXRlIGZ1bmN0aW9ucyByZWZlcmVuY2UgaXQsIGFuZCBpdHMgbWV0aG9kcyByZWZlcmVuY2UgcHJpdmF0ZSBmdW5jdGlvbnMsIHNvIHdlIG11c3QgZGVjbGFyZSBoZXJlIGFuZCBkZWZpbmUgbGF0ZXJcblxuICAvKipcbiAgICogR2V0cyBhIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHZhbHVlLlxuICAgKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IGNvbmZpZ092ZXJyaWRlT3B0aW9ucyBJZiB0cnVlLCBhbmQgb3B0aW9uIGlzIGRlZmluZWQgaW4gdGhpcyBzZXQsXG4gICAqICB2YWx1ZSB3aWxsIGJlIHRha2VuIGZyb20gdGhpcyBvYmplY3QuIE90aGVyd2lzZSwgdmFsdWUgd2lsbCBiZSB0YWtlbiBmcm9tIGJhc2UgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbk5hbWUgTmFtZSBvZiB0aGUgb3B0aW9uIHdob3NlIHZhbHVlIGlzIHNvdWdodC5cbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBbY29uZmlnT3B0aW9uTmFtZV0gTmFtZSBvZiBvcHRpb24gdG8gdXNlIF9faW5zdGVhZCBvZl9fIGBvcHRpb25OYW1lYFxuICAgKiAgSUlGIGBjb25maWdPdmVycmlkZU9wdGlvbnNgIGlzIG5vdCBkZWZpbmVkLiBPdGhlcndpc2UsIGBvcHRpb25OYW1lYCBpcyB1c2VkLlxuICAgKi9cblxuICB2YXIgZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKGNvbmZpZ092ZXJyaWRlT3B0aW9ucywgb3B0aW9uTmFtZSwgY29uZmlnT3B0aW9uTmFtZSkge1xuICAgIHJldHVybiBjb25maWdPdmVycmlkZU9wdGlvbnMgJiYgY29uZmlnT3ZlcnJpZGVPcHRpb25zW29wdGlvbk5hbWVdICE9PSB1bmRlZmluZWQgPyBjb25maWdPdmVycmlkZU9wdGlvbnNbb3B0aW9uTmFtZV0gOiBjb25maWdbY29uZmlnT3B0aW9uTmFtZSB8fCBvcHRpb25OYW1lXTtcbiAgfTtcbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge251bWJlcn0gSW5kZXggb2YgdGhlIGNvbnRhaW5lciBpbiBlaXRoZXIgYHN0YXRlLmNvbnRhaW5lcnNgIG9yXG4gICAqICBgc3RhdGUuY29udGFpbmVyR3JvdXBzYCAodGhlIG9yZGVyL2xlbmd0aCBvZiB0aGVzZSBsaXN0cyBhcmUgdGhlIHNhbWUpOyAtMVxuICAgKiAgaWYgdGhlIGVsZW1lbnQgaXNuJ3QgZm91bmQuXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRDb250YWluZXJJbmRleCA9IGZ1bmN0aW9uIGZpbmRDb250YWluZXJJbmRleChlbGVtZW50KSB7XG4gICAgLy8gTk9URTogc2VhcmNoIGBjb250YWluZXJHcm91cHNgIGJlY2F1c2UgaXQncyBwb3NzaWJsZSBhIGdyb3VwIGNvbnRhaW5zIG5vIHRhYmJhYmxlXG4gICAgLy8gIG5vZGVzLCBidXQgc3RpbGwgY29udGFpbnMgZm9jdXNhYmxlIG5vZGVzIChlLmcuIGlmIHRoZXkgYWxsIGhhdmUgYHRhYmluZGV4PS0xYClcbiAgICAvLyAgYW5kIHdlIHN0aWxsIG5lZWQgdG8gZmluZCB0aGUgZWxlbWVudCBpbiB0aGVyZVxuICAgIHJldHVybiBzdGF0ZS5jb250YWluZXJHcm91cHMuZmluZEluZGV4KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICAgICAgdGFiYmFibGVOb2RlcyA9IF9yZWYudGFiYmFibGVOb2RlcztcbiAgICAgIHJldHVybiBjb250YWluZXIuY29udGFpbnMoZWxlbWVudCkgfHwgLy8gZmFsbCBiYWNrIHRvIGV4cGxpY2l0IHRhYmJhYmxlIHNlYXJjaCB3aGljaCB3aWxsIHRha2UgaW50byBjb25zaWRlcmF0aW9uIGFueVxuICAgICAgLy8gIHdlYiBjb21wb25lbnRzIGlmIHRoZSBgdGFiYmFibGVPcHRpb25zLmdldFNoYWRvd1Jvb3RgIG9wdGlvbiB3YXMgdXNlZCBmb3JcbiAgICAgIC8vICB0aGUgdHJhcCwgZW5hYmxpbmcgc2hhZG93IERPTSBzdXBwb3J0IGluIHRhYmJhYmxlIChgTm9kZS5jb250YWlucygpYCBkb2Vzbid0XG4gICAgICAvLyAgbG9vayBpbnNpZGUgd2ViIGNvbXBvbmVudHMgZXZlbiBpZiBvcGVuKVxuICAgICAgdGFiYmFibGVOb2Rlcy5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBub2RlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uLCB3aGljaCBpcyBleHBlY3RlZCB0byBiZSBhbiBvcHRpb24gdGhhdFxuICAgKiAgY2FuIGJlIGVpdGhlciBhIERPTSBub2RlLCBhIHN0cmluZyB0aGF0IGlzIGEgc2VsZWN0b3IgdG8gZ2V0IGEgbm9kZSwgYGZhbHNlYFxuICAgKiAgKGlmIGEgbm9kZSBpcyBleHBsaWNpdGx5IE5PVCBnaXZlbiksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFueSBvZiB0aGVzZVxuICAgKiAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgZmFsc2UgfCBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IFJldHVybnNcbiAgICogIGB1bmRlZmluZWRgIGlmIHRoZSBvcHRpb24gaXMgbm90IHNwZWNpZmllZDsgYGZhbHNlYCBpZiB0aGUgb3B0aW9uXG4gICAqICByZXNvbHZlZCB0byBgZmFsc2VgIChub2RlIGV4cGxpY2l0bHkgbm90IGdpdmVuKTsgb3RoZXJ3aXNlLCB0aGUgcmVzb2x2ZWRcbiAgICogIERPTSBub2RlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG9wdGlvbiBpcyBzZXQsIG5vdCBgZmFsc2VgLCBhbmQgaXMgbm90LCBvciBkb2VzIG5vdFxuICAgKiAgcmVzb2x2ZSB0byBhIG5vZGUuXG4gICAqL1xuXG5cbiAgdmFyIGdldE5vZGVGb3JPcHRpb24gPSBmdW5jdGlvbiBnZXROb2RlRm9yT3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHBhcmFtc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZS5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvblZhbHVlID09PSB0cnVlKSB7XG4gICAgICBvcHRpb25WYWx1ZSA9IHVuZGVmaW5lZDsgLy8gdXNlIGRlZmF1bHQgdmFsdWVcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvblZhbHVlO1xuICAgICAgfSAvLyBlbHNlLCBlbXB0eSBzdHJpbmcgKGludmFsaWQpLCBudWxsIChpbnZhbGlkKSwgMCAoaW52YWxpZClcblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCB3YXMgc3BlY2lmaWVkIGJ1dCB3YXMgbm90IGEgbm9kZSwgb3IgZGlkIG5vdCByZXR1cm4gYSBub2RlXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG9wdGlvblZhbHVlOyAvLyBjb3VsZCBiZSBIVE1MRWxlbWVudCwgU1ZHRWxlbWVudCwgb3Igbm9uLWVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgbm9kZSA9IGRvYy5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTsgLy8gcmVzb2x2ZSB0byBub2RlLCBvciBudWxsIGlmIGZhaWxzXG5cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCBhcyBzZWxlY3RvciByZWZlcnMgdG8gbm8ga25vd24gbm9kZVwiKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgdmFyIGdldEluaXRpYWxGb2N1c05vZGUgPSBmdW5jdGlvbiBnZXRJbml0aWFsRm9jdXNOb2RlKCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJyk7IC8vIGZhbHNlIGV4cGxpY2l0bHkgaW5kaWNhdGVzIHdlIHdhbnQgbm8gaW5pdGlhbEZvY3VzIGF0IGFsbFxuXG4gICAgaWYgKG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gb3B0aW9uIG5vdCBzcGVjaWZpZWQ6IHVzZSBmYWxsYmFjayBvcHRpb25zXG4gICAgICBpZiAoZmluZENvbnRhaW5lckluZGV4KGRvYy5hY3RpdmVFbGVtZW50KSA+PSAwKSB7XG4gICAgICAgIG5vZGUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaXJzdFRhYmJhYmxlR3JvdXAgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1swXTtcbiAgICAgICAgdmFyIGZpcnN0VGFiYmFibGVOb2RlID0gZmlyc3RUYWJiYWJsZUdyb3VwICYmIGZpcnN0VGFiYmFibGVHcm91cC5maXJzdFRhYmJhYmxlTm9kZTsgLy8gTk9URTogYGZhbGxiYWNrRm9jdXNgIG9wdGlvbiBmdW5jdGlvbiBjYW5ub3QgcmV0dXJuIGBmYWxzZWAgKG5vdCBzdXBwb3J0ZWQpXG5cbiAgICAgICAgbm9kZSA9IGZpcnN0VGFiYmFibGVOb2RlIHx8IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBmb2N1cy10cmFwIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVRhYmJhYmxlTm9kZXMgPSBmdW5jdGlvbiB1cGRhdGVUYWJiYWJsZU5vZGVzKCkge1xuICAgIHN0YXRlLmNvbnRhaW5lckdyb3VwcyA9IHN0YXRlLmNvbnRhaW5lcnMubWFwKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciB0YWJiYWJsZU5vZGVzID0gdGFiYmFibGUoY29udGFpbmVyLCBjb25maWcudGFiYmFibGVPcHRpb25zKTsgLy8gTk9URTogaWYgd2UgaGF2ZSB0YWJiYWJsZSBub2Rlcywgd2UgbXVzdCBoYXZlIGZvY3VzYWJsZSBub2RlczsgZm9jdXNhYmxlIG5vZGVzXG4gICAgICAvLyAgYXJlIGEgc3VwZXJzZXQgb2YgdGFiYmFibGUgbm9kZXNcblxuICAgICAgdmFyIGZvY3VzYWJsZU5vZGVzID0gZm9jdXNhYmxlKGNvbnRhaW5lciwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgdGFiYmFibGVOb2RlczogdGFiYmFibGVOb2RlcyxcbiAgICAgICAgZm9jdXNhYmxlTm9kZXM6IGZvY3VzYWJsZU5vZGVzLFxuICAgICAgICBmaXJzdFRhYmJhYmxlTm9kZTogdGFiYmFibGVOb2Rlcy5sZW5ndGggPiAwID8gdGFiYmFibGVOb2Rlc1swXSA6IG51bGwsXG4gICAgICAgIGxhc3RUYWJiYWJsZU5vZGU6IHRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCA/IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXSA6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIHRoZSBfX3RhYmJhYmxlX18gbm9kZSB0aGF0IGZvbGxvd3MgdGhlIGdpdmVuIG5vZGUgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24sXG4gICAgICAgICAqICBpbiB0aGlzIGNvbnRhaW5lciwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcndhcmRdIFRydWUgaWYgZ29pbmcgaW4gZm9yd2FyZCB0YWIgb3JkZXI7IGZhbHNlIGlmIGdvaW5nXG4gICAgICAgICAqICBpbiByZXZlcnNlLlxuICAgICAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8dW5kZWZpbmVkfSBUaGUgbmV4dCB0YWJiYWJsZSBub2RlLCBpZiBhbnkuXG4gICAgICAgICAqL1xuICAgICAgICBuZXh0VGFiYmFibGVOb2RlOiBmdW5jdGlvbiBuZXh0VGFiYmFibGVOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgZm9yd2FyZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgICAvLyBOT1RFOiBJZiB0YWJpbmRleCBpcyBwb3NpdGl2ZSAoaW4gb3JkZXIgdG8gbWFuaXB1bGF0ZSB0aGUgdGFiIG9yZGVyIHNlcGFyYXRlXG4gICAgICAgICAgLy8gIGZyb20gdGhlIERPTSBvcmRlciksIHRoaXMgX193aWxsIG5vdCB3b3JrX18gYmVjYXVzZSB0aGUgbGlzdCBvZiBmb2N1c2FibGVOb2RlcyxcbiAgICAgICAgICAvLyAgd2hpbGUgaXQgY29udGFpbnMgdGFiYmFibGUgbm9kZXMsIGRvZXMgbm90IHNvcnQgaXRzIG5vZGVzIGluIGFueSBvcmRlciBvdGhlclxuICAgICAgICAgIC8vICB0aGFuIERPTSBvcmRlciwgYmVjYXVzZSBpdCBjYW4ndDogV2hlcmUgd291bGQgeW91IHBsYWNlIGZvY3VzYWJsZSAoYnV0IG5vdFxuICAgICAgICAgIC8vICB0YWJiYWJsZSkgbm9kZXMgaW4gdGhhdCBvcmRlcj8gVGhleSBoYXZlIG5vIG9yZGVyLCBiZWNhdXNlIHRoZXkgYXJlbid0IHRhYmJhbGUuLi5cbiAgICAgICAgICAvLyBTdXBwb3J0IGZvciBwb3NpdGl2ZSB0YWJpbmRleCBpcyBhbHJlYWR5IGJyb2tlbiBhbmQgaGFyZCB0byBtYW5hZ2UgKHBvc3NpYmx5XG4gICAgICAgICAgLy8gIG5vdCBzdXBwb3J0YWJsZSwgVEJEKSwgc28gdGhpcyBpc24ndCBnb2luZyB0byBtYWtlIHRoaW5ncyB3b3JzZSB0aGFuIHRoZXlcbiAgICAgICAgICAvLyAgYWxyZWFkeSBhcmUsIGFuZCBhdCBsZWFzdCBtYWtlcyB0aGluZ3MgYmV0dGVyIGZvciB0aGUgbWFqb3JpdHkgb2YgY2FzZXMgd2hlcmVcbiAgICAgICAgICAvLyAgdGFiaW5kZXggaXMgZWl0aGVyIDAvdW5zZXQgb3IgbmVnYXRpdmUuXG4gICAgICAgICAgLy8gRllJLCBwb3NpdGl2ZSB0YWJpbmRleCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC9pc3N1ZXMvMzc1XG4gICAgICAgICAgdmFyIG5vZGVJZHggPSBmb2N1c2FibGVOb2Rlcy5maW5kSW5kZXgoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBuID09PSBub2RlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG5vZGVJZHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlTm9kZXMuc2xpY2Uobm9kZUlkeCArIDEpLmZpbmQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzVGFiYmFibGUobiwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlTm9kZXMuc2xpY2UoMCwgbm9kZUlkeCkucmV2ZXJzZSgpLmZpbmQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1RhYmJhYmxlKG4sIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHN0YXRlLnRhYmJhYmxlR3JvdXBzID0gc3RhdGUuY29udGFpbmVyR3JvdXBzLmZpbHRlcihmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIHJldHVybiBncm91cC50YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDA7XG4gICAgfSk7IC8vIHRocm93IGlmIG5vIGdyb3VwcyBoYXZlIHRhYmJhYmxlIG5vZGVzIGFuZCB3ZSBkb24ndCBoYXZlIGEgZmFsbGJhY2sgZm9jdXMgbm9kZSBlaXRoZXJcblxuICAgIGlmIChzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggPD0gMCAmJiAhZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpIC8vIHJldHVybmluZyBmYWxzZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wdGlvblxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGZvY3VzLXRyYXAgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBjb250YWluZXIgd2l0aCBhdCBsZWFzdCBvbmUgdGFiYmFibGUgbm9kZSBpbiBpdCBhdCBhbGwgdGltZXMnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRyeUZvY3VzID0gZnVuY3Rpb24gdHJ5Rm9jdXMobm9kZSkge1xuICAgIGlmIChub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBkb2MuYWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykge1xuICAgICAgdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6ICEhY29uZmlnLnByZXZlbnRTY3JvbGxcbiAgICB9KTtcbiAgICBzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IG5vZGU7XG5cbiAgICBpZiAoaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkpIHtcbiAgICAgIG5vZGUuc2VsZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRSZXR1cm5Gb2N1c05vZGUgPSBmdW5jdGlvbiBnZXRSZXR1cm5Gb2N1c05vZGUocHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdzZXRSZXR1cm5Gb2N1cycsIHByZXZpb3VzQWN0aXZlRWxlbWVudCk7XG4gICAgcmV0dXJuIG5vZGUgPyBub2RlIDogbm9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHByZXZpb3VzQWN0aXZlRWxlbWVudDtcbiAgfTsgLy8gVGhpcyBuZWVkcyB0byBiZSBkb25lIG9uIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBpbnN0ZWFkIG9mIGNsaWNrXG4gIC8vIHNvIHRoYXQgaXQgcHJlY2VkZXMgdGhlIGZvY3VzIGV2ZW50LlxuXG5cbiAgdmFyIGNoZWNrUG9pbnRlckRvd24gPSBmdW5jdGlvbiBjaGVja1BvaW50ZXJEb3duKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0QWN0dWFsVGFyZ2V0KGUpO1xuXG4gICAgaWYgKGZpbmRDb250YWluZXJJbmRleCh0YXJnZXQpID49IDApIHtcbiAgICAgIC8vIGFsbG93IHRoZSBjbGljayBzaW5jZSBpdCBvY3VycmVkIGluc2lkZSB0aGUgdHJhcFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZU9ySGFuZGxlcihjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMsIGUpKSB7XG4gICAgICAvLyBpbW1lZGlhdGVseSBkZWFjdGl2YXRlIHRoZSB0cmFwXG4gICAgICB0cmFwLmRlYWN0aXZhdGUoe1xuICAgICAgICAvLyBpZiwgb24gZGVhY3RpdmF0aW9uLCB3ZSBzaG91bGQgcmV0dXJuIGZvY3VzIHRvIHRoZSBub2RlIG9yaWdpbmFsbHktZm9jdXNlZFxuICAgICAgICAvLyAgd2hlbiB0aGUgdHJhcCB3YXMgYWN0aXZhdGVkIChvciB0aGUgY29uZmlndXJlZCBgc2V0UmV0dXJuRm9jdXNgIG5vZGUpLFxuICAgICAgICAvLyAgdGhlbiBhc3N1bWUgaXQncyBhbHNvIE9LIHRvIHJldHVybiBmb2N1cyB0byB0aGUgb3V0c2lkZSBub2RlIHRoYXQgd2FzXG4gICAgICAgIC8vICBqdXN0IGNsaWNrZWQsIGNhdXNpbmcgZGVhY3RpdmF0aW9uLCBhcyBsb25nIGFzIHRoYXQgbm9kZSBpcyBmb2N1c2FibGU7XG4gICAgICAgIC8vICBpZiBpdCBpc24ndCBmb2N1c2FibGUsIHRoZW4gcmV0dXJuIGZvY3VzIHRvIHRoZSBvcmlnaW5hbCBub2RlIGZvY3VzZWRcbiAgICAgICAgLy8gIG9uIGFjdGl2YXRpb24gKG9yIHRoZSBjb25maWd1cmVkIGBzZXRSZXR1cm5Gb2N1c2Agbm9kZSlcbiAgICAgICAgLy8gTk9URTogYnkgc2V0dGluZyBgcmV0dXJuRm9jdXM6IGZhbHNlYCwgZGVhY3RpdmF0ZSgpIHdpbGwgZG8gbm90aGluZyxcbiAgICAgICAgLy8gIHdoaWNoIHdpbGwgcmVzdWx0IGluIHRoZSBvdXRzaWRlIGNsaWNrIHNldHRpbmcgZm9jdXMgdG8gdGhlIG5vZGVcbiAgICAgICAgLy8gIHRoYXQgd2FzIGNsaWNrZWQsIHdoZXRoZXIgaXQncyBmb2N1c2FibGUgb3Igbm90OyBieSBzZXR0aW5nXG4gICAgICAgIC8vICBgcmV0dXJuRm9jdXM6IHRydWVgLCB3ZSdsbCBhdHRlbXB0IHRvIHJlLWZvY3VzIHRoZSBub2RlIG9yaWdpbmFsbHktZm9jdXNlZFxuICAgICAgICAvLyAgb24gYWN0aXZhdGlvbiAob3IgdGhlIGNvbmZpZ3VyZWQgYHNldFJldHVybkZvY3VzYCBub2RlKVxuICAgICAgICByZXR1cm5Gb2N1czogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlICYmICFpc0ZvY3VzYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoaXMgaXMgbmVlZGVkIGZvciBtb2JpbGUgZGV2aWNlcy5cbiAgICAvLyAoSWYgd2UnbGwgb25seSBsZXQgYGNsaWNrYCBldmVudHMgdGhyb3VnaCxcbiAgICAvLyB0aGVuIG9uIG1vYmlsZSB0aGV5IHdpbGwgYmUgYmxvY2tlZCBhbnl3YXlzIGlmIGB0b3VjaHN0YXJ0YCBpcyBibG9ja2VkLilcblxuXG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZSkpIHtcbiAgICAgIC8vIGFsbG93IHRoZSBjbGljayBvdXRzaWRlIHRoZSB0cmFwIHRvIHRha2UgcGxhY2VcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG90aGVyd2lzZSwgcHJldmVudCB0aGUgY2xpY2tcblxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9OyAvLyBJbiBjYXNlIGZvY3VzIGVzY2FwZXMgdGhlIHRyYXAgZm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIHB1bGwgaXQgYmFjayBpbi5cblxuXG4gIHZhciBjaGVja0ZvY3VzSW4gPSBmdW5jdGlvbiBjaGVja0ZvY3VzSW4oZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG4gICAgdmFyIHRhcmdldENvbnRhaW5lZCA9IGZpbmRDb250YWluZXJJbmRleCh0YXJnZXQpID49IDA7IC8vIEluIEZpcmVmb3ggd2hlbiB5b3UgVGFiIG91dCBvZiBhbiBpZnJhbWUgdGhlIERvY3VtZW50IGlzIGJyaWVmbHkgZm9jdXNlZC5cblxuICAgIGlmICh0YXJnZXRDb250YWluZWQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIGlmICh0YXJnZXRDb250YWluZWQpIHtcbiAgICAgICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzY2FwZWQhIHB1bGwgaXQgYmFjayBpbiB0byB3aGVyZSBpdCBqdXN0IGxlZnRcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB0cnlGb2N1cyhzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH1cbiAgfTsgLy8gSGlqYWNrIFRhYiBldmVudHMgb24gdGhlIGZpcnN0IGFuZCBsYXN0IGZvY3VzYWJsZSBub2RlcyBvZiB0aGUgdHJhcCxcbiAgLy8gaW4gb3JkZXIgdG8gcHJldmVudCBmb2N1cyBmcm9tIGVzY2FwaW5nLiBJZiBpdCBlc2NhcGVzIGZvciBldmVuIGFcbiAgLy8gbW9tZW50IGl0IGNhbiBlbmQgdXAgc2Nyb2xsaW5nIHRoZSBwYWdlIGFuZCBjYXVzaW5nIGNvbmZ1c2lvbiBzbyB3ZVxuICAvLyBraW5kIG9mIG5lZWQgdG8gY2FwdHVyZSB0aGUgYWN0aW9uIGF0IHRoZSBrZXlkb3duIHBoYXNlLlxuXG5cbiAgdmFyIGNoZWNrVGFiID0gZnVuY3Rpb24gY2hlY2tUYWIoZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIHZhciBkZXN0aW5hdGlvbk5vZGUgPSBudWxsO1xuXG4gICAgaWYgKHN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IGlzIGFjdHVhbGx5IGNvbnRhaW5lZCBpbiBhIGdyb3VwXG4gICAgICAvLyBOT1RFOiB0aGUgdGFyZ2V0IG1heSBhbHNvIGJlIHRoZSBjb250YWluZXIgaXRzZWxmIGlmIGl0J3MgZm9jdXNhYmxlXG4gICAgICAvLyAgd2l0aCB0YWJJbmRleD0nLTEnIGFuZCB3YXMgZ2l2ZW4gaW5pdGlhbCBmb2N1c1xuICAgICAgdmFyIGNvbnRhaW5lckluZGV4ID0gZmluZENvbnRhaW5lckluZGV4KHRhcmdldCk7XG4gICAgICB2YXIgY29udGFpbmVyR3JvdXAgPSBjb250YWluZXJJbmRleCA+PSAwID8gc3RhdGUuY29udGFpbmVyR3JvdXBzW2NvbnRhaW5lckluZGV4XSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGNvbnRhaW5lckluZGV4IDwgMCkge1xuICAgICAgICAvLyB0YXJnZXQgbm90IGZvdW5kIGluIGFueSBncm91cDogcXVpdGUgcG9zc2libGUgZm9jdXMgaGFzIGVzY2FwZWQgdGhlIHRyYXAsXG4gICAgICAgIC8vICBzbyBicmluZyBpdCBiYWNrIGluIHRvLi4uXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgLy8gLi4udGhlIGxhc3Qgbm9kZSBpbiB0aGUgbGFzdCBncm91cFxuICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzW3N0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCAtIDFdLmxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gLi4udGhlIGZpcnN0IG5vZGUgaW4gdGhlIGZpcnN0IGdyb3VwXG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gc3RhdGUudGFiYmFibGVHcm91cHNbMF0uZmlyc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAvLyBSRVZFUlNFXG4gICAgICAgIC8vIGlzIHRoZSB0YXJnZXQgdGhlIGZpcnN0IHRhYmJhYmxlIG5vZGUgaW4gYSBncm91cD9cbiAgICAgICAgdmFyIHN0YXJ0T2ZHcm91cEluZGV4ID0gZmluZEluZGV4KHN0YXRlLnRhYmJhYmxlR3JvdXBzLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgZmlyc3RUYWJiYWJsZU5vZGUgPSBfcmVmMi5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0T2ZHcm91cEluZGV4IDwgMCAmJiAoY29udGFpbmVyR3JvdXAuY29udGFpbmVyID09PSB0YXJnZXQgfHwgaXNGb2N1c2FibGUodGFyZ2V0LCBjb25maWcudGFiYmFibGVPcHRpb25zKSAmJiAhaXNUYWJiYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpICYmICFjb250YWluZXJHcm91cC5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCwgZmFsc2UpKSkge1xuICAgICAgICAgIC8vIGFuIGV4Y2VwdGlvbiBjYXNlIHdoZXJlIHRoZSB0YXJnZXQgaXMgZWl0aGVyIHRoZSBjb250YWluZXIgaXRzZWxmLCBvclxuICAgICAgICAgIC8vICBhIG5vbi10YWJiYWJsZSBub2RlIHRoYXQgd2FzIGdpdmVuIGZvY3VzIChpLmUuIHRhYmluZGV4IGlzIG5lZ2F0aXZlXG4gICAgICAgICAgLy8gIGFuZCB1c2VyIGNsaWNrZWQgb24gaXQgb3Igbm9kZSB3YXMgcHJvZ3JhbW1hdGljYWxseSBnaXZlbiBmb2N1cylcbiAgICAgICAgICAvLyAgYW5kIGlzIG5vdCBmb2xsb3dlZCBieSBhbnkgb3RoZXIgdGFiYmFibGUgbm9kZSwgaW4gd2hpY2hcbiAgICAgICAgICAvLyAgY2FzZSwgd2Ugc2hvdWxkIGhhbmRsZSBzaGlmdCt0YWIgYXMgaWYgZm9jdXMgd2VyZSBvbiB0aGUgY29udGFpbmVyJ3NcbiAgICAgICAgICAvLyAgZmlyc3QgdGFiYmFibGUgbm9kZSwgYW5kIGdvIHRvIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIExBU1QgZ3JvdXBcbiAgICAgICAgICBzdGFydE9mR3JvdXBJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBZRVM6IHRoZW4gc2hpZnQrdGFiIHNob3VsZCBnbyB0byB0aGUgbGFzdCB0YWJiYWJsZSBub2RlIGluIHRoZVxuICAgICAgICAgIC8vICBwcmV2aW91cyBncm91cCAoYW5kIHdyYXAgYXJvdW5kIHRvIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgb2ZcbiAgICAgICAgICAvLyAgdGhlIExBU1QgZ3JvdXAgaWYgaXQncyB0aGUgZmlyc3QgdGFiYmFibGUgbm9kZSBvZiB0aGUgRklSU1QgZ3JvdXApXG4gICAgICAgICAgdmFyIGRlc3RpbmF0aW9uR3JvdXBJbmRleCA9IHN0YXJ0T2ZHcm91cEluZGV4ID09PSAwID8gc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMSA6IHN0YXJ0T2ZHcm91cEluZGV4IC0gMTtcbiAgICAgICAgICB2YXIgZGVzdGluYXRpb25Hcm91cCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzW2Rlc3RpbmF0aW9uR3JvdXBJbmRleF07XG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gZGVzdGluYXRpb25Hcm91cC5sYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGT1JXQVJEXG4gICAgICAgIC8vIGlzIHRoZSB0YXJnZXQgdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBpbiBhIGdyb3VwP1xuICAgICAgICB2YXIgbGFzdE9mR3JvdXBJbmRleCA9IGZpbmRJbmRleChzdGF0ZS50YWJiYWJsZUdyb3VwcywgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgdmFyIGxhc3RUYWJiYWJsZU5vZGUgPSBfcmVmMy5sYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChsYXN0T2ZHcm91cEluZGV4IDwgMCAmJiAoY29udGFpbmVyR3JvdXAuY29udGFpbmVyID09PSB0YXJnZXQgfHwgaXNGb2N1c2FibGUodGFyZ2V0LCBjb25maWcudGFiYmFibGVPcHRpb25zKSAmJiAhaXNUYWJiYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpICYmICFjb250YWluZXJHcm91cC5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCkpKSB7XG4gICAgICAgICAgLy8gYW4gZXhjZXB0aW9uIGNhc2Ugd2hlcmUgdGhlIHRhcmdldCBpcyB0aGUgY29udGFpbmVyIGl0c2VsZiwgb3JcbiAgICAgICAgICAvLyAgYSBub24tdGFiYmFibGUgbm9kZSB0aGF0IHdhcyBnaXZlbiBmb2N1cyAoaS5lLiB0YWJpbmRleCBpcyBuZWdhdGl2ZVxuICAgICAgICAgIC8vICBhbmQgdXNlciBjbGlja2VkIG9uIGl0IG9yIG5vZGUgd2FzIHByb2dyYW1tYXRpY2FsbHkgZ2l2ZW4gZm9jdXMpXG4gICAgICAgICAgLy8gIGFuZCBpcyBub3QgZm9sbG93ZWQgYnkgYW55IG90aGVyIHRhYmJhYmxlIG5vZGUsIGluIHdoaWNoXG4gICAgICAgICAgLy8gIGNhc2UsIHdlIHNob3VsZCBoYW5kbGUgdGFiIGFzIGlmIGZvY3VzIHdlcmUgb24gdGhlIGNvbnRhaW5lcidzXG4gICAgICAgICAgLy8gIGxhc3QgdGFiYmFibGUgbm9kZSwgYW5kIGdvIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVCBncm91cFxuICAgICAgICAgIGxhc3RPZkdyb3VwSW5kZXggPSBjb250YWluZXJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBZRVM6IHRoZW4gdGFiIHNob3VsZCBnbyB0byB0aGUgZmlyc3QgdGFiYmFibGUgbm9kZSBpbiB0aGUgbmV4dFxuICAgICAgICAgIC8vICBncm91cCAoYW5kIHdyYXAgYXJvdW5kIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVFxuICAgICAgICAgIC8vICBncm91cCBpZiBpdCdzIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIExBU1QgZ3JvdXApXG4gICAgICAgICAgdmFyIF9kZXN0aW5hdGlvbkdyb3VwSW5kZXggPSBsYXN0T2ZHcm91cEluZGV4ID09PSBzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxID8gMCA6IGxhc3RPZkdyb3VwSW5kZXggKyAxO1xuXG4gICAgICAgICAgdmFyIF9kZXN0aW5hdGlvbkdyb3VwID0gc3RhdGUudGFiYmFibGVHcm91cHNbX2Rlc3RpbmF0aW9uR3JvdXBJbmRleF07XG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gX2Rlc3RpbmF0aW9uR3JvdXAuZmlyc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTk9URTogdGhlIGZhbGxiYWNrRm9jdXMgb3B0aW9uIGRvZXMgbm90IHN1cHBvcnQgcmV0dXJuaW5nIGZhbHNlIHRvIG9wdC1vdXRcbiAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICB9XG5cbiAgICBpZiAoZGVzdGluYXRpb25Ob2RlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0cnlGb2N1cyhkZXN0aW5hdGlvbk5vZGUpO1xuICAgIH0gLy8gZWxzZSwgbGV0IHRoZSBicm93c2VyIHRha2UgY2FyZSBvZiBbc2hpZnQrXXRhYiBhbmQgbW92ZSB0aGUgZm9jdXNcblxuICB9O1xuXG4gIHZhciBjaGVja0tleSA9IGZ1bmN0aW9uIGNoZWNrS2V5KGUpIHtcbiAgICBpZiAoaXNFc2NhcGVFdmVudChlKSAmJiB2YWx1ZU9ySGFuZGxlcihjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMsIGUpICE9PSBmYWxzZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzVGFiRXZlbnQoZSkpIHtcbiAgICAgIGNoZWNrVGFiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2hlY2tDbGljayA9IGZ1bmN0aW9uIGNoZWNrQ2xpY2soZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG5cbiAgICBpZiAoZmluZENvbnRhaW5lckluZGV4KHRhcmdldCkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZU9ySGFuZGxlcihjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMsIGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfTsgLy9cbiAgLy8gRVZFTlQgTElTVEVORVJTXG4gIC8vXG5cblxuICB2YXIgYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG5cblxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuYWN0aXZhdGVUcmFwKHRyYXApOyAvLyBEZWxheSBlbnN1cmVzIHRoYXQgdGhlIGZvY3VzZWQgZWxlbWVudCBkb2Vzbid0IGNhcHR1cmUgdGhlIGV2ZW50XG4gICAgLy8gdGhhdCBjYXVzZWQgdGhlIGZvY3VzIHRyYXAgYWN0aXZhdGlvbi5cblxuICAgIHN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIgPSBjb25maWcuZGVsYXlJbml0aWFsRm9jdXMgPyBkZWxheShmdW5jdGlvbiAoKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH0pIDogdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH07XG5cbiAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfTsgLy9cbiAgLy8gVFJBUCBERUZJTklUSU9OXG4gIC8vXG5cblxuICB0cmFwID0ge1xuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICByZXR1cm4gc3RhdGUuYWN0aXZlO1xuICAgIH0sXG5cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnBhdXNlZDtcbiAgICB9LFxuXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRlT3B0aW9ucykge1xuICAgICAgaWYgKHN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG9uQWN0aXZhdGUgPSBnZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCAnb25BY3RpdmF0ZScpO1xuICAgICAgdmFyIG9uUG9zdEFjdGl2YXRlID0gZ2V0T3B0aW9uKGFjdGl2YXRlT3B0aW9ucywgJ29uUG9zdEFjdGl2YXRlJyk7XG4gICAgICB2YXIgY2hlY2tDYW5Gb2N1c1RyYXAgPSBnZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCAnY2hlY2tDYW5Gb2N1c1RyYXAnKTtcblxuICAgICAgaWYgKCFjaGVja0NhbkZvY3VzVHJhcCkge1xuICAgICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmFjdGl2ZSA9IHRydWU7XG4gICAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvYy5hY3RpdmVFbGVtZW50O1xuXG4gICAgICBpZiAob25BY3RpdmF0ZSkge1xuICAgICAgICBvbkFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hBY3RpdmF0aW9uID0gZnVuY3Rpb24gZmluaXNoQWN0aXZhdGlvbigpIHtcbiAgICAgICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgaWYgKG9uUG9zdEFjdGl2YXRlKSB7XG4gICAgICAgICAgb25Qb3N0QWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgIGNoZWNrQ2FuRm9jdXNUcmFwKHN0YXRlLmNvbnRhaW5lcnMuY29uY2F0KCkpLnRoZW4oZmluaXNoQWN0aXZhdGlvbiwgZmluaXNoQWN0aXZhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmaW5pc2hBY3RpdmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uIGRlYWN0aXZhdGUoZGVhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICAgIGlmICghc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgb25EZWFjdGl2YXRlOiBjb25maWcub25EZWFjdGl2YXRlLFxuICAgICAgICBvblBvc3REZWFjdGl2YXRlOiBjb25maWcub25Qb3N0RGVhY3RpdmF0ZSxcbiAgICAgICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogY29uZmlnLmNoZWNrQ2FuUmV0dXJuRm9jdXNcbiAgICAgIH0sIGRlYWN0aXZhdGVPcHRpb25zKTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIpOyAvLyBub29wIGlmIHVuZGVmaW5lZFxuXG4gICAgICBzdGF0ZS5kZWxheUluaXRpYWxGb2N1c1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICBzdGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgYWN0aXZlRm9jdXNUcmFwcy5kZWFjdGl2YXRlVHJhcCh0cmFwKTtcbiAgICAgIHZhciBvbkRlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uRGVhY3RpdmF0ZScpO1xuICAgICAgdmFyIG9uUG9zdERlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uUG9zdERlYWN0aXZhdGUnKTtcbiAgICAgIHZhciBjaGVja0NhblJldHVybkZvY3VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdjaGVja0NhblJldHVybkZvY3VzJyk7XG4gICAgICB2YXIgcmV0dXJuRm9jdXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3JldHVybkZvY3VzJywgJ3JldHVybkZvY3VzT25EZWFjdGl2YXRlJyk7XG5cbiAgICAgIGlmIChvbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgb25EZWFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hEZWFjdGl2YXRpb24gPSBmdW5jdGlvbiBmaW5pc2hEZWFjdGl2YXRpb24oKSB7XG4gICAgICAgIGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAgIHRyeUZvY3VzKGdldFJldHVybkZvY3VzTm9kZShzdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25Qb3N0RGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgb25Qb3N0RGVhY3RpdmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAocmV0dXJuRm9jdXMgJiYgY2hlY2tDYW5SZXR1cm5Gb2N1cykge1xuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzKGdldFJldHVybkZvY3VzTm9kZShzdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pKS50aGVuKGZpbmlzaERlYWN0aXZhdGlvbiwgZmluaXNoRGVhY3RpdmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZpbmlzaERlYWN0aXZhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICBpZiAoc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdW5wYXVzZTogZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICAgIGlmICghc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJFbGVtZW50cyhjb250YWluZXJFbGVtZW50cykge1xuICAgICAgdmFyIGVsZW1lbnRzQXNBcnJheSA9IFtdLmNvbmNhdChjb250YWluZXJFbGVtZW50cykuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgc3RhdGUuY29udGFpbmVycyA9IGVsZW1lbnRzQXNBcnJheS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvYy5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9OyAvLyBpbml0aWFsaXplIGNvbnRhaW5lciBlbGVtZW50c1xuXG4gIHRyYXAudXBkYXRlQ29udGFpbmVyRWxlbWVudHMoZWxlbWVudHMpO1xuICByZXR1cm4gdHJhcDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUZvY3VzVHJhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtdHJhcC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/focus-trap/dist/focus-trap.esm.js\n"));

/***/ }),

/***/ "./node_modules/focus-trap/node_modules/tabbable/dist/index.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/focus-trap/node_modules/tabbable/dist/index.esm.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   focusable: function() { return /* binding */ focusable; },\n/* harmony export */   isFocusable: function() { return /* binding */ isFocusable; },\n/* harmony export */   isTabbable: function() { return /* binding */ isTabbable; },\n/* harmony export */   tabbable: function() { return /* binding */ tabbable; }\n/* harmony export */ });\n/*!\n* tabbable 5.3.3\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\n\n\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      } // iterate over shadow content if possible\n\n\n      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n\n  return candidates;\n};\n\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || getRootNode(node);\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n\n  return width === 0 && height === 0;\n};\n\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n\n\n  var nodeRootHost = getRootNode(node).host;\n  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n\n    if (nodeIsAttached) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    } // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  } // visible, as far as we can tell, or per current `displayCheck` mode\n\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i); // when the first <legend> (in document order) is found\n\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        } // the disabled <fieldset> containing `node` has no <legend>\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  } // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n\n\n  return false;\n};\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\n\n\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scope;\n    var element = isScope ? item.scope : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n\n  return sortByOrder(candidates);\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9ub2RlX21vZHVsZXMvdGFiYmFibGUvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLDRCQUE0QjtBQUN2QyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxXQUFXO0FBQ3pCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsdUJBQXVCLGlEQUFpRDtBQUN0RjtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsa0JBQWtCO0FBQ2hDOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsU0FBUztBQUNwQixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksb0VBQW9FO0FBQ3hFLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTix1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RCxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFd0Q7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAvbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2Rpc3QvaW5kZXguZXNtLmpzPzZlYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIHRhYmJhYmxlIDUuMy4zXG4qIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvdGFiYmFibGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbnZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYScsICdhW2hyZWZdJywgJ2J1dHRvbicsICdbdGFiaW5kZXhdOm5vdChzbG90KScsICdhdWRpb1tjb250cm9sc10nLCAndmlkZW9bY29udHJvbHNdJywgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJywgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJywgJ2RldGFpbHMnXTtcbnZhciBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG52YXIgTm9FbGVtZW50ID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnO1xudmFyIG1hdGNoZXMgPSBOb0VsZW1lbnQgPyBmdW5jdGlvbiAoKSB7fSA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xudmFyIGdldFJvb3ROb2RlID0gIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZSA/IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG59IDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudDtcbn07XG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgY29udGFpbmVyIHRvIGNoZWNrIGluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciB0byBjaGVja1xuICogQHBhcmFtIHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICovXG5cbnZhciBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpKTtcblxuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cblxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZXNTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZSBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZXNTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59XG4gKi9cblxuXG52YXIgZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5ID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KGVsZW1lbnRzLCBpbmNsdWRlQ29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gW107XG4gIHZhciBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcblxuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG5cbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICB2YXIgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIHZhciBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgdmFyIG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIG5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgdmFyIHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcblxuICAgICAgaWYgKHZhbGlkQ2FuZGlkYXRlICYmIG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQpICYmIChpbmNsdWRlQ29udGFpbmVyIHx8ICFlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkpIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSAvLyBpdGVyYXRlIG92ZXIgc2hhZG93IGNvbnRlbnQgaWYgcG9zc2libGVcblxuXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdCB8fCAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuZ2V0U2hhZG93Um9vdChlbGVtZW50KTtcbiAgICAgIHZhciB2YWxpZFNoYWRvd1Jvb3QgPSAhb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KTtcblxuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNjb3BlIElJRiBhIHNoYWRvdyByb290IG5vZGUgd2FzIGdpdmVuOyBvdGhlcndpc2UsIGFuIHVuZGlzY2xvc2VkXG4gICAgICAgIC8vICBzaGFkb3cgZXhpc3RzLCBzbyBsb29rIGF0IGxpZ2h0IGRvbSBjaGlsZHJlbiBhcyBmYWxsYmFjayBCVVQgY3JlYXRlIGEgc2NvcGUgZm9yIGFueVxuICAgICAgICAvLyAgY2hpbGQgY2FuZGlkYXRlcyBmb3VuZCBiZWNhdXNlIHRoZXkncmUgbGlrZWx5IHNsb3R0ZWQgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vICBjaGlsZHJlbiBvZiB0aGUgd2ViIGNvbXBvbmVudCBlbGVtZW50ICh3aGljaCBoYXMgdGhlIHNoYWRvdyksIGluIHRoZSBsaWdodCBkb20sIGJ1dFxuICAgICAgICAvLyAgc2xvdHRlZCBzb21ld2hlcmUgX2luc2lkZV8gdGhlIHVuZGlzY2xvc2VkIHNoYWRvdykgLS0gdGhlIHNjb3BlIGlzIGNyZWF0ZWQgYmVsb3csXG4gICAgICAgIC8vICBfYWZ0ZXJfIHdlIHJldHVybiBmcm9tIHRoaXMgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgdmFyIF9uZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KHNoYWRvd1Jvb3QgPT09IHRydWUgPyBlbGVtZW50LmNoaWxkcmVuIDogc2hhZG93Um9vdC5jaGlsZHJlbiwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBfbmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogX25lc3RlZENhbmRpZGF0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0LmFwcGx5KGVsZW1lbnRzVG9DaGVjaywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG52YXIgZ2V0VGFiaW5kZXggPSBmdW5jdGlvbiBnZXRUYWJpbmRleChub2RlLCBpc1Njb3BlKSB7XG4gIGlmIChub2RlLnRhYkluZGV4IDwgMCkge1xuICAgIC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIC0xIHdoZW4gdGhlICd0YWJpbmRleCcgYXR0cmlidXRlIGlzbid0IHNwZWNpZmllZCBpbiB0aGUgRE9NLFxuICAgIC8vIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gICAgLy8gb3JkZXIsIGNvbnNpZGVyIHRoZWlyIHRhYiBpbmRleCB0byBiZSAwLlxuICAgIC8vIEFsc28gYnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAgIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuICAgIC8vXG4gICAgLy8gaXNTY29wZSBpcyBwb3NpdGl2ZSBmb3IgY3VzdG9tIGVsZW1lbnQgd2l0aCBzaGFkb3cgcm9vdCBvciBzbG90IHRoYXQgYnkgZGVmYXVsdFxuICAgIC8vIGhhdmUgdGFiSW5kZXggLTEsIGJ1dCBuZWVkIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgdGhlaXJcbiAgICAvLyBjb250ZW50IHRvIGJlIGluc2VydGVkIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgaWYgKChpc1Njb3BlIHx8IC9eKEFVRElPfFZJREVPfERFVEFJTFMpJC8udGVzdChub2RlLnRhZ05hbWUpIHx8IG5vZGUuaXNDb250ZW50RWRpdGFibGUpICYmIGlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG5cbnZhciBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbnZhciBpc0lucHV0ID0gZnVuY3Rpb24gaXNJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xuXG52YXIgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcblxudmFyIGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkge1xuICB2YXIgciA9IG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWSc7XG4gIH0pO1xuICByZXR1cm4gcjtcbn07XG5cbnZhciBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8obm9kZXMsIGZvcm0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc1RhYmJhYmxlUmFkaW8obm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG5cbiAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJyk7XG4gIH07XG5cbiAgdmFyIHJhZGlvU2V0O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxudmFyIGlzUmFkaW8gPSBmdW5jdGlvbiBpc1JhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxudmFyIGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG52YXIgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIGlzWmVyb0FyZWEobm9kZSkge1xuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4obm9kZSwgX3JlZikge1xuICB2YXIgZGlzcGxheUNoZWNrID0gX3JlZi5kaXNwbGF5Q2hlY2ssXG4gICAgICBnZXRTaGFkb3dSb290ID0gX3JlZi5nZXRTaGFkb3dSb290O1xuXG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXG4gIC8vICAodGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSBhIHZlcnkgbG9uZyB3YXkgYmFjaylcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgdmFyIG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgJ2RldGFpbHM6bm90KFtvcGVuXSkgKicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxuICAvLyAgKGJ1dCBOT1QgX3RoZV8gZG9jdW1lbnQ7IHNlZSBzZWNvbmQgJ0lmJyBjb21tZW50IGJlbG93IGZvciBtb3JlKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXG4gIC8vICBzaGFkb3csIGFuZCBhbGwgbm9kZXMgaXQgY29udGFpbnMsIGlzIG5ldmVyIGNvbnNpZGVyZWQgaW4gdGhlIGRvY3VtZW50IHNpbmNlIHNoYWRvd3NcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXG4gIC8vICB2aXNpYmlsaXR5LCBpbmNsdWRpbmcgYWxsIHRoZSBub2RlcyBpdCBjb250YWlucykuIFRoZSBob3N0IGNvdWxkIGJlIGFueSBub3JtYWwgbm9kZSxcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXG4gIC8vICB0ZXN0ZWQpLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cblxuXG4gIHZhciBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlKS5ob3N0O1xuICB2YXIgbm9kZUlzQXR0YWNoZWQgPSAobm9kZVJvb3RIb3N0ID09PSBudWxsIHx8IG5vZGVSb290SG9zdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVJvb3RIb3N0Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KSkgfHwgbm9kZS5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpO1xuXG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcbiAgICAgIC8vICAnbm9uLXplcm8tYXJlYScgZmFsbGJhY2tcbiAgICAgIHZhciBvcmlnaW5hbE5vZGUgPSBub2RlO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUobm9kZSk7XG5cbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgJiYgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJiBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBvcmlnaW5hbE5vZGU7XG4gICAgfSAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG4gICAgLy8gU2luY2Ugd2UgZGlkbid0IGZpbmQgaXQgc2l0dGluZyBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgKG9yIHNoYWRvd3MgYXJlIGRpc2FibGVkKVxuICAgIC8vICBub3cgd2UgY2FuIGp1c3QgdGVzdCB0byBzZWUgaWYgaXQgd291bGQgbm9ybWFsbHkgYmUgdmlzaWJsZSBvciBub3QsIHByb3ZpZGVkIGl0J3NcbiAgICAvLyAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9jdW1lbnQuXG4gICAgLy8gTk9URTogV2UgbXVzdCBjb25zaWRlciBjYXNlIHdoZXJlIG5vZGUgaXMgaW5zaWRlIGEgc2hhZG93IERPTSBhbmQgZ2l2ZW4gZGlyZWN0bHkgdG9cbiAgICAvLyAgYGlzVGFiYmFibGUoKWAgb3IgYGlzRm9jdXNhYmxlKClgIC0tIHJlZ2FyZGxlc3Mgb2YgYGdldFNoYWRvd1Jvb3RgIG9wdGlvbiBzZXR0aW5nLlxuXG5cbiAgICBpZiAobm9kZUlzQXR0YWNoZWQpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9IC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxuICAgIC8vICBBUEkgd2lsbCBfX2Fsd2F5c19fIHJldHVybiB6ZXJvIHJlY3RzICh0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBSZWFjdFxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcbiAgICAvL1xuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxuICAgIC8vICBBUElzIG9uIG5vZGVzIGluIGRldGFjaGVkIGNvbnRhaW5lcnMgaGFzIGFjdHVhbGx5IGltcGxpY2l0bHkgdXNlZCB0YWJiYWJsZSBpbiB3aGF0XG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cblxuICB9IGVsc2UgaWYgKGRpc3BsYXlDaGVjayA9PT0gJ25vbi16ZXJvLWFyZWEnKSB7XG4gICAgLy8gTk9URTogRXZlbiB0aG91Z2ggdGhpcyB0ZXN0cyB0aGF0IHRoZSBub2RlJ3MgY2xpZW50IHJlY3QgaXMgbm9uLXplcm8gdG8gZGV0ZXJtaW5lXG4gICAgLy8gIHdoZXRoZXIgaXQncyBkaXNwbGF5ZWQsIGFuZCB0aGF0IGEgZGV0YWNoZWQgbm9kZSB3aWxsIF9fYWx3YXlzX18gaGF2ZSBhIHplcm8tYXJlYVxuICAgIC8vICBjbGllbnQgcmVjdCwgd2UgZG9uJ3Qgc3BlY2lhbC1jYXNlIGZvciB3aGV0aGVyIHRoZSBub2RlIGlzIGF0dGFjaGVkIG9yIG5vdC4gSW5cbiAgICAvLyAgdGhpcyBtb2RlLCB3ZSBkbyB3YW50IHRvIGNvbnNpZGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHplcm8gYXJlYSB0byBiZSBoaWRkZW4gYXQgYWxsXG4gICAgLy8gIHRpbWVzLCBhbmQgdGhhdCBpbmNsdWRlcyBhdHRhY2hlZCBvciBub3QuXG4gICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gIH0gLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrYCBtb2RlXG5cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5cblxudmFyIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpIHtcbiAgaWYgKC9eKElOUFVUfEJVVFRPTnxTRUxFQ1R8VEVYVEFSRUEpJC8udGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7IC8vIGNoZWNrIGlmIGBub2RlYCBpcyBjb250YWluZWQgaW4gYSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpOyAvLyB3aGVuIHRoZSBmaXJzdCA8bGVnZW5kPiAoaW4gZG9jdW1lbnQgb3JkZXIpIGlzIGZvdW5kXG5cbiAgICAgICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0xFR0VORCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgPGZpZWxkc2V0PiBpcyBub3QgbmVzdGVkIGluIGFub3RoZXIgZGlzYWJsZWQgPGZpZWxkc2V0PixcbiAgICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGBub2RlYCBpcyBhIGRlc2NlbmRhbnQgb2YgaXRzIGZpcnN0IDxsZWdlbmQ+XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKHBhcmVudE5vZGUsICdmaWVsZHNldFtkaXNhYmxlZF0gKicpID8gdHJ1ZSA6ICFjaGlsZC5jb250YWlucyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdGhlIGRpc2FibGVkIDxmaWVsZHNldD4gY29udGFpbmluZyBgbm9kZWAgaGFzIG5vIDxsZWdlbmQ+XG5cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH0gLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xuICAvLyAgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKG5vZGUuZGlzYWJsZWQgfHwgaXNIaWRkZW5JbnB1dChub2RlKSB8fCBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fCAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHwgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmIChpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHwgZ2V0VGFiaW5kZXgobm9kZSkgPCAwIHx8ICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUoc2hhZG93SG9zdE5vZGUpIHtcbiAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG5cbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXG4gIC8vIGJyb3dzZXJzIHdpbGwgbm90IGFsbG93IHRhYiB0YXJnZXRpbmcgc2FpZCBlbGVtZW50J3MgY2hpbGRyZW4uXG5cblxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59IGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIEVsZW1lbnRbXVxuICovXG5cblxudmFyIHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcykge1xuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICB2YXIgaXNTY29wZSA9ICEhaXRlbS5zY29wZTtcbiAgICB2YXIgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlIDogaXRlbTtcbiAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICB2YXIgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG5cbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGUgPyByZWd1bGFyVGFiYmFibGVzLnB1c2guYXBwbHkocmVndWxhclRhYmJhYmxlcywgZWxlbWVudHMpIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlcy5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc29ydGFibGUpIHtcbiAgICBzb3J0YWJsZS5pc1Njb3BlID8gYWNjLnB1c2guYXBwbHkoYWNjLCBzb3J0YWJsZS5jb250ZW50KSA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKS5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG52YXIgdGFiYmFibGUgPSBmdW5jdGlvbiB0YWJiYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG5cbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoZWwsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxudmFyIGZvY3VzYWJsZSA9IGZ1bmN0aW9uIGZvY3VzYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG5cbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3RcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG52YXIgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVGFiYmFibGUobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XG5cbnZhciBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmV4cG9ydCB7IGZvY3VzYWJsZSwgaXNGb2N1c2FibGUsIGlzVGFiYmFibGUsIHRhYmJhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/focus-trap/node_modules/tabbable/dist/index.esm.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsd0ZBQTRCOztBQUV6UCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzP2NhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2dsb2JhbF9wcm9jZXNzLCBfZ2xvYmFsX3Byb2Nlc3MxO1xubW9kdWxlLmV4cG9ydHMgPSAoKF9nbG9iYWxfcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzLmVudikgJiYgdHlwZW9mICgoX2dsb2JhbF9wcm9jZXNzMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzMS5lbnYpID09PSBcIm9iamVjdFwiID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3NcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./src/components/form/map.tsx":
/*!*************************************!*\
  !*** ./src/components/form/map.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mapper: function() { return /* binding */ Mapper; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_map_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-map-gl */ \"./node_modules/react-map-gl/dist/esm/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _mapbox_search_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mapbox/search-js-react */ \"./node_modules/@mapbox/search-js-react/dist/index-esm.js\");\n/* harmony import */ var _utils_mapboxToken__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @utils/mapboxToken */ \"./src/utils/mapboxToken.ts\");\n/* harmony import */ var _barrel_optimize_names_Field_Input_Label_headlessui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=Field,Input,Label!=!@headlessui/react */ \"__barrel_optimize__?names=Field,Input,Label!=!./node_modules/@headlessui/react/dist/headlessui.esm.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction Mapper(param) {\n    let { latitude, longitude, setLatitude, setLongitude, mapRef } = param;\n    const viewPort = {\n        latitude: 48.86061984785351,\n        longitude: 2.337599080135306,\n        zoom: 1\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-72\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_map_gl__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            ref: mapRef,\n            mapboxAccessToken: _utils_mapboxToken__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n            mapStyle: \"mapbox://styles/mapbox/streets-v12?optimize=true\",\n            initialViewState: viewPort,\n            maxZoom: 20,\n            minZoom: 0,\n            onClick: (e)=>{\n                setLatitude(e.lngLat.lat);\n                setLongitude(e.lngLat.lng);\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_map_gl__WEBPACK_IMPORTED_MODULE_1__.GeolocateControl, {\n                    position: \"top-left\"\n                }, void 0, false, {\n                    fileName: \"/app/src/components/form/map.tsx\",\n                    lineNumber: 53,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_map_gl__WEBPACK_IMPORTED_MODULE_1__.NavigationControl, {\n                    position: \"top-left\"\n                }, void 0, false, {\n                    fileName: \"/app/src/components/form/map.tsx\",\n                    lineNumber: 54,\n                    columnNumber: 5\n                }, this),\n                latitude == null && longitude == null ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_map_gl__WEBPACK_IMPORTED_MODULE_1__.Marker, {\n                    latitude: latitude,\n                    longitude: longitude,\n                    anchor: \"bottom\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        src: \"/assets/marker-icon.png\",\n                        alt: \"marker\",\n                        width: 32,\n                        height: 32\n                    }, void 0, false, {\n                        fileName: \"/app/src/components/form/map.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 7\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/app/src/components/form/map.tsx\",\n                    lineNumber: 57,\n                    columnNumber: 6\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/app/src/components/form/map.tsx\",\n            lineNumber: 41,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"/app/src/components/form/map.tsx\",\n        lineNumber: 40,\n        columnNumber: 3\n    }, this);\n}\n_c = Mapper;\nfunction MapForm(param) {\n    let { latitude, longitude, setLatitude, setLongitude, page } = param;\n    _s();\n    const [address, setAddress] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const [change, setChange] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Field_Input_Label_headlessui_react__WEBPACK_IMPORTED_MODULE_5__.Field, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Field_Input_Label_headlessui_react__WEBPACK_IMPORTED_MODULE_5__.Label, {\n                className: \"text-lg text-center mb-2\",\n                children: page[\"map\"][\"title\"]\n            }, void 0, false, {\n                fileName: \"/app/src/components/form/map.tsx\",\n                lineNumber: 78,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mapbox_search_js_react__WEBPACK_IMPORTED_MODULE_3__.AddressAutofill, {\n                accessToken: _utils_mapboxToken__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n                browserAutofillEnabled: true,\n                onRetrieve: (res)=>{\n                    var _mapRef_current;\n                    setAddress(res.features[0].properties.place_name);\n                    setLongitude(res.features[0].geometry.coordinates[0]);\n                    setLatitude(res.features[0].geometry.coordinates[1]);\n                    (_mapRef_current = mapRef.current) === null || _mapRef_current === void 0 ? void 0 : _mapRef_current.flyTo({\n                        center: [\n                            res.features[0].geometry.coordinates[0],\n                            res.features[0].geometry.coordinates[1]\n                        ],\n                        zoom: 16\n                    });\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Field_Input_Label_headlessui_react__WEBPACK_IMPORTED_MODULE_5__.Input, {\n                    name: \"address\",\n                    type: \"text\",\n                    autoComplete: \"address-line1\",\n                    className: \"w-full rounded-md mb-2 py-3 px-6 text-base text-body-color placeholder-body-color shadow-one outline-none focus:border-primary focus-visible:shadow-none border\",\n                    value: address,\n                    onChange: (e)=>setAddress(e.target.value),\n                    maxLength: 2000,\n                    placeholder: page[\"map\"][\"placeholder\"]\n                }, void 0, false, {\n                    fileName: \"/app/src/components/form/map.tsx\",\n                    lineNumber: 98,\n                    columnNumber: 5\n                }, this)\n            }, void 0, false, {\n                fileName: \"/app/src/components/form/map.tsx\",\n                lineNumber: 81,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Mapper, {\n                latitude: latitude,\n                longitude: longitude,\n                setLatitude: setLatitude,\n                setLongitude: setLongitude,\n                mapRef: mapRef\n            }, void 0, false, {\n                fileName: \"/app/src/components/form/map.tsx\",\n                lineNumber: 109,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/src/components/form/map.tsx\",\n        lineNumber: 77,\n        columnNumber: 3\n    }, this);\n}\n_s(MapForm, \"KAn0A34ac0aRB4sFlByIxchnqyQ=\");\n_c1 = MapForm;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MapForm);\nvar _c, _c1;\n$RefreshReg$(_c, \"Mapper\");\n$RefreshReg$(_c1, \"MapForm\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9mb3JtL21hcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBa0Y7QUFFOUI7QUFDSztBQUVaO0FBR1c7QUFrQmpELFNBQVNXLE9BQU8sS0FJUjtRQUpRLEVBQ3JCQyxRQUFRLEVBQUVDLFNBQVMsRUFDbkJDLFdBQVcsRUFBRUMsWUFBWSxFQUN6QkMsTUFBTSxFQUNPLEdBSlE7SUFNdEIsTUFBTUMsV0FBVztRQUNoQkwsVUFBVTtRQUNWQyxXQUFXO1FBQ1hLLE1BQU07SUFDUDtJQUVHLHFCQUNGLDhEQUFDQztRQUFJQyxXQUFVO2tCQUNkLDRFQUFDcEIsb0RBQUtBO1lBQ0xxQixLQUFLTDtZQUNMTSxtQkFBbUJmLDBEQUFXQTtZQUM5QmdCLFVBQVM7WUFDVEMsa0JBQWtCUDtZQUNsQlEsU0FBUztZQUNUQyxTQUFTO1lBQ1RDLFNBQVMsQ0FBQ0M7Z0JBQ1RkLFlBQVljLEVBQUVDLE1BQU0sQ0FBQ0MsR0FBRztnQkFDeEJmLGFBQWFhLEVBQUVDLE1BQU0sQ0FBQ0UsR0FBRztZQUN6Qjs7OEJBRUQsOERBQUM3QiwwREFBZ0JBO29CQUFDOEIsVUFBUzs7Ozs7OzhCQUMzQiw4REFBQy9CLDJEQUFpQkE7b0JBQUMrQixVQUFTOzs7Ozs7Z0JBRTFCcEIsWUFBWSxRQUFRQyxhQUFhLHFCQUFRLDhKQUMxQyw4REFBQ1YsZ0RBQU1BO29CQUFDUyxVQUFVQTtvQkFBVUMsV0FBV0E7b0JBQVdvQixRQUFPOzhCQUN4RCw0RUFBQ0M7d0JBQ0FDLEtBQUk7d0JBQ0pDLEtBQUk7d0JBQ0pDLE9BQU87d0JBQ1BDLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPZjtLQTFDZ0IzQjtBQTRDaEIsU0FBUzRCLFFBQVEsS0FBaUU7UUFBakUsRUFBRTNCLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRXlCLElBQUksRUFBVyxHQUFqRTs7SUFDaEIsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUd0QywrQ0FBUUEsQ0FBUztJQUMvQyxNQUFNWSxTQUFTWCw2Q0FBTUEsQ0FBQztJQUN0QixNQUFNLENBQUNzQyxRQUFRQyxVQUFVLEdBQUd4QywrQ0FBUUEsQ0FBUztJQUU3QyxxQkFDQyw4REFBQ00sNEZBQUtBOzswQkFDTCw4REFBQ0YsNEZBQUtBO2dCQUFDWSxXQUFVOzBCQUNmb0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFROzs7Ozs7MEJBRXRCLDhEQUFDbEMsb0VBQWVBO2dCQUNmdUMsYUFBYXRDLDBEQUFXQTtnQkFDeEJ1Qyx3QkFBd0I7Z0JBQ3hCQyxZQUNDLENBQUNDO3dCQUlBaEM7b0JBSEEwQixXQUFXTSxJQUFJQyxRQUFRLENBQUMsRUFBRSxDQUFDQyxVQUFVLENBQUNDLFVBQVU7b0JBQ2hEcEMsYUFBYWlDLElBQUlDLFFBQVEsQ0FBQyxFQUFFLENBQUNHLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDLEVBQUU7b0JBQ3BEdkMsWUFBWWtDLElBQUlDLFFBQVEsQ0FBQyxFQUFFLENBQUNHLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDLEVBQUU7cUJBQ25EckMsa0JBQUFBLE9BQU9zQyxPQUFPLGNBQWR0QyxzQ0FBQUEsZ0JBQWdCdUMsS0FBSyxDQUFDO3dCQUNyQkMsUUFBUTs0QkFDTlIsSUFBSUMsUUFBUSxDQUFDLEVBQUUsQ0FBQ0csUUFBUSxDQUFDQyxXQUFXLENBQUMsRUFBRTs0QkFDdkNMLElBQUlDLFFBQVEsQ0FBQyxFQUFFLENBQUNHLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDLEVBQUU7eUJBQ3RDO3dCQUNIbkMsTUFBTTtvQkFDUDtnQkFDRDswQkFFRCw0RUFBQ1QsNEZBQUtBO29CQUNKZ0QsTUFBSztvQkFDTEMsTUFBSztvQkFDTEMsY0FBYTtvQkFDYnZDLFdBQVU7b0JBQ1Z3QyxPQUFPbkI7b0JBQ1BvQixVQUFVLENBQUNqQyxJQUFNYyxXQUFXZCxFQUFFa0MsTUFBTSxDQUFDRixLQUFLO29CQUMxQ0csV0FBVztvQkFDWEMsYUFBYXhCLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYzs7Ozs7Ozs7Ozs7MEJBRzFDLDhEQUFDN0I7Z0JBQ0FDLFVBQVVBO2dCQUNWQyxXQUFXQTtnQkFDWEMsYUFBYUE7Z0JBQ2JDLGNBQWNBO2dCQUNkQyxRQUFRQTs7Ozs7Ozs7Ozs7O0FBSVo7R0EvQ1N1QjtNQUFBQTtBQWdEVCwrREFBZUEsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9mb3JtL21hcC50c3g/NmMwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFwR2wsIHsgTmF2aWdhdGlvbkNvbnRyb2wsIEdlb2xvY2F0ZUNvbnRyb2wsIE1hcmtlciB9IGZyb20gXCJyZWFjdC1tYXAtZ2xcIjtcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFkZHJlc3NBdXRvZmlsbCB9IGZyb20gJ0BtYXBib3gvc2VhcmNoLWpzLXJlYWN0J1xuXG5pbXBvcnQgbWFwYm94VG9rZW4gZnJvbSAnQHV0aWxzL21hcGJveFRva2VuJztcblxuaW1wb3J0IHR5cGUgeyBNYXBSZWYgfSBmcm9tICdyZWFjdC1tYXAtZ2wnO1xuaW1wb3J0IHsgTGFiZWwsIElucHV0LCBGaWVsZCB9IGZyb20gJ0BoZWFkbGVzc3VpL3JlYWN0JztcblxudHlwZSBNYXBUeXBlID0ge1xuXHRsYXRpdHVkZTogbnVtYmVyIHwgbnVsbDtcblx0bG9uZ2l0dWRlOiBudW1iZXIgfCBudWxsO1xuXHRzZXRMYXRpdHVkZTogKGU6IG51bWJlcikgPT4gdm9pZDtcblx0c2V0TG9uZ2l0dWRlOiAoZTogbnVtYmVyKSA9PiB2b2lkO1xuXHRwYWdlOiBhbnk7XG59XG5cbnR5cGUgTWFwcGVyVHlwZSA9IHtcblx0bGF0aXR1ZGU6IG51bWJlciB8IG51bGw7XG5cdGxvbmdpdHVkZTogbnVtYmVyIHwgbnVsbDtcblx0c2V0TGF0aXR1ZGU6IChlOiBudW1iZXIpID0+IHZvaWQ7XG5cdHNldExvbmdpdHVkZTogKGU6IG51bWJlcikgPT4gdm9pZDtcblx0bWFwUmVmOiBhbnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBNYXBwZXIoe1xuXHRcdGxhdGl0dWRlLCBsb25naXR1ZGUsXG5cdFx0c2V0TGF0aXR1ZGUsIHNldExvbmdpdHVkZSxcblx0XHRtYXBSZWZcblx0fSA6IE1hcHBlclR5cGUpIHtcblxuXHRjb25zdCB2aWV3UG9ydCA9IHtcblx0XHRsYXRpdHVkZTogNDguODYwNjE5ODQ3ODUzNTEsXG5cdFx0bG9uZ2l0dWRlOiAyLjMzNzU5OTA4MDEzNTMwNixcblx0XHR6b29tOiAxXG5cdH1cblx0XG4gICAgcmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cImgtNzJcIj5cblx0XHRcdDxNYXBHbFxuXHRcdFx0XHRyZWY9e21hcFJlZn1cblx0XHRcdFx0bWFwYm94QWNjZXNzVG9rZW49e21hcGJveFRva2VufVxuXHRcdFx0XHRtYXBTdHlsZT1cIm1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12MTI/b3B0aW1pemU9dHJ1ZVwiXG5cdFx0XHRcdGluaXRpYWxWaWV3U3RhdGU9e3ZpZXdQb3J0fVxuXHRcdFx0XHRtYXhab29tPXsyMH1cblx0XHRcdFx0bWluWm9vbT17MH1cblx0XHRcdFx0b25DbGljaz17KGUpID0+IHtcblx0XHRcdFx0XHRzZXRMYXRpdHVkZShlLmxuZ0xhdC5sYXQpO1xuXHRcdFx0XHRcdHNldExvbmdpdHVkZShlLmxuZ0xhdC5sbmcpO1xuXHRcdFx0XHRcdH19XG5cdFx0XHQ+XG5cdFx0XHRcdDxHZW9sb2NhdGVDb250cm9sIHBvc2l0aW9uPVwidG9wLWxlZnRcIiAvPlxuXHRcdFx0XHQ8TmF2aWdhdGlvbkNvbnRyb2wgcG9zaXRpb249XCJ0b3AtbGVmdFwiIC8+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHQobGF0aXR1ZGUgPT0gbnVsbCAmJiBsb25naXR1ZGUgPT0gbnVsbCkgPyA8PjwvPiA6IFxuXHRcdFx0XHRcdDxNYXJrZXIgbGF0aXR1ZGU9e2xhdGl0dWRlfSBsb25naXR1ZGU9e2xvbmdpdHVkZX0gYW5jaG9yPVwiYm90dG9tXCI+XG5cdFx0XHRcdFx0XHQ8aW1nXG5cdFx0XHRcdFx0XHRcdHNyYz1cIi9hc3NldHMvbWFya2VyLWljb24ucG5nXCJcblx0XHRcdFx0XHRcdFx0YWx0PVwibWFya2VyXCJcblx0XHRcdFx0XHRcdFx0d2lkdGg9ezMyfVxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ9ezMyfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvTWFya2VyPlxuXHRcdFx0XHR9XG5cdFx0XHQ8L01hcEdsPlxuXHRcdDwvZGl2PlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIE1hcEZvcm0oeyBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzZXRMYXRpdHVkZSwgc2V0TG9uZ2l0dWRlLCBwYWdlIH06IE1hcFR5cGUpIHtcblx0Y29uc3QgW2FkZHJlc3MsIHNldEFkZHJlc3NdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcblx0Y29uc3QgbWFwUmVmID0gdXNlUmVmKG51bGwpO1xuXHRjb25zdCBbY2hhbmdlLCBzZXRDaGFuZ2VdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcblxuXHRyZXR1cm4gKFxuXHRcdDxGaWVsZD5cblx0XHRcdDxMYWJlbCBjbGFzc05hbWU9XCJ0ZXh0LWxnIHRleHQtY2VudGVyIG1iLTJcIj5cblx0XHRcdFx0e3BhZ2VbJ21hcCddWyd0aXRsZSddfVxuXHRcdFx0PC9MYWJlbD5cblx0XHRcdDxBZGRyZXNzQXV0b2ZpbGxcblx0XHRcdFx0YWNjZXNzVG9rZW49e21hcGJveFRva2VufVxuXHRcdFx0XHRicm93c2VyQXV0b2ZpbGxFbmFibGVkPXt0cnVlfVxuXHRcdFx0XHRvblJldHJpZXZlPXtcblx0XHRcdFx0XHQocmVzKSA9PiB7XG5cdFx0XHRcdFx0XHRzZXRBZGRyZXNzKHJlcy5mZWF0dXJlc1swXS5wcm9wZXJ0aWVzLnBsYWNlX25hbWUpO1xuXHRcdFx0XHRcdFx0c2V0TG9uZ2l0dWRlKHJlcy5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSk7XG5cdFx0XHRcdFx0XHRzZXRMYXRpdHVkZShyZXMuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0pO1xuXHRcdFx0XHRcdFx0bWFwUmVmLmN1cnJlbnQ/LmZseVRvKHtcblx0XHRcdFx0XHRcdFx0Y2VudGVyOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1cblx0XHRcdFx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRcdHpvb206IDE2XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH19XG5cdFx0XHQ+XG5cdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0bmFtZT1cImFkZHJlc3NcIlxuXHRcdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdFx0YXV0b0NvbXBsZXRlPVwiYWRkcmVzcy1saW5lMVwiXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJ3LWZ1bGwgcm91bmRlZC1tZCBtYi0yIHB5LTMgcHgtNiB0ZXh0LWJhc2UgdGV4dC1ib2R5LWNvbG9yIHBsYWNlaG9sZGVyLWJvZHktY29sb3Igc2hhZG93LW9uZSBvdXRsaW5lLW5vbmUgZm9jdXM6Ym9yZGVyLXByaW1hcnkgZm9jdXMtdmlzaWJsZTpzaGFkb3ctbm9uZSBib3JkZXJcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e2FkZHJlc3N9XG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17KGUpID0+IHNldEFkZHJlc3MoZS50YXJnZXQudmFsdWUpfVxuXHRcdFx0XHRcdFx0bWF4TGVuZ3RoPXsyMDAwfVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9e3BhZ2VbJ21hcCddWydwbGFjZWhvbGRlciddfVxuXHRcdFx0XHQvPlxuXHRcdFx0PC9BZGRyZXNzQXV0b2ZpbGw+XG5cdFx0XHQ8TWFwcGVyXG5cdFx0XHRcdGxhdGl0dWRlPXtsYXRpdHVkZX1cblx0XHRcdFx0bG9uZ2l0dWRlPXtsb25naXR1ZGV9XG5cdFx0XHRcdHNldExhdGl0dWRlPXtzZXRMYXRpdHVkZX1cblx0XHRcdFx0c2V0TG9uZ2l0dWRlPXtzZXRMb25naXR1ZGV9XG5cdFx0XHRcdG1hcFJlZj17bWFwUmVmfVxuXHRcdFx0Lz5cblx0XHQ8L0ZpZWxkPlxuXHQpXG59XG5leHBvcnQgZGVmYXVsdCBNYXBGb3JtO1xuIl0sIm5hbWVzIjpbIk1hcEdsIiwiTmF2aWdhdGlvbkNvbnRyb2wiLCJHZW9sb2NhdGVDb250cm9sIiwiTWFya2VyIiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJBZGRyZXNzQXV0b2ZpbGwiLCJtYXBib3hUb2tlbiIsIkxhYmVsIiwiSW5wdXQiLCJGaWVsZCIsIk1hcHBlciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwic2V0TGF0aXR1ZGUiLCJzZXRMb25naXR1ZGUiLCJtYXBSZWYiLCJ2aWV3UG9ydCIsInpvb20iLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiLCJtYXBib3hBY2Nlc3NUb2tlbiIsIm1hcFN0eWxlIiwiaW5pdGlhbFZpZXdTdGF0ZSIsIm1heFpvb20iLCJtaW5ab29tIiwib25DbGljayIsImUiLCJsbmdMYXQiLCJsYXQiLCJsbmciLCJwb3NpdGlvbiIsImFuY2hvciIsImltZyIsInNyYyIsImFsdCIsIndpZHRoIiwiaGVpZ2h0IiwiTWFwRm9ybSIsInBhZ2UiLCJhZGRyZXNzIiwic2V0QWRkcmVzcyIsImNoYW5nZSIsInNldENoYW5nZSIsImFjY2Vzc1Rva2VuIiwiYnJvd3NlckF1dG9maWxsRW5hYmxlZCIsIm9uUmV0cmlldmUiLCJyZXMiLCJmZWF0dXJlcyIsInByb3BlcnRpZXMiLCJwbGFjZV9uYW1lIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImN1cnJlbnQiLCJmbHlUbyIsImNlbnRlciIsIm5hbWUiLCJ0eXBlIiwiYXV0b0NvbXBsZXRlIiwidmFsdWUiLCJvbkNoYW5nZSIsInRhcmdldCIsIm1heExlbmd0aCIsInBsYWNlaG9sZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/form/map.tsx\n"));

/***/ }),

/***/ "./src/utils/mapboxToken.ts":
/*!**********************************!*\
  !*** ./src/utils/mapboxToken.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst mapboxToken =  true ? \"pk.eyJ1IjoiYmxhYmxhY2FyMmxlcmV0b3VyIiwiYSI6ImNsd3o1eTlpdDAzZHkya3JhcWlxcTI3eDEifQ.JcI1QpYODrbKBbTU7yZdlQ\" : 0;\n/* harmony default export */ __webpack_exports__[\"default\"] = (mapboxToken);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvbWFwYm94VG9rZW4udHMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLGNBQXVCLEtBQTZDSSxHQUFJSCwwR0FBK0IsR0FBRyxDQUFFO0FBQ2xILCtEQUFlRCxXQUFXQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9tYXBib3hUb2tlbi50cz9jM2RlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG1hcGJveFRva2VuIDogc3RyaW5nID0gKHByb2Nlc3MuZW52Lk1BUEJPWF9BQ0NFU1NfVE9LRU4gIT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk1BUEJPWF9BQ0NFU1NfVE9LRU4gOiBcIlwiO1xuZXhwb3J0IGRlZmF1bHQgbWFwYm94VG9rZW47XG4iXSwibmFtZXMiOlsibWFwYm94VG9rZW4iLCJwcm9jZXNzIiwiZW52IiwiTUFQQk9YX0FDQ0VTU19UT0tFTiIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/mapboxToken.ts\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/no-scroll/index.js":
/*!*****************************************!*\
  !*** ./node_modules/no-scroll/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function(root) {\n  var isOn = false;\n  var scrollbarSize;\n  var scrollTop;\n\n  function getScrollbarSize() {\n    if (typeof scrollbarSize !== 'undefined') return scrollbarSize;\n\n    var doc = document.documentElement;\n    var dummyScroller = document.createElement('div');\n    dummyScroller.setAttribute('style', 'width:99px;height:99px;' + 'position:absolute;top:-9999px;overflow:scroll;');\n    doc.appendChild(dummyScroller);\n    scrollbarSize = dummyScroller.offsetWidth - dummyScroller.clientWidth;\n    doc.removeChild(dummyScroller);\n    return scrollbarSize;\n  }\n\n  function hasScrollbar() {\n    return document.documentElement.scrollHeight > window.innerHeight;\n  }\n\n  function on(options) {\n    if (typeof document === 'undefined' || isOn) return;\n    var doc = document.documentElement;\n    scrollTop = window.pageYOffset;\n    if (hasScrollbar()) {\n      doc.style.width = 'calc(100% - '+ getScrollbarSize() +'px)';\n    } else {\n      doc.style.width = '100%';\n    }\n    doc.style.position = 'fixed';\n    doc.style.top = -scrollTop + 'px';\n    doc.style.overflow = 'hidden';\n    isOn = true;\n  }\n\n  function off() {\n    if (typeof document === 'undefined' || !isOn) return;\n    var doc = document.documentElement;\n    doc.style.width = '';\n    doc.style.position = '';\n    doc.style.top = '';\n    doc.style.overflow = '';\n    window.scroll(0, scrollTop);\n    isOn = false;\n  }\n\n  function toggle() {\n    if (isOn) {\n      off();\n      return;\n    }\n    on();\n  }\n\n  var noScroll = {\n    on: on,\n    off: off,\n    toggle: toggle,\n  };\n\n  if ( true && typeof module.exports !== 'undefined') {\n    module.exports = noScroll;\n  } else {\n    root.noScroll = noScroll;\n  }\n})(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm8tc2Nyb2xsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxZQUFZLHVCQUF1QixZQUFZLGdCQUFnQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQTZCO0FBQ25DO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uby1zY3JvbGwvaW5kZXguanM/YmFmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24ocm9vdCkge1xuICB2YXIgaXNPbiA9IGZhbHNlO1xuICB2YXIgc2Nyb2xsYmFyU2l6ZTtcbiAgdmFyIHNjcm9sbFRvcDtcblxuICBmdW5jdGlvbiBnZXRTY3JvbGxiYXJTaXplKCkge1xuICAgIGlmICh0eXBlb2Ygc2Nyb2xsYmFyU2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBzY3JvbGxiYXJTaXplO1xuXG4gICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZHVtbXlTY3JvbGxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGR1bW15U2Nyb2xsZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICd3aWR0aDo5OXB4O2hlaWdodDo5OXB4OycgKyAncG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTk5cHg7b3ZlcmZsb3c6c2Nyb2xsOycpO1xuICAgIGRvYy5hcHBlbmRDaGlsZChkdW1teVNjcm9sbGVyKTtcbiAgICBzY3JvbGxiYXJTaXplID0gZHVtbXlTY3JvbGxlci5vZmZzZXRXaWR0aCAtIGR1bW15U2Nyb2xsZXIuY2xpZW50V2lkdGg7XG4gICAgZG9jLnJlbW92ZUNoaWxkKGR1bW15U2Nyb2xsZXIpO1xuICAgIHJldHVybiBzY3JvbGxiYXJTaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzU2Nyb2xsYmFyKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gb24ob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IGlzT24pIHJldHVybjtcbiAgICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBpZiAoaGFzU2Nyb2xsYmFyKCkpIHtcbiAgICAgIGRvYy5zdHlsZS53aWR0aCA9ICdjYWxjKDEwMCUgLSAnKyBnZXRTY3JvbGxiYXJTaXplKCkgKydweCknO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2Muc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgfVxuICAgIGRvYy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgZG9jLnN0eWxlLnRvcCA9IC1zY3JvbGxUb3AgKyAncHgnO1xuICAgIGRvYy5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIGlzT24gPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb2ZmKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICFpc09uKSByZXR1cm47XG4gICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBkb2Muc3R5bGUud2lkdGggPSAnJztcbiAgICBkb2Muc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICBkb2Muc3R5bGUudG9wID0gJyc7XG4gICAgZG9jLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgd2luZG93LnNjcm9sbCgwLCBzY3JvbGxUb3ApO1xuICAgIGlzT24gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICBpZiAoaXNPbikge1xuICAgICAgb2ZmKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uKCk7XG4gIH1cblxuICB2YXIgbm9TY3JvbGwgPSB7XG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIHRvZ2dsZTogdG9nZ2xlLFxuICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBub1Njcm9sbDtcbiAgfSBlbHNlIHtcbiAgICByb290Lm5vU2Nyb2xsID0gbm9TY3JvbGw7XG4gIH1cbn0pKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/no-scroll/index.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/attribution-control.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/attribution-control.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/apply-react-style */ \"./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\");\n/* harmony import */ var _use_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-control */ \"./node_modules/react-map-gl/dist/esm/components/use-control.js\");\n\n\n\nfunction AttributionControl(props) {\n    const ctrl = (0,_use_control__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(({ mapLib }) => new mapLib.AttributionControl(props), {\n        position: props.position\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (0,_utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__.applyReactStyle)(ctrl._container, props.style);\n    }, [props.style]);\n    return null;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(AttributionControl));\n//# sourceMappingURL=attribution-control.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYXR0cmlidXRpb24tY29udHJvbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUNxQjtBQUN0QjtBQUN2QztBQUNBLGlCQUFpQix3REFBVSxJQUFJLFFBQVE7QUFDdkM7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiLFFBQVEseUVBQWU7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQSwrREFBZSwyQ0FBSSxvQkFBb0IsRUFBQztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYXR0cmlidXRpb24tY29udHJvbC5qcz8wZWI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgbWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGFwcGx5UmVhY3RTdHlsZSB9IGZyb20gJy4uL3V0aWxzL2FwcGx5LXJlYWN0LXN0eWxlJztcbmltcG9ydCB1c2VDb250cm9sIGZyb20gJy4vdXNlLWNvbnRyb2wnO1xuZnVuY3Rpb24gQXR0cmlidXRpb25Db250cm9sKHByb3BzKSB7XG4gICAgY29uc3QgY3RybCA9IHVzZUNvbnRyb2woKHsgbWFwTGliIH0pID0+IG5ldyBtYXBMaWIuQXR0cmlidXRpb25Db250cm9sKHByb3BzKSwge1xuICAgICAgICBwb3NpdGlvbjogcHJvcHMucG9zaXRpb25cbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBhcHBseVJlYWN0U3R5bGUoY3RybC5fY29udGFpbmVyLCBwcm9wcy5zdHlsZSk7XG4gICAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZGVmYXVsdCBtZW1vKEF0dHJpYnV0aW9uQ29udHJvbCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGlvbi1jb250cm9sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/attribution-control.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/apply-react-style */ \"./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\");\n/* harmony import */ var _use_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-control */ \"./node_modules/react-map-gl/dist/esm/components/use-control.js\");\n\n\n\nfunction FullscreenControl(props) {\n    const ctrl = (0,_use_control__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(({ mapLib }) => new mapLib.FullscreenControl({\n        container: props.containerId && document.getElementById(props.containerId)\n    }), { position: props.position });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (0,_utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__.applyReactStyle)(ctrl._controlContainer, props.style);\n    }, [props.style]);\n    return null;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(FullscreenControl));\n//# sourceMappingURL=fullscreen-control.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvZnVsbHNjcmVlbi1jb250cm9sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ3FCO0FBQ3RCO0FBQ3ZDO0FBQ0EsaUJBQWlCLHdEQUFVLElBQUksUUFBUTtBQUN2QztBQUNBLEtBQUssS0FBSywwQkFBMEI7QUFDcEMsSUFBSSxnREFBUztBQUNiLFFBQVEseUVBQWU7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQSwrREFBZSwyQ0FBSSxtQkFBbUIsRUFBQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvZnVsbHNjcmVlbi1jb250cm9sLmpzPzFkMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXBwbHlSZWFjdFN0eWxlIH0gZnJvbSAnLi4vdXRpbHMvYXBwbHktcmVhY3Qtc3R5bGUnO1xuaW1wb3J0IHVzZUNvbnRyb2wgZnJvbSAnLi91c2UtY29udHJvbCc7XG5mdW5jdGlvbiBGdWxsc2NyZWVuQ29udHJvbChwcm9wcykge1xuICAgIGNvbnN0IGN0cmwgPSB1c2VDb250cm9sKCh7IG1hcExpYiB9KSA9PiBuZXcgbWFwTGliLkZ1bGxzY3JlZW5Db250cm9sKHtcbiAgICAgICAgY29udGFpbmVyOiBwcm9wcy5jb250YWluZXJJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcm9wcy5jb250YWluZXJJZClcbiAgICB9KSwgeyBwb3NpdGlvbjogcHJvcHMucG9zaXRpb24gfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgYXBwbHlSZWFjdFN0eWxlKGN0cmwuX2NvbnRyb2xDb250YWluZXIsIHByb3BzLnN0eWxlKTtcbiAgICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBkZWZhdWx0IG1lbW8oRnVsbHNjcmVlbkNvbnRyb2wpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVsbHNjcmVlbi1jb250cm9sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/geolocate-control.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/geolocate-control.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/apply-react-style */ \"./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\");\n/* harmony import */ var _use_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-control */ \"./node_modules/react-map-gl/dist/esm/components/use-control.js\");\n\n\n\nfunction GeolocateControl(props, ref) {\n    const thisRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ props });\n    const ctrl = (0,_use_control__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(({ mapLib }) => {\n        const gc = new mapLib.GeolocateControl(props);\n        // Hack: fix GeolocateControl reuse\n        // When using React strict mode, the component is mounted twice.\n        // GeolocateControl's UI creation is asynchronous. Removing and adding it back causes the UI to be initialized twice.\n        // @ts-expect-error private method\n        const setupUI = gc._setupUI;\n        // @ts-expect-error private method\n        gc._setupUI = args => {\n            if (!gc._container.hasChildNodes()) {\n                setupUI(args);\n            }\n        };\n        gc.on('geolocate', e => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onGeolocate) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        });\n        gc.on('error', e => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onError) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        });\n        gc.on('outofmaxbounds', e => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onOutOfMaxBounds) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        });\n        gc.on('trackuserlocationstart', e => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onTrackUserLocationStart) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        });\n        gc.on('trackuserlocationend', e => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onTrackUserLocationEnd) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        });\n        return gc;\n    }, { position: props.position });\n    thisRef.current.props = props;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ctrl, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (0,_utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__.applyReactStyle)(ctrl._container, props.style);\n    }, [props.style]);\n    return null;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(GeolocateControl)));\n//# sourceMappingURL=geolocate-control.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvZ2VvbG9jYXRlLWNvbnRyb2wuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUY7QUFDcEI7QUFDdEI7QUFDdkM7QUFDQSxvQkFBb0IsNkNBQU0sR0FBRyxPQUFPO0FBQ3BDLGlCQUFpQix3REFBVSxJQUFJLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUssSUFBSSwwQkFBMEI7QUFDbkM7QUFDQSxJQUFJLDBEQUFtQjtBQUN2QixJQUFJLGdEQUFTO0FBQ2IsUUFBUSx5RUFBZTtBQUN2QixLQUFLO0FBQ0w7QUFDQTtBQUNBLCtEQUFlLDJDQUFJLENBQUMsaURBQVUsbUJBQW1CLEVBQUM7QUFDbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2dlb2xvY2F0ZS1jb250cm9sLmpzPzIxMWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmLCB1c2VFZmZlY3QsIGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhcHBseVJlYWN0U3R5bGUgfSBmcm9tICcuLi91dGlscy9hcHBseS1yZWFjdC1zdHlsZSc7XG5pbXBvcnQgdXNlQ29udHJvbCBmcm9tICcuL3VzZS1jb250cm9sJztcbmZ1bmN0aW9uIEdlb2xvY2F0ZUNvbnRyb2wocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHRoaXNSZWYgPSB1c2VSZWYoeyBwcm9wcyB9KTtcbiAgICBjb25zdCBjdHJsID0gdXNlQ29udHJvbCgoeyBtYXBMaWIgfSkgPT4ge1xuICAgICAgICBjb25zdCBnYyA9IG5ldyBtYXBMaWIuR2VvbG9jYXRlQ29udHJvbChwcm9wcyk7XG4gICAgICAgIC8vIEhhY2s6IGZpeCBHZW9sb2NhdGVDb250cm9sIHJldXNlXG4gICAgICAgIC8vIFdoZW4gdXNpbmcgUmVhY3Qgc3RyaWN0IG1vZGUsIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0d2ljZS5cbiAgICAgICAgLy8gR2VvbG9jYXRlQ29udHJvbCdzIFVJIGNyZWF0aW9uIGlzIGFzeW5jaHJvbm91cy4gUmVtb3ZpbmcgYW5kIGFkZGluZyBpdCBiYWNrIGNhdXNlcyB0aGUgVUkgdG8gYmUgaW5pdGlhbGl6ZWQgdHdpY2UuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcHJpdmF0ZSBtZXRob2RcbiAgICAgICAgY29uc3Qgc2V0dXBVSSA9IGdjLl9zZXR1cFVJO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHByaXZhdGUgbWV0aG9kXG4gICAgICAgIGdjLl9zZXR1cFVJID0gYXJncyA9PiB7XG4gICAgICAgICAgICBpZiAoIWdjLl9jb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgc2V0dXBVSShhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZ2Mub24oJ2dlb2xvY2F0ZScsIGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXNSZWYuY3VycmVudC5wcm9wcykub25HZW9sb2NhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdjLm9uKCdlcnJvcicsIGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXNSZWYuY3VycmVudC5wcm9wcykub25FcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2Mub24oJ291dG9mbWF4Ym91bmRzJywgZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpc1JlZi5jdXJyZW50LnByb3BzKS5vbk91dE9mTWF4Qm91bmRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnYy5vbigndHJhY2t1c2VybG9jYXRpb25zdGFydCcsIGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXNSZWYuY3VycmVudC5wcm9wcykub25UcmFja1VzZXJMb2NhdGlvblN0YXJ0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnYy5vbigndHJhY2t1c2VybG9jYXRpb25lbmQnLCBlID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzUmVmLmN1cnJlbnQucHJvcHMpLm9uVHJhY2tVc2VyTG9jYXRpb25FbmQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnYztcbiAgICB9LCB7IHBvc2l0aW9uOiBwcm9wcy5wb3NpdGlvbiB9KTtcbiAgICB0aGlzUmVmLmN1cnJlbnQucHJvcHMgPSBwcm9wcztcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gY3RybCwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFwcGx5UmVhY3RTdHlsZShjdHJsLl9jb250YWluZXIsIHByb3BzLnN0eWxlKTtcbiAgICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBkZWZhdWx0IG1lbW8oZm9yd2FyZFJlZihHZW9sb2NhdGVDb250cm9sKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW9sb2NhdGUtY29udHJvbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/geolocate-control.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/layer.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/layer.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"./node_modules/react-map-gl/dist/esm/components/map.js\");\n/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ \"./node_modules/react-map-gl/dist/esm/utils/assert.js\");\n/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/deep-equal */ \"./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\");\n\n\n\n\n/* eslint-disable complexity, max-statements */\nfunction updateLayer(map, id, props, prevProps) {\n    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(props.id === prevProps.id, 'layer id changed');\n    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(props.type === prevProps.type, 'layer type changed');\n    if (props.type === 'custom' || prevProps.type === 'custom') {\n        return;\n    }\n    const { layout = {}, paint = {}, filter, minzoom, maxzoom, beforeId } = props;\n    if (beforeId !== prevProps.beforeId) {\n        map.moveLayer(id, beforeId);\n    }\n    if (layout !== prevProps.layout) {\n        const prevLayout = prevProps.layout || {};\n        for (const key in layout) {\n            if (!(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(layout[key], prevLayout[key])) {\n                map.setLayoutProperty(id, key, layout[key]);\n            }\n        }\n        for (const key in prevLayout) {\n            if (!layout.hasOwnProperty(key)) {\n                map.setLayoutProperty(id, key, undefined);\n            }\n        }\n    }\n    if (paint !== prevProps.paint) {\n        const prevPaint = prevProps.paint || {};\n        for (const key in paint) {\n            if (!(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(paint[key], prevPaint[key])) {\n                map.setPaintProperty(id, key, paint[key]);\n            }\n        }\n        for (const key in prevPaint) {\n            if (!paint.hasOwnProperty(key)) {\n                map.setPaintProperty(id, key, undefined);\n            }\n        }\n    }\n    if (!(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(filter, prevProps.filter)) {\n        map.setFilter(id, filter);\n    }\n    if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {\n        map.setLayerZoomRange(id, minzoom, maxzoom);\n    }\n}\nfunction createLayer(map, id, props) {\n    // @ts-ignore\n    if (map.style && map.style._loaded && (!('source' in props) || map.getSource(props.source))) {\n        const options = { ...props, id };\n        delete options.beforeId;\n        // @ts-ignore\n        map.addLayer(options, props.beforeId);\n    }\n}\n/* eslint-enable complexity, max-statements */\nlet layerCounter = 0;\nfunction Layer(props) {\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_map__WEBPACK_IMPORTED_MODULE_1__.MapContext).map.getMap();\n    const propsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props);\n    const [, setStyleLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => props.id || `jsx-layer-${layerCounter++}`, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (map) {\n            const forceUpdate = () => setStyleLoaded(version => version + 1);\n            map.on('styledata', forceUpdate);\n            forceUpdate();\n            return () => {\n                map.off('styledata', forceUpdate);\n                // @ts-ignore\n                if (map.style && map.style._loaded && map.getLayer(id)) {\n                    map.removeLayer(id);\n                }\n            };\n        }\n        return undefined;\n    }, [map]);\n    // @ts-ignore\n    const layer = map && map.style && map.getLayer(id);\n    if (layer) {\n        try {\n            updateLayer(map, id, props, propsRef.current);\n        }\n        catch (error) {\n            console.warn(error); // eslint-disable-line\n        }\n    }\n    else {\n        createLayer(map, id, props);\n    }\n    // Store last rendered props\n    propsRef.current = props;\n    return null;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Layer);\n//# sourceMappingURL=layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbGF5ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlFO0FBQ3RDO0FBQ0U7QUFDVztBQUNoRDtBQUNBO0FBQ0EsSUFBSSx5REFBTTtBQUNWLElBQUkseURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsWUFBWSx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDREQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFVLENBQUMsNENBQVU7QUFDckMscUJBQXFCLDZDQUFNO0FBQzNCLCtCQUErQiwrQ0FBUTtBQUN2QyxlQUFlLDhDQUFPLGdDQUFnQyxlQUFlO0FBQ3JFLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxLQUFLLEVBQUM7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2xheWVyLmpzPzZhOGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTWFwQ29udGV4dCB9IGZyb20gJy4vbWFwJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gJy4uL3V0aWxzL2RlZXAtZXF1YWwnO1xuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbmZ1bmN0aW9uIHVwZGF0ZUxheWVyKG1hcCwgaWQsIHByb3BzLCBwcmV2UHJvcHMpIHtcbiAgICBhc3NlcnQocHJvcHMuaWQgPT09IHByZXZQcm9wcy5pZCwgJ2xheWVyIGlkIGNoYW5nZWQnKTtcbiAgICBhc3NlcnQocHJvcHMudHlwZSA9PT0gcHJldlByb3BzLnR5cGUsICdsYXllciB0eXBlIGNoYW5nZWQnKTtcbiAgICBpZiAocHJvcHMudHlwZSA9PT0gJ2N1c3RvbScgfHwgcHJldlByb3BzLnR5cGUgPT09ICdjdXN0b20nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBsYXlvdXQgPSB7fSwgcGFpbnQgPSB7fSwgZmlsdGVyLCBtaW56b29tLCBtYXh6b29tLCBiZWZvcmVJZCB9ID0gcHJvcHM7XG4gICAgaWYgKGJlZm9yZUlkICE9PSBwcmV2UHJvcHMuYmVmb3JlSWQpIHtcbiAgICAgICAgbWFwLm1vdmVMYXllcihpZCwgYmVmb3JlSWQpO1xuICAgIH1cbiAgICBpZiAobGF5b3V0ICE9PSBwcmV2UHJvcHMubGF5b3V0KSB7XG4gICAgICAgIGNvbnN0IHByZXZMYXlvdXQgPSBwcmV2UHJvcHMubGF5b3V0IHx8IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGxheW91dFtrZXldLCBwcmV2TGF5b3V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGlkLCBrZXksIGxheW91dFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2TGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAoIWxheW91dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGlkLCBrZXksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhaW50ICE9PSBwcmV2UHJvcHMucGFpbnQpIHtcbiAgICAgICAgY29uc3QgcHJldlBhaW50ID0gcHJldlByb3BzLnBhaW50IHx8IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYWludCkge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwocGFpbnRba2V5XSwgcHJldlBhaW50W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldFBhaW50UHJvcGVydHkoaWQsIGtleSwgcGFpbnRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldlBhaW50KSB7XG4gICAgICAgICAgICBpZiAoIXBhaW50Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0UGFpbnRQcm9wZXJ0eShpZCwga2V5LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZGVlcEVxdWFsKGZpbHRlciwgcHJldlByb3BzLmZpbHRlcikpIHtcbiAgICAgICAgbWFwLnNldEZpbHRlcihpZCwgZmlsdGVyKTtcbiAgICB9XG4gICAgaWYgKG1pbnpvb20gIT09IHByZXZQcm9wcy5taW56b29tIHx8IG1heHpvb20gIT09IHByZXZQcm9wcy5tYXh6b29tKSB7XG4gICAgICAgIG1hcC5zZXRMYXllclpvb21SYW5nZShpZCwgbWluem9vbSwgbWF4em9vbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTGF5ZXIobWFwLCBpZCwgcHJvcHMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCAmJiAoISgnc291cmNlJyBpbiBwcm9wcykgfHwgbWFwLmdldFNvdXJjZShwcm9wcy5zb3VyY2UpKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0geyAuLi5wcm9wcywgaWQgfTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuYmVmb3JlSWQ7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbWFwLmFkZExheWVyKG9wdGlvbnMsIHByb3BzLmJlZm9yZUlkKTtcbiAgICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5sZXQgbGF5ZXJDb3VudGVyID0gMDtcbmZ1bmN0aW9uIExheWVyKHByb3BzKSB7XG4gICAgY29uc3QgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KS5tYXAuZ2V0TWFwKCk7XG4gICAgY29uc3QgcHJvcHNSZWYgPSB1c2VSZWYocHJvcHMpO1xuICAgIGNvbnN0IFssIHNldFN0eWxlTG9hZGVkXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBwcm9wcy5pZCB8fCBganN4LWxheWVyLSR7bGF5ZXJDb3VudGVyKyt9YCwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKCkgPT4gc2V0U3R5bGVMb2FkZWQodmVyc2lvbiA9PiB2ZXJzaW9uICsgMSk7XG4gICAgICAgICAgICBtYXAub24oJ3N0eWxlZGF0YScsIGZvcmNlVXBkYXRlKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1hcC5vZmYoJ3N0eWxlZGF0YScsIGZvcmNlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCAmJiBtYXAuZ2V0TGF5ZXIoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sIFttYXBdKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbGF5ZXIgPSBtYXAgJiYgbWFwLnN0eWxlICYmIG1hcC5nZXRMYXllcihpZCk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cGRhdGVMYXllcihtYXAsIGlkLCBwcm9wcywgcHJvcHNSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNyZWF0ZUxheWVyKG1hcCwgaWQsIHByb3BzKTtcbiAgICB9XG4gICAgLy8gU3RvcmUgbGFzdCByZW5kZXJlZCBwcm9wc1xuICAgIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBkZWZhdWx0IExheWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/layer.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/map.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/map.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapContext: function() { return /* binding */ MapContext; },\n/* harmony export */   \"default\": function() { return /* binding */ Map; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _use_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-map */ \"./node_modules/react-map-gl/dist/esm/components/use-map.js\");\n/* harmony import */ var _mapbox_mapbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mapbox/mapbox */ \"./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js\");\n/* harmony import */ var _mapbox_create_ref__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mapbox/create-ref */ \"./node_modules/react-map-gl/dist/esm/mapbox/create-ref.js\");\n/* harmony import */ var _utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/use-isomorphic-layout-effect */ \"./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js\");\n/* harmony import */ var _utils_set_globals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/set-globals */ \"./node_modules/react-map-gl/dist/esm/utils/set-globals.js\");\n\n\n\n\n\n\n\nconst MapContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction Map(props, ref, defaultLib) {\n    const mountedMapsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_use_map__WEBPACK_IMPORTED_MODULE_1__.MountedMapsContext);\n    const [mapInstance, setMapInstance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const { current: contextValue } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ mapLib: null, map: null });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const mapLib = props.mapLib;\n        let isMounted = true;\n        let mapbox;\n        Promise.resolve(mapLib || defaultLib)\n            .then((module) => {\n            if (!isMounted) {\n                return;\n            }\n            if (!module) {\n                throw new Error('Invalid mapLib');\n            }\n            const mapboxgl = 'Map' in module ? module : module.default;\n            if (!mapboxgl.Map) {\n                throw new Error('Invalid mapLib');\n            }\n            // workerUrl & workerClass may change the result of supported()\n            // https://github.com/visgl/react-map-gl/discussions/2027\n            (0,_utils_set_globals__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(mapboxgl, props);\n            if (!mapboxgl.supported || mapboxgl.supported(props)) {\n                if (props.reuseMaps) {\n                    mapbox = _mapbox_mapbox__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reuse(props, containerRef.current);\n                }\n                if (!mapbox) {\n                    mapbox = new _mapbox_mapbox__WEBPACK_IMPORTED_MODULE_2__[\"default\"](mapboxgl.Map, props, containerRef.current);\n                }\n                contextValue.map = (0,_mapbox_create_ref__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(mapbox);\n                contextValue.mapLib = mapboxgl;\n                setMapInstance(mapbox);\n                mountedMapsContext === null || mountedMapsContext === void 0 ? void 0 : mountedMapsContext.onMapMount(contextValue.map, props.id);\n            }\n            else {\n                throw new Error('Map is not supported by this browser');\n            }\n        })\n            .catch(error => {\n            const { onError } = props;\n            if (onError) {\n                onError({\n                    type: 'error',\n                    target: null,\n                    originalEvent: null,\n                    error\n                });\n            }\n            else {\n                console.error(error); // eslint-disable-line\n            }\n        });\n        return () => {\n            isMounted = false;\n            if (mapbox) {\n                mountedMapsContext === null || mountedMapsContext === void 0 ? void 0 : mountedMapsContext.onMapUnmount(props.id);\n                if (props.reuseMaps) {\n                    mapbox.recycle();\n                }\n                else {\n                    mapbox.destroy();\n                }\n            }\n        };\n    }, []);\n    (0,_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(() => {\n        if (mapInstance) {\n            mapInstance.setProps(props);\n        }\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => contextValue.map, [mapInstance]);\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        ...props.style\n    }), [props.style]);\n    const CHILD_CONTAINER_STYLE = {\n        height: '100%'\n    };\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: props.id, ref: containerRef, style: style }, mapInstance && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(MapContext.Provider, { value: contextValue },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { \"mapboxgl-children\": \"\", style: CHILD_CONTAINER_STYLE }, props.children)))));\n}\n//# sourceMappingURL=map.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErQjtBQUMrRDtBQUMvQztBQUNUO0FBQ087QUFDaUM7QUFDaEM7QUFDdkMsbUJBQW1CLGdEQUFtQjtBQUM5QjtBQUNmLCtCQUErQixpREFBVSxDQUFDLHdEQUFrQjtBQUM1RCwwQ0FBMEMsK0NBQVE7QUFDbEQseUJBQXlCLDZDQUFNO0FBQy9CLFlBQVksd0JBQXdCLEVBQUUsNkNBQU0sR0FBRyx5QkFBeUI7QUFDeEUsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFVO0FBQ3RCO0FBQ0E7QUFDQSw2QkFBNkIsNERBQVk7QUFDekM7QUFDQTtBQUNBLGlDQUFpQyxzREFBTTtBQUN2QztBQUNBLG1DQUFtQyw4REFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLCtFQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSwwREFBbUI7QUFDdkIsa0JBQWtCLDhDQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQW1CLFVBQVUsK0NBQStDLGtCQUFrQixnREFBbUIsd0JBQXdCLHFCQUFxQjtBQUMxSyxRQUFRLGdEQUFtQixVQUFVLHVEQUF1RDtBQUM1RjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9tYXAuanM/NDhlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNb3VudGVkTWFwc0NvbnRleHQgfSBmcm9tICcuL3VzZS1tYXAnO1xuaW1wb3J0IE1hcGJveCBmcm9tICcuLi9tYXBib3gvbWFwYm94JztcbmltcG9ydCBjcmVhdGVSZWYgZnJvbSAnLi4vbWFwYm94L2NyZWF0ZS1yZWYnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAnLi4vdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgc2V0R2xvYmFscyBmcm9tICcuLi91dGlscy9zZXQtZ2xvYmFscyc7XG5leHBvcnQgY29uc3QgTWFwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXAocHJvcHMsIHJlZiwgZGVmYXVsdExpYikge1xuICAgIGNvbnN0IG1vdW50ZWRNYXBzQ29udGV4dCA9IHVzZUNvbnRleHQoTW91bnRlZE1hcHNDb250ZXh0KTtcbiAgICBjb25zdCBbbWFwSW5zdGFuY2UsIHNldE1hcEluc3RhbmNlXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHsgY3VycmVudDogY29udGV4dFZhbHVlIH0gPSB1c2VSZWYoeyBtYXBMaWI6IG51bGwsIG1hcDogbnVsbCB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBtYXBMaWIgPSBwcm9wcy5tYXBMaWI7XG4gICAgICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbWFwYm94O1xuICAgICAgICBQcm9taXNlLnJlc29sdmUobWFwTGliIHx8IGRlZmF1bHRMaWIpXG4gICAgICAgICAgICAudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcExpYicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFwYm94Z2wgPSAnTWFwJyBpbiBtb2R1bGUgPyBtb2R1bGUgOiBtb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgICAgIGlmICghbWFwYm94Z2wuTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcExpYicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd29ya2VyVXJsICYgd29ya2VyQ2xhc3MgbWF5IGNoYW5nZSB0aGUgcmVzdWx0IG9mIHN1cHBvcnRlZCgpXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlzZ2wvcmVhY3QtbWFwLWdsL2Rpc2N1c3Npb25zLzIwMjdcbiAgICAgICAgICAgIHNldEdsb2JhbHMobWFwYm94Z2wsIHByb3BzKTtcbiAgICAgICAgICAgIGlmICghbWFwYm94Z2wuc3VwcG9ydGVkIHx8IG1hcGJveGdsLnN1cHBvcnRlZChwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucmV1c2VNYXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcGJveCA9IE1hcGJveC5yZXVzZShwcm9wcywgY29udGFpbmVyUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1hcGJveCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBib3ggPSBuZXcgTWFwYm94KG1hcGJveGdsLk1hcCwgcHJvcHMsIGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dFZhbHVlLm1hcCA9IGNyZWF0ZVJlZihtYXBib3gpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRWYWx1ZS5tYXBMaWIgPSBtYXBib3hnbDtcbiAgICAgICAgICAgICAgICBzZXRNYXBJbnN0YW5jZShtYXBib3gpO1xuICAgICAgICAgICAgICAgIG1vdW50ZWRNYXBzQ29udGV4dCA9PT0gbnVsbCB8fCBtb3VudGVkTWFwc0NvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vdW50ZWRNYXBzQ29udGV4dC5vbk1hcE1vdW50KGNvbnRleHRWYWx1ZS5tYXAsIHByb3BzLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFwIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkVycm9yIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWFwYm94KSB7XG4gICAgICAgICAgICAgICAgbW91bnRlZE1hcHNDb250ZXh0ID09PSBudWxsIHx8IG1vdW50ZWRNYXBzQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW91bnRlZE1hcHNDb250ZXh0Lm9uTWFwVW5tb3VudChwcm9wcy5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLnJldXNlTWFwcykge1xuICAgICAgICAgICAgICAgICAgICBtYXBib3gucmVjeWNsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwYm94LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobWFwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBjb250ZXh0VmFsdWUubWFwLCBbbWFwSW5zdGFuY2VdKTtcbiAgICBjb25zdCBzdHlsZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAuLi5wcm9wcy5zdHlsZVxuICAgIH0pLCBbcHJvcHMuc3R5bGVdKTtcbiAgICBjb25zdCBDSElMRF9DT05UQUlORVJfU1RZTEUgPSB7XG4gICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBpZDogcHJvcHMuaWQsIHJlZjogY29udGFpbmVyUmVmLCBzdHlsZTogc3R5bGUgfSwgbWFwSW5zdGFuY2UgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcIm1hcGJveGdsLWNoaWxkcmVuXCI6IFwiXCIsIHN0eWxlOiBDSElMRF9DT05UQUlORVJfU1RZTEUgfSwgcHJvcHMuY2hpbGRyZW4pKSkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/map.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/marker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/marker.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_apply_react_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/apply-react-style */ \"./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ \"./node_modules/react-map-gl/dist/esm/components/map.js\");\n/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/deep-equal */ \"./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\");\n/* global document */\n\n\n\n\n\n\n/* eslint-disable complexity,max-statements */\nfunction Marker(props, ref) {\n    const { map, mapLib } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_map__WEBPACK_IMPORTED_MODULE_3__.MapContext);\n    const thisRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ props });\n    thisRef.current.props = props;\n    const marker = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        let hasChildren = false;\n        react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(props.children, el => {\n            if (el) {\n                hasChildren = true;\n            }\n        });\n        const options = {\n            ...props,\n            element: hasChildren ? document.createElement('div') : null\n        };\n        const mk = new mapLib.Marker(options);\n        mk.setLngLat([props.longitude, props.latitude]);\n        mk.getElement().addEventListener('click', (e) => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                type: 'click',\n                target: mk,\n                originalEvent: e\n            });\n        });\n        mk.on('dragstart', e => {\n            var _a, _b;\n            const evt = e;\n            evt.lngLat = marker.getLngLat();\n            (_b = (_a = thisRef.current.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, evt);\n        });\n        mk.on('drag', e => {\n            var _a, _b;\n            const evt = e;\n            evt.lngLat = marker.getLngLat();\n            (_b = (_a = thisRef.current.props).onDrag) === null || _b === void 0 ? void 0 : _b.call(_a, evt);\n        });\n        mk.on('dragend', e => {\n            var _a, _b;\n            const evt = e;\n            evt.lngLat = marker.getLngLat();\n            (_b = (_a = thisRef.current.props).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, evt);\n        });\n        return mk;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        marker.addTo(map.getMap());\n        return () => {\n            marker.remove();\n        };\n    }, []);\n    const { longitude, latitude, offset, style, draggable = false, popup = null, rotation = 0, rotationAlignment = 'auto', pitchAlignment = 'auto' } = props;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (0,_utils_apply_react_style__WEBPACK_IMPORTED_MODULE_2__.applyReactStyle)(marker.getElement(), style);\n    }, [style]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, []);\n    if (marker.getLngLat().lng !== longitude || marker.getLngLat().lat !== latitude) {\n        marker.setLngLat([longitude, latitude]);\n    }\n    if (offset && !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_4__.arePointsEqual)(marker.getOffset(), offset)) {\n        marker.setOffset(offset);\n    }\n    if (marker.isDraggable() !== draggable) {\n        marker.setDraggable(draggable);\n    }\n    if (marker.getRotation() !== rotation) {\n        marker.setRotation(rotation);\n    }\n    if (marker.getRotationAlignment() !== rotationAlignment) {\n        marker.setRotationAlignment(rotationAlignment);\n    }\n    if (marker.getPitchAlignment() !== pitchAlignment) {\n        marker.setPitchAlignment(pitchAlignment);\n    }\n    if (marker.getPopup() !== popup) {\n        marker.setPopup(popup);\n    }\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, marker.getElement());\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(Marker)));\n//# sourceMappingURL=marker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbWFya2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDK0I7QUFDVTtBQUM2RDtBQUN6QztBQUMxQjtBQUNrQjtBQUNyRDtBQUNBO0FBQ0EsWUFBWSxjQUFjLEVBQUUsaURBQVUsQ0FBQyw0Q0FBVTtBQUNqRCxvQkFBb0IsNkNBQU0sR0FBRyxPQUFPO0FBQ3BDO0FBQ0EsbUJBQW1CLDhDQUFPO0FBQzFCO0FBQ0EsUUFBUSwyQ0FBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSx5SUFBeUk7QUFDckosSUFBSSxnREFBUztBQUNiLFFBQVEseUVBQWU7QUFDdkIsS0FBSztBQUNMLElBQUksMERBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBWTtBQUN2QjtBQUNBLCtEQUFlLDJDQUFJLENBQUMsaURBQVUsU0FBUyxFQUFDO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9tYXJrZXIuanM/M2JhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgZG9jdW1lbnQgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlQ29udGV4dCwgZm9yd2FyZFJlZiwgbWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGFwcGx5UmVhY3RTdHlsZSB9IGZyb20gJy4uL3V0aWxzL2FwcGx5LXJlYWN0LXN0eWxlJztcbmltcG9ydCB7IE1hcENvbnRleHQgfSBmcm9tICcuL21hcCc7XG5pbXBvcnQgeyBhcmVQb2ludHNFcXVhbCB9IGZyb20gJy4uL3V0aWxzL2RlZXAtZXF1YWwnO1xuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSxtYXgtc3RhdGVtZW50cyAqL1xuZnVuY3Rpb24gTWFya2VyKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7IG1hcCwgbWFwTGliIH0gPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIGNvbnN0IHRoaXNSZWYgPSB1c2VSZWYoeyBwcm9wcyB9KTtcbiAgICB0aGlzUmVmLmN1cnJlbnQucHJvcHMgPSBwcm9wcztcbiAgICBjb25zdCBtYXJrZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IGhhc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGVsID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGhhc0NoaWxkcmVuID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1rID0gbmV3IG1hcExpYi5NYXJrZXIob3B0aW9ucyk7XG4gICAgICAgIG1rLnNldExuZ0xhdChbcHJvcHMubG9uZ2l0dWRlLCBwcm9wcy5sYXRpdHVkZV0pO1xuICAgICAgICBtay5nZXRFbGVtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXNSZWYuY3VycmVudC5wcm9wcykub25DbGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbWssXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtay5vbignZHJhZ3N0YXJ0JywgZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZTtcbiAgICAgICAgICAgIGV2dC5sbmdMYXQgPSBtYXJrZXIuZ2V0TG5nTGF0KCk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzUmVmLmN1cnJlbnQucHJvcHMpLm9uRHJhZ1N0YXJ0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1rLm9uKCdkcmFnJywgZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZTtcbiAgICAgICAgICAgIGV2dC5sbmdMYXQgPSBtYXJrZXIuZ2V0TG5nTGF0KCk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzUmVmLmN1cnJlbnQucHJvcHMpLm9uRHJhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtay5vbignZHJhZ2VuZCcsIGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGU7XG4gICAgICAgICAgICBldnQubG5nTGF0ID0gbWFya2VyLmdldExuZ0xhdCgpO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpc1JlZi5jdXJyZW50LnByb3BzKS5vbkRyYWdFbmQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBldnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1rO1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtYXJrZXIuYWRkVG8obWFwLmdldE1hcCgpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1hcmtlci5yZW1vdmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgeyBsb25naXR1ZGUsIGxhdGl0dWRlLCBvZmZzZXQsIHN0eWxlLCBkcmFnZ2FibGUgPSBmYWxzZSwgcG9wdXAgPSBudWxsLCByb3RhdGlvbiA9IDAsIHJvdGF0aW9uQWxpZ25tZW50ID0gJ2F1dG8nLCBwaXRjaEFsaWdubWVudCA9ICdhdXRvJyB9ID0gcHJvcHM7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgYXBwbHlSZWFjdFN0eWxlKG1hcmtlci5nZXRFbGVtZW50KCksIHN0eWxlKTtcbiAgICB9LCBbc3R5bGVdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbXSk7XG4gICAgaWYgKG1hcmtlci5nZXRMbmdMYXQoKS5sbmcgIT09IGxvbmdpdHVkZSB8fCBtYXJrZXIuZ2V0TG5nTGF0KCkubGF0ICE9PSBsYXRpdHVkZSkge1xuICAgICAgICBtYXJrZXIuc2V0TG5nTGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlXSk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgJiYgIWFyZVBvaW50c0VxdWFsKG1hcmtlci5nZXRPZmZzZXQoKSwgb2Zmc2V0KSkge1xuICAgICAgICBtYXJrZXIuc2V0T2Zmc2V0KG9mZnNldCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXIuaXNEcmFnZ2FibGUoKSAhPT0gZHJhZ2dhYmxlKSB7XG4gICAgICAgIG1hcmtlci5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9XG4gICAgaWYgKG1hcmtlci5nZXRSb3RhdGlvbigpICE9PSByb3RhdGlvbikge1xuICAgICAgICBtYXJrZXIuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgICBpZiAobWFya2VyLmdldFJvdGF0aW9uQWxpZ25tZW50KCkgIT09IHJvdGF0aW9uQWxpZ25tZW50KSB7XG4gICAgICAgIG1hcmtlci5zZXRSb3RhdGlvbkFsaWdubWVudChyb3RhdGlvbkFsaWdubWVudCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXIuZ2V0UGl0Y2hBbGlnbm1lbnQoKSAhPT0gcGl0Y2hBbGlnbm1lbnQpIHtcbiAgICAgICAgbWFya2VyLnNldFBpdGNoQWxpZ25tZW50KHBpdGNoQWxpZ25tZW50KTtcbiAgICB9XG4gICAgaWYgKG1hcmtlci5nZXRQb3B1cCgpICE9PSBwb3B1cCkge1xuICAgICAgICBtYXJrZXIuc2V0UG9wdXAocG9wdXApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKHByb3BzLmNoaWxkcmVuLCBtYXJrZXIuZ2V0RWxlbWVudCgpKTtcbn1cbmV4cG9ydCBkZWZhdWx0IG1lbW8oZm9yd2FyZFJlZihNYXJrZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcmtlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/marker.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/navigation-control.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/navigation-control.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/apply-react-style */ \"./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\");\n/* harmony import */ var _use_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-control */ \"./node_modules/react-map-gl/dist/esm/components/use-control.js\");\n\n\n\nfunction NavigationControl(props) {\n    const ctrl = (0,_use_control__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(({ mapLib }) => new mapLib.NavigationControl(props), {\n        position: props.position\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (0,_utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__.applyReactStyle)(ctrl._container, props.style);\n    }, [props.style]);\n    return null;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NavigationControl));\n//# sourceMappingURL=navigation-control.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbmF2aWdhdGlvbi1jb250cm9sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ3FCO0FBQ3RCO0FBQ3ZDO0FBQ0EsaUJBQWlCLHdEQUFVLElBQUksUUFBUTtBQUN2QztBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2IsUUFBUSx5RUFBZTtBQUN2QixLQUFLO0FBQ0w7QUFDQTtBQUNBLCtEQUFlLDJDQUFJLG1CQUFtQixFQUFDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9uYXZpZ2F0aW9uLWNvbnRyb2wuanM/Mzg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhcHBseVJlYWN0U3R5bGUgfSBmcm9tICcuLi91dGlscy9hcHBseS1yZWFjdC1zdHlsZSc7XG5pbXBvcnQgdXNlQ29udHJvbCBmcm9tICcuL3VzZS1jb250cm9sJztcbmZ1bmN0aW9uIE5hdmlnYXRpb25Db250cm9sKHByb3BzKSB7XG4gICAgY29uc3QgY3RybCA9IHVzZUNvbnRyb2woKHsgbWFwTGliIH0pID0+IG5ldyBtYXBMaWIuTmF2aWdhdGlvbkNvbnRyb2wocHJvcHMpLCB7XG4gICAgICAgIHBvc2l0aW9uOiBwcm9wcy5wb3NpdGlvblxuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFwcGx5UmVhY3RTdHlsZShjdHJsLl9jb250YWluZXIsIHByb3BzLnN0eWxlKTtcbiAgICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBkZWZhdWx0IG1lbW8oTmF2aWdhdGlvbkNvbnRyb2wpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi1jb250cm9sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/navigation-control.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/popup.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/popup.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_apply_react_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/apply-react-style */ \"./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ \"./node_modules/react-map-gl/dist/esm/components/map.js\");\n/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/deep-equal */ \"./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\");\n\n\n\n\n\n// Adapted from https://github.com/mapbox/mapbox-gl-js/blob/v1.13.0/src/ui/popup.js\nfunction getClassList(className) {\n    return new Set(className ? className.trim().split(/\\s+/) : []);\n}\n/* eslint-disable complexity,max-statements */\nfunction Popup(props, ref) {\n    const { map, mapLib } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_map__WEBPACK_IMPORTED_MODULE_3__.MapContext);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        return document.createElement('div');\n    }, []);\n    const thisRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({ props });\n    thisRef.current.props = props;\n    const popup = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        const options = { ...props };\n        const pp = new mapLib.Popup(options);\n        pp.setLngLat([props.longitude, props.latitude]);\n        pp.once('open', e => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onOpen) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        });\n        return pp;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const onClose = e => {\n            var _a, _b;\n            (_b = (_a = thisRef.current.props).onClose) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        popup.on('close', onClose);\n        popup.setDOMContent(container).addTo(map.getMap());\n        return () => {\n            // https://github.com/visgl/react-map-gl/issues/1825\n            // onClose should not be fired if the popup is removed by unmounting\n            // When using React strict mode, the component is mounted twice.\n            // Firing the onClose callback here would be a false signal to remove the component.\n            popup.off('close', onClose);\n            if (popup.isOpen()) {\n                popup.remove();\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        (0,_utils_apply_react_style__WEBPACK_IMPORTED_MODULE_2__.applyReactStyle)(popup.getElement(), props.style);\n    }, [props.style]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, () => popup, []);\n    if (popup.isOpen()) {\n        if (popup.getLngLat().lng !== props.longitude || popup.getLngLat().lat !== props.latitude) {\n            popup.setLngLat([props.longitude, props.latitude]);\n        }\n        if (props.offset && !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(popup.options.offset, props.offset)) {\n            popup.setOffset(props.offset);\n        }\n        if (popup.options.anchor !== props.anchor || popup.options.maxWidth !== props.maxWidth) {\n            popup.options.anchor = props.anchor;\n            popup.setMaxWidth(props.maxWidth);\n        }\n        if (popup.options.className !== props.className) {\n            const prevClassList = getClassList(popup.options.className);\n            const nextClassList = getClassList(props.className);\n            for (const c of prevClassList) {\n                if (!nextClassList.has(c)) {\n                    popup.removeClassName(c);\n                }\n            }\n            for (const c of nextClassList) {\n                if (!prevClassList.has(c)) {\n                    popup.addClassName(c);\n                }\n            }\n            popup.options.className = props.className;\n        }\n    }\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_0__.createPortal)(props.children, container);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,react__WEBPACK_IMPORTED_MODULE_1__.memo)((0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(Popup)));\n//# sourceMappingURL=popup.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvcG9wdXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUM7QUFDNkQ7QUFDekM7QUFDMUI7QUFDYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWMsRUFBRSxpREFBVSxDQUFDLDRDQUFVO0FBQ2pELHNCQUFzQiw4Q0FBTztBQUM3QjtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNkNBQU0sR0FBRyxPQUFPO0FBQ3BDO0FBQ0Esa0JBQWtCLDhDQUFPO0FBQ3pCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2IsUUFBUSx5RUFBZTtBQUN2QixLQUFLO0FBQ0wsSUFBSSwwREFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNERBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFZO0FBQ3ZCO0FBQ0EsK0RBQWUsMkNBQUksQ0FBQyxpREFBVSxRQUFRLEVBQUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3BvcHVwLmpzPzEyZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VDb250ZXh0LCBmb3J3YXJkUmVmLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXBwbHlSZWFjdFN0eWxlIH0gZnJvbSAnLi4vdXRpbHMvYXBwbHktcmVhY3Qtc3R5bGUnO1xuaW1wb3J0IHsgTWFwQ29udGV4dCB9IGZyb20gJy4vbWFwJztcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gJy4uL3V0aWxzL2RlZXAtZXF1YWwnO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2Jsb2IvdjEuMTMuMC9zcmMvdWkvcG9wdXAuanNcbmZ1bmN0aW9uIGdldENsYXNzTGlzdChjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gbmV3IFNldChjbGFzc05hbWUgPyBjbGFzc05hbWUudHJpbSgpLnNwbGl0KC9cXHMrLykgOiBbXSk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LG1heC1zdGF0ZW1lbnRzICovXG5mdW5jdGlvbiBQb3B1cChwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBtYXAsIG1hcExpYiB9ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCB0aGlzUmVmID0gdXNlUmVmKHsgcHJvcHMgfSk7XG4gICAgdGhpc1JlZi5jdXJyZW50LnByb3BzID0gcHJvcHM7XG4gICAgY29uc3QgcG9wdXAgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4ucHJvcHMgfTtcbiAgICAgICAgY29uc3QgcHAgPSBuZXcgbWFwTGliLlBvcHVwKG9wdGlvbnMpO1xuICAgICAgICBwcC5zZXRMbmdMYXQoW3Byb3BzLmxvbmdpdHVkZSwgcHJvcHMubGF0aXR1ZGVdKTtcbiAgICAgICAgcHAub25jZSgnb3BlbicsIGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXNSZWYuY3VycmVudC5wcm9wcykub25PcGVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHA7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSBlID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzUmVmLmN1cnJlbnQucHJvcHMpLm9uQ2xvc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9wdXAub24oJ2Nsb3NlJywgb25DbG9zZSk7XG4gICAgICAgIHBvcHVwLnNldERPTUNvbnRlbnQoY29udGFpbmVyKS5hZGRUbyhtYXAuZ2V0TWFwKCkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Zpc2dsL3JlYWN0LW1hcC1nbC9pc3N1ZXMvMTgyNVxuICAgICAgICAgICAgLy8gb25DbG9zZSBzaG91bGQgbm90IGJlIGZpcmVkIGlmIHRoZSBwb3B1cCBpcyByZW1vdmVkIGJ5IHVubW91bnRpbmdcbiAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgUmVhY3Qgc3RyaWN0IG1vZGUsIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0d2ljZS5cbiAgICAgICAgICAgIC8vIEZpcmluZyB0aGUgb25DbG9zZSBjYWxsYmFjayBoZXJlIHdvdWxkIGJlIGEgZmFsc2Ugc2lnbmFsIHRvIHJlbW92ZSB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgcG9wdXAub2ZmKCdjbG9zZScsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgaWYgKHBvcHVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgICAgICAgcG9wdXAucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFwcGx5UmVhY3RTdHlsZShwb3B1cC5nZXRFbGVtZW50KCksIHByb3BzLnN0eWxlKTtcbiAgICB9LCBbcHJvcHMuc3R5bGVdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcG9wdXAsIFtdKTtcbiAgICBpZiAocG9wdXAuaXNPcGVuKCkpIHtcbiAgICAgICAgaWYgKHBvcHVwLmdldExuZ0xhdCgpLmxuZyAhPT0gcHJvcHMubG9uZ2l0dWRlIHx8IHBvcHVwLmdldExuZ0xhdCgpLmxhdCAhPT0gcHJvcHMubGF0aXR1ZGUpIHtcbiAgICAgICAgICAgIHBvcHVwLnNldExuZ0xhdChbcHJvcHMubG9uZ2l0dWRlLCBwcm9wcy5sYXRpdHVkZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5vZmZzZXQgJiYgIWRlZXBFcXVhbChwb3B1cC5vcHRpb25zLm9mZnNldCwgcHJvcHMub2Zmc2V0KSkge1xuICAgICAgICAgICAgcG9wdXAuc2V0T2Zmc2V0KHByb3BzLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcHVwLm9wdGlvbnMuYW5jaG9yICE9PSBwcm9wcy5hbmNob3IgfHwgcG9wdXAub3B0aW9ucy5tYXhXaWR0aCAhPT0gcHJvcHMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIHBvcHVwLm9wdGlvbnMuYW5jaG9yID0gcHJvcHMuYW5jaG9yO1xuICAgICAgICAgICAgcG9wdXAuc2V0TWF4V2lkdGgocHJvcHMubWF4V2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3B1cC5vcHRpb25zLmNsYXNzTmFtZSAhPT0gcHJvcHMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2Q2xhc3NMaXN0ID0gZ2V0Q2xhc3NMaXN0KHBvcHVwLm9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDbGFzc0xpc3QgPSBnZXRDbGFzc0xpc3QocHJvcHMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBwcmV2Q2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0Q2xhc3NMaXN0LmhhcyhjKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3B1cC5yZW1vdmVDbGFzc05hbWUoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIG5leHRDbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZDbGFzc0xpc3QuaGFzKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcHVwLmFkZENsYXNzTmFtZShjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3B1cC5vcHRpb25zLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKHByb3BzLmNoaWxkcmVuLCBjb250YWluZXIpO1xufVxuZXhwb3J0IGRlZmF1bHQgbWVtbyhmb3J3YXJkUmVmKFBvcHVwKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3B1cC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/popup.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/scale-control.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/scale-control.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/apply-react-style */ \"./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\");\n/* harmony import */ var _use_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-control */ \"./node_modules/react-map-gl/dist/esm/components/use-control.js\");\n\n\n\nfunction ScaleControl(props) {\n    const ctrl = (0,_use_control__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(({ mapLib }) => new mapLib.ScaleControl(props), {\n        position: props.position\n    });\n    const propsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props);\n    const prevProps = propsRef.current;\n    propsRef.current = props;\n    const { style } = props;\n    if (props.maxWidth !== undefined && props.maxWidth !== prevProps.maxWidth) {\n        ctrl.options.maxWidth = props.maxWidth;\n    }\n    if (props.unit !== undefined && props.unit !== prevProps.unit) {\n        ctrl.setUnit(props.unit);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (0,_utils_apply_react_style__WEBPACK_IMPORTED_MODULE_1__.applyReactStyle)(ctrl._container, style);\n    }, [style]);\n    return null;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(ScaleControl));\n//# sourceMappingURL=scale-control.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc2NhbGUtY29udHJvbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRDtBQUNhO0FBQ3RCO0FBQ3ZDO0FBQ0EsaUJBQWlCLHdEQUFVLElBQUksUUFBUTtBQUN2QztBQUNBLEtBQUs7QUFDTCxxQkFBcUIsNkNBQU07QUFDM0I7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2IsUUFBUSx5RUFBZTtBQUN2QixLQUFLO0FBQ0w7QUFDQTtBQUNBLCtEQUFlLDJDQUFJLGNBQWMsRUFBQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc2NhbGUtY29udHJvbC5qcz9kMTk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXBwbHlSZWFjdFN0eWxlIH0gZnJvbSAnLi4vdXRpbHMvYXBwbHktcmVhY3Qtc3R5bGUnO1xuaW1wb3J0IHVzZUNvbnRyb2wgZnJvbSAnLi91c2UtY29udHJvbCc7XG5mdW5jdGlvbiBTY2FsZUNvbnRyb2wocHJvcHMpIHtcbiAgICBjb25zdCBjdHJsID0gdXNlQ29udHJvbCgoeyBtYXBMaWIgfSkgPT4gbmV3IG1hcExpYi5TY2FsZUNvbnRyb2wocHJvcHMpLCB7XG4gICAgICAgIHBvc2l0aW9uOiBwcm9wcy5wb3NpdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IHByb3BzUmVmID0gdXNlUmVmKHByb3BzKTtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBwcm9wc1JlZi5jdXJyZW50O1xuICAgIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgICBjb25zdCB7IHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAocHJvcHMubWF4V2lkdGggIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5tYXhXaWR0aCAhPT0gcHJldlByb3BzLm1heFdpZHRoKSB7XG4gICAgICAgIGN0cmwub3B0aW9ucy5tYXhXaWR0aCA9IHByb3BzLm1heFdpZHRoO1xuICAgIH1cbiAgICBpZiAocHJvcHMudW5pdCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLnVuaXQgIT09IHByZXZQcm9wcy51bml0KSB7XG4gICAgICAgIGN0cmwuc2V0VW5pdChwcm9wcy51bml0KTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgYXBwbHlSZWFjdFN0eWxlKGN0cmwuX2NvbnRhaW5lciwgc3R5bGUpO1xuICAgIH0sIFtzdHlsZV0pO1xuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGRlZmF1bHQgbWVtbyhTY2FsZUNvbnRyb2wpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NhbGUtY29udHJvbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/scale-control.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/source.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/source.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"./node_modules/react-map-gl/dist/esm/components/map.js\");\n/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ \"./node_modules/react-map-gl/dist/esm/utils/assert.js\");\n/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/deep-equal */ \"./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\");\n\n\n\n\n\n\nlet sourceCounter = 0;\nfunction createSource(map, id, props) {\n    // @ts-ignore\n    if (map.style && map.style._loaded) {\n        const options = { ...props };\n        delete options.id;\n        delete options.children;\n        // @ts-ignore\n        map.addSource(id, options);\n        return map.getSource(id);\n    }\n    return null;\n}\n/* eslint-disable complexity */\nfunction updateSource(source, props, prevProps) {\n    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(props.id === prevProps.id, 'source id changed');\n    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(props.type === prevProps.type, 'source type changed');\n    let changedKey = '';\n    let changedKeyCount = 0;\n    for (const key in props) {\n        if (key !== 'children' && key !== 'id' && !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(prevProps[key], props[key])) {\n            changedKey = key;\n            changedKeyCount++;\n        }\n    }\n    if (!changedKeyCount) {\n        return;\n    }\n    const type = props.type;\n    if (type === 'geojson') {\n        source.setData(props.data);\n    }\n    else if (type === 'image') {\n        source.updateImage({\n            url: props.url,\n            coordinates: props.coordinates\n        });\n    }\n    else if ('setCoordinates' in source && changedKeyCount === 1 && changedKey === 'coordinates') {\n        source.setCoordinates(props.coordinates);\n    }\n    else if ('setUrl' in source) {\n        // Added in 1.12.0:\n        // vectorTileSource.setTiles\n        // vectorTileSource.setUrl\n        switch (changedKey) {\n            case 'url':\n                source.setUrl(props.url);\n                break;\n            case 'tiles':\n                source.setTiles(props.tiles);\n                break;\n            default:\n        }\n    }\n    else {\n        // eslint-disable-next-line\n        console.warn(`Unable to update <Source> prop: ${changedKey}`);\n    }\n}\n/* eslint-enable complexity */\nfunction Source(props) {\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_map__WEBPACK_IMPORTED_MODULE_1__.MapContext).map.getMap();\n    const propsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props);\n    const [, setStyleLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => props.id || `jsx-source-${sourceCounter++}`, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (map) {\n            /* global setTimeout */\n            const forceUpdate = () => setTimeout(() => setStyleLoaded(version => version + 1), 0);\n            map.on('styledata', forceUpdate);\n            forceUpdate();\n            return () => {\n                var _a;\n                map.off('styledata', forceUpdate);\n                // @ts-ignore\n                if (map.style && map.style._loaded && map.getSource(id)) {\n                    // Parent effects are destroyed before child ones, see\n                    // https://github.com/facebook/react/issues/16728\n                    // Source can only be removed after all child layers are removed\n                    const allLayers = (_a = map.getStyle()) === null || _a === void 0 ? void 0 : _a.layers;\n                    if (allLayers) {\n                        for (const layer of allLayers) {\n                            // @ts-ignore (2339) source does not exist on all layer types\n                            if (layer.source === id) {\n                                map.removeLayer(layer.id);\n                            }\n                        }\n                    }\n                    map.removeSource(id);\n                }\n            };\n        }\n        return undefined;\n    }, [map]);\n    // @ts-ignore\n    let source = map && map.style && map.getSource(id);\n    if (source) {\n        updateSource(source, props, propsRef.current);\n    }\n    else {\n        source = createSource(map, id, props);\n    }\n    propsRef.current = props;\n    return ((source &&\n        react__WEBPACK_IMPORTED_MODULE_0__.Children.map(props.children, child => child &&\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, {\n                source: id\n            }))) ||\n        null);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Source);\n//# sourceMappingURL=source.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc291cmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUMwQztBQUNwQztBQUNGO0FBQ0U7QUFDVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseURBQU07QUFDVixJQUFJLHlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDREQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQVUsQ0FBQyw0Q0FBVTtBQUNyQyxxQkFBcUIsNkNBQU07QUFDM0IsK0JBQStCLCtDQUFRO0FBQ3ZDLGVBQWUsOENBQU8saUNBQWlDLGdCQUFnQjtBQUN2RSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBYztBQUN0QixZQUFZLG1EQUFZO0FBQ3hCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwrREFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3NvdXJjZS5qcz9kZGE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1hcENvbnRleHQgfSBmcm9tICcuL21hcCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQgeyBkZWVwRXF1YWwgfSBmcm9tICcuLi91dGlscy9kZWVwLWVxdWFsJztcbmxldCBzb3VyY2VDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVNvdXJjZShtYXAsIGlkLCBwcm9wcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAobWFwLnN0eWxlICYmIG1hcC5zdHlsZS5fbG9hZGVkKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLnByb3BzIH07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmlkO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGlsZHJlbjtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBtYXAuYWRkU291cmNlKGlkLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXRTb3VyY2UoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmZ1bmN0aW9uIHVwZGF0ZVNvdXJjZShzb3VyY2UsIHByb3BzLCBwcmV2UHJvcHMpIHtcbiAgICBhc3NlcnQocHJvcHMuaWQgPT09IHByZXZQcm9wcy5pZCwgJ3NvdXJjZSBpZCBjaGFuZ2VkJyk7XG4gICAgYXNzZXJ0KHByb3BzLnR5cGUgPT09IHByZXZQcm9wcy50eXBlLCAnc291cmNlIHR5cGUgY2hhbmdlZCcpO1xuICAgIGxldCBjaGFuZ2VkS2V5ID0gJyc7XG4gICAgbGV0IGNoYW5nZWRLZXlDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdpZCcgJiYgIWRlZXBFcXVhbChwcmV2UHJvcHNba2V5XSwgcHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIGNoYW5nZWRLZXkgPSBrZXk7XG4gICAgICAgICAgICBjaGFuZ2VkS2V5Q291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNoYW5nZWRLZXlDb3VudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBwcm9wcy50eXBlO1xuICAgIGlmICh0eXBlID09PSAnZ2VvanNvbicpIHtcbiAgICAgICAgc291cmNlLnNldERhdGEocHJvcHMuZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgICAgc291cmNlLnVwZGF0ZUltYWdlKHtcbiAgICAgICAgICAgIHVybDogcHJvcHMudXJsLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHByb3BzLmNvb3JkaW5hdGVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICgnc2V0Q29vcmRpbmF0ZXMnIGluIHNvdXJjZSAmJiBjaGFuZ2VkS2V5Q291bnQgPT09IDEgJiYgY2hhbmdlZEtleSA9PT0gJ2Nvb3JkaW5hdGVzJykge1xuICAgICAgICBzb3VyY2Uuc2V0Q29vcmRpbmF0ZXMocHJvcHMuY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnc2V0VXJsJyBpbiBzb3VyY2UpIHtcbiAgICAgICAgLy8gQWRkZWQgaW4gMS4xMi4wOlxuICAgICAgICAvLyB2ZWN0b3JUaWxlU291cmNlLnNldFRpbGVzXG4gICAgICAgIC8vIHZlY3RvclRpbGVTb3VyY2Uuc2V0VXJsXG4gICAgICAgIHN3aXRjaCAoY2hhbmdlZEtleSkge1xuICAgICAgICAgICAgY2FzZSAndXJsJzpcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc2V0VXJsKHByb3BzLnVybCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0aWxlcyc6XG4gICAgICAgICAgICAgICAgc291cmNlLnNldFRpbGVzKHByb3BzLnRpbGVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zb2xlLndhcm4oYFVuYWJsZSB0byB1cGRhdGUgPFNvdXJjZT4gcHJvcDogJHtjaGFuZ2VkS2V5fWApO1xuICAgIH1cbn1cbi8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuZnVuY3Rpb24gU291cmNlKHByb3BzKSB7XG4gICAgY29uc3QgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KS5tYXAuZ2V0TWFwKCk7XG4gICAgY29uc3QgcHJvcHNSZWYgPSB1c2VSZWYocHJvcHMpO1xuICAgIGNvbnN0IFssIHNldFN0eWxlTG9hZGVkXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBwcm9wcy5pZCB8fCBganN4LXNvdXJjZS0ke3NvdXJjZUNvdW50ZXIrK31gLCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgLyogZ2xvYmFsIHNldFRpbWVvdXQgKi9cbiAgICAgICAgICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKCkgPT4gc2V0VGltZW91dCgoKSA9PiBzZXRTdHlsZUxvYWRlZCh2ZXJzaW9uID0+IHZlcnNpb24gKyAxKSwgMCk7XG4gICAgICAgICAgICBtYXAub24oJ3N0eWxlZGF0YScsIGZvcmNlVXBkYXRlKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBtYXAub2ZmKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQgJiYgbWFwLmdldFNvdXJjZShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyZW50IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBiZWZvcmUgY2hpbGQgb25lcywgc2VlXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MjhcbiAgICAgICAgICAgICAgICAgICAgLy8gU291cmNlIGNhbiBvbmx5IGJlIHJlbW92ZWQgYWZ0ZXIgYWxsIGNoaWxkIGxheWVycyBhcmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxMYXllcnMgPSAoX2EgPSBtYXAuZ2V0U3R5bGUoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheWVycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbExheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiBhbGxMYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlICgyMzM5KSBzb3VyY2UgZG9lcyBub3QgZXhpc3Qgb24gYWxsIGxheWVyIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLnNvdXJjZSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnJlbW92ZUxheWVyKGxheWVyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFwLnJlbW92ZVNvdXJjZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sIFttYXBdKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IHNvdXJjZSA9IG1hcCAmJiBtYXAuc3R5bGUgJiYgbWFwLmdldFNvdXJjZShpZCk7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB1cGRhdGVTb3VyY2Uoc291cmNlLCBwcm9wcywgcHJvcHNSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSBjcmVhdGVTb3VyY2UobWFwLCBpZCwgcHJvcHMpO1xuICAgIH1cbiAgICBwcm9wc1JlZi5jdXJyZW50ID0gcHJvcHM7XG4gICAgcmV0dXJuICgoc291cmNlICYmXG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgY2hpbGQgPT4gY2hpbGQgJiZcbiAgICAgICAgICAgIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogaWRcbiAgICAgICAgICAgIH0pKSkgfHxcbiAgICAgICAgbnVsbCk7XG59XG5leHBvcnQgZGVmYXVsdCBTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3VyY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/source.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/use-control.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/use-control.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"./node_modules/react-map-gl/dist/esm/components/map.js\");\n\n\nfunction useControl(onCreate, arg1, arg2, arg3) {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_map__WEBPACK_IMPORTED_MODULE_1__.MapContext);\n    const ctrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => onCreate(context), []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const opts = (arg3 || arg2 || arg1);\n        const onAdd = typeof arg1 === 'function' && typeof arg2 === 'function' ? arg1 : null;\n        const onRemove = typeof arg2 === 'function' ? arg2 : typeof arg1 === 'function' ? arg1 : null;\n        const { map } = context;\n        if (!map.hasControl(ctrl)) {\n            map.addControl(ctrl, opts === null || opts === void 0 ? void 0 : opts.position);\n            if (onAdd) {\n                onAdd(context);\n            }\n        }\n        return () => {\n            if (onRemove) {\n                onRemove(context);\n            }\n            // Map might have been removed (parent effects are destroyed before child ones)\n            if (map.hasControl(ctrl)) {\n                map.removeControl(ctrl);\n            }\n        };\n    }, []);\n    return ctrl;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (useControl);\n//# sourceMappingURL=use-control.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvdXNlLWNvbnRyb2wuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUF1RDtBQUNwQjtBQUNuQztBQUNBLG9CQUFvQixpREFBVSxDQUFDLDRDQUFVO0FBQ3pDLGlCQUFpQiw4Q0FBTztBQUN4QixJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrREFBZSxVQUFVLEVBQUM7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3VzZS1jb250cm9sLmpzPzVmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTWVtbywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTWFwQ29udGV4dCB9IGZyb20gJy4vbWFwJztcbmZ1bmN0aW9uIHVzZUNvbnRyb2wob25DcmVhdGUsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICBjb25zdCBjdHJsID0gdXNlTWVtbygoKSA9PiBvbkNyZWF0ZShjb250ZXh0KSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoYXJnMyB8fCBhcmcyIHx8IGFyZzEpO1xuICAgICAgICBjb25zdCBvbkFkZCA9IHR5cGVvZiBhcmcxID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmcyID09PSAnZnVuY3Rpb24nID8gYXJnMSA6IG51bGw7XG4gICAgICAgIGNvbnN0IG9uUmVtb3ZlID0gdHlwZW9mIGFyZzIgPT09ICdmdW5jdGlvbicgPyBhcmcyIDogdHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicgPyBhcmcxIDogbnVsbDtcbiAgICAgICAgY29uc3QgeyBtYXAgfSA9IGNvbnRleHQ7XG4gICAgICAgIGlmICghbWFwLmhhc0NvbnRyb2woY3RybCkpIHtcbiAgICAgICAgICAgIG1hcC5hZGRDb250cm9sKGN0cmwsIG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAob25BZGQpIHtcbiAgICAgICAgICAgICAgICBvbkFkZChjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9uUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgb25SZW1vdmUoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXAgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgKHBhcmVudCBlZmZlY3RzIGFyZSBkZXN0cm95ZWQgYmVmb3JlIGNoaWxkIG9uZXMpXG4gICAgICAgICAgICBpZiAobWFwLmhhc0NvbnRyb2woY3RybCkpIHtcbiAgICAgICAgICAgICAgICBtYXAucmVtb3ZlQ29udHJvbChjdHJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGN0cmw7XG59XG5leHBvcnQgZGVmYXVsdCB1c2VDb250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWNvbnRyb2wuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/use-control.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/components/use-map.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/components/use-map.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapProvider: function() { return /* binding */ MapProvider; },\n/* harmony export */   MountedMapsContext: function() { return /* binding */ MountedMapsContext; },\n/* harmony export */   useMap: function() { return /* binding */ useMap; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"./node_modules/react-map-gl/dist/esm/components/map.js\");\n\n\n\nconst MountedMapsContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst MapProvider = props => {\n    const [maps, setMaps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const onMapMount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((map, id = 'default') => {\n        setMaps(currMaps => {\n            if (id === 'current') {\n                throw new Error(\"'current' cannot be used as map id\");\n            }\n            if (currMaps[id]) {\n                throw new Error(`Multiple maps with the same id: ${id}`);\n            }\n            return { ...currMaps, [id]: map };\n        });\n    }, []);\n    const onMapUnmount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id = 'default') => {\n        setMaps(currMaps => {\n            if (currMaps[id]) {\n                const nextMaps = { ...currMaps };\n                delete nextMaps[id];\n                return nextMaps;\n            }\n            return currMaps;\n        });\n    }, []);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(MountedMapsContext.Provider, { value: {\n            maps,\n            onMapMount,\n            onMapUnmount\n        } }, props.children));\n};\nfunction useMap() {\n    var _a;\n    const maps = (_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MountedMapsContext)) === null || _a === void 0 ? void 0 : _a.maps;\n    const currentMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_map__WEBPACK_IMPORTED_MODULE_1__.MapContext);\n    const mapsWithCurrent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return { ...maps, current: currentMap === null || currentMap === void 0 ? void 0 : currentMap.map };\n    }, [maps, currentMap]);\n    return mapsWithCurrent;\n}\n//# sourceMappingURL=use-map.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvdXNlLW1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFDb0M7QUFDaEM7QUFDNUIsMkJBQTJCLGdEQUFtQjtBQUM5QztBQUNQLDRCQUE0QiwrQ0FBUSxHQUFHO0FBQ3ZDLHVCQUF1QixrREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEdBQUc7QUFDdEU7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCx5QkFBeUIsa0RBQVc7QUFDcEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsWUFBWSxnREFBbUIsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNPO0FBQ1A7QUFDQSx1QkFBdUIsaURBQVU7QUFDakMsdUJBQXVCLGlEQUFVLENBQUMsNENBQVU7QUFDNUMsNEJBQTRCLDhDQUFPO0FBQ25DLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy91c2UtbWFwLmpzPzY5NzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTWFwQ29udGV4dCB9IGZyb20gJy4vbWFwJztcbmV4cG9ydCBjb25zdCBNb3VudGVkTWFwc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0IGNvbnN0IE1hcFByb3ZpZGVyID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IFttYXBzLCBzZXRNYXBzXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBjb25zdCBvbk1hcE1vdW50ID0gdXNlQ2FsbGJhY2soKG1hcCwgaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICAgICAgc2V0TWFwcyhjdXJyTWFwcyA9PiB7XG4gICAgICAgICAgICBpZiAoaWQgPT09ICdjdXJyZW50Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidjdXJyZW50JyBjYW5ub3QgYmUgdXNlZCBhcyBtYXAgaWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyck1hcHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBtYXBzIHdpdGggdGhlIHNhbWUgaWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5jdXJyTWFwcywgW2lkXTogbWFwIH07XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBvbk1hcFVubW91bnQgPSB1c2VDYWxsYmFjaygoaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICAgICAgc2V0TWFwcyhjdXJyTWFwcyA9PiB7XG4gICAgICAgICAgICBpZiAoY3Vyck1hcHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dE1hcHMgPSB7IC4uLmN1cnJNYXBzIH07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5leHRNYXBzW2lkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dE1hcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3Vyck1hcHM7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW91bnRlZE1hcHNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7XG4gICAgICAgICAgICBtYXBzLFxuICAgICAgICAgICAgb25NYXBNb3VudCxcbiAgICAgICAgICAgIG9uTWFwVW5tb3VudFxuICAgICAgICB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWFwcyA9IChfYSA9IHVzZUNvbnRleHQoTW91bnRlZE1hcHNDb250ZXh0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcHM7XG4gICAgY29uc3QgY3VycmVudE1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgY29uc3QgbWFwc1dpdGhDdXJyZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7IC4uLm1hcHMsIGN1cnJlbnQ6IGN1cnJlbnRNYXAgPT09IG51bGwgfHwgY3VycmVudE1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudE1hcC5tYXAgfTtcbiAgICB9LCBbbWFwcywgY3VycmVudE1hcF0pO1xuICAgIHJldHVybiBtYXBzV2l0aEN1cnJlbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/components/use-map.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/exports-mapbox.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/exports-mapbox.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttributionControl: function() { return /* binding */ AttributionControl; },\n/* harmony export */   FullscreenControl: function() { return /* binding */ FullscreenControl; },\n/* harmony export */   GeolocateControl: function() { return /* binding */ GeolocateControl; },\n/* harmony export */   Layer: function() { return /* binding */ Layer; },\n/* harmony export */   Map: function() { return /* binding */ Map; },\n/* harmony export */   MapProvider: function() { return /* reexport safe */ _components_use_map__WEBPACK_IMPORTED_MODULE_11__.MapProvider; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   NavigationControl: function() { return /* binding */ NavigationControl; },\n/* harmony export */   Popup: function() { return /* binding */ Popup; },\n/* harmony export */   ScaleControl: function() { return /* binding */ ScaleControl; },\n/* harmony export */   Source: function() { return /* binding */ Source; },\n/* harmony export */   useControl: function() { return /* reexport safe */ _components_use_control__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; },\n/* harmony export */   useMap: function() { return /* binding */ useMap; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/map */ \"./node_modules/react-map-gl/dist/esm/components/map.js\");\n/* harmony import */ var _components_marker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/marker */ \"./node_modules/react-map-gl/dist/esm/components/marker.js\");\n/* harmony import */ var _components_popup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/popup */ \"./node_modules/react-map-gl/dist/esm/components/popup.js\");\n/* harmony import */ var _components_attribution_control__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/attribution-control */ \"./node_modules/react-map-gl/dist/esm/components/attribution-control.js\");\n/* harmony import */ var _components_fullscreen_control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/fullscreen-control */ \"./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js\");\n/* harmony import */ var _components_geolocate_control__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/geolocate-control */ \"./node_modules/react-map-gl/dist/esm/components/geolocate-control.js\");\n/* harmony import */ var _components_navigation_control__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/navigation-control */ \"./node_modules/react-map-gl/dist/esm/components/navigation-control.js\");\n/* harmony import */ var _components_scale_control__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/scale-control */ \"./node_modules/react-map-gl/dist/esm/components/scale-control.js\");\n/* harmony import */ var _components_layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/layer */ \"./node_modules/react-map-gl/dist/esm/components/layer.js\");\n/* harmony import */ var _components_source__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/source */ \"./node_modules/react-map-gl/dist/esm/components/source.js\");\n/* harmony import */ var _components_use_map__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/use-map */ \"./node_modules/react-map-gl/dist/esm/components/use-map.js\");\n/* harmony import */ var _components_use_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/use-control */ \"./node_modules/react-map-gl/dist/esm/components/use-control.js\");\n/* harmony import */ var _types_public__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./types/public */ \"./node_modules/react-map-gl/dist/esm/types/public.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types_public__WEBPACK_IMPORTED_MODULE_13__) if([\"default\",\"useMap\",\"Map\",\"Marker\",\"Popup\",\"AttributionControl\",\"FullscreenControl\",\"NavigationControl\",\"GeolocateControl\",\"ScaleControl\",\"Layer\",\"Source\",\"useControl\",\"MapProvider\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _types_public__WEBPACK_IMPORTED_MODULE_13__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _types_style_spec_mapbox__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./types/style-spec-mapbox */ \"./node_modules/react-map-gl/dist/esm/types/style-spec-mapbox.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types_style_spec_mapbox__WEBPACK_IMPORTED_MODULE_14__) if([\"default\",\"useMap\",\"Map\",\"Marker\",\"Popup\",\"AttributionControl\",\"FullscreenControl\",\"NavigationControl\",\"GeolocateControl\",\"ScaleControl\",\"Layer\",\"Source\",\"useControl\",\"MapProvider\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _types_style_spec_mapbox__WEBPACK_IMPORTED_MODULE_14__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n\n\n\n\n\n\n\nfunction useMap() {\n    return (0,_components_use_map__WEBPACK_IMPORTED_MODULE_11__.useMap)();\n}\nconst mapLib = __webpack_require__.e(/*! import() */ \"node_modules_mapbox-gl_dist_mapbox-gl_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! mapbox-gl */ \"./node_modules/mapbox-gl/dist/mapbox-gl.js\", 23));\nconst Map = (() => {\n    return react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Map(props, ref) {\n        return (0,_components_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(props, ref, mapLib);\n    });\n})();\nconst Marker = _components_marker__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\nconst Popup = _components_popup__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\nconst AttributionControl = _components_attribution_control__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\nconst FullscreenControl = _components_fullscreen_control__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\nconst NavigationControl = _components_navigation_control__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\nconst GeolocateControl = _components_geolocate_control__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\nconst ScaleControl = _components_scale_control__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\nconst Layer = _components_layer__WEBPACK_IMPORTED_MODULE_9__[\"default\"];\nconst Source = _components_source__WEBPACK_IMPORTED_MODULE_10__[\"default\"];\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\n// Types\n\n\n//# sourceMappingURL=exports-mapbox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2V4cG9ydHMtbWFwYm94LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ29CO0FBQ007QUFDRjtBQUMyQjtBQUNGO0FBQ0Y7QUFDRTtBQUNWO0FBQ2Y7QUFDRTtBQUNBO0FBQ2xEO0FBQ1AsV0FBVyw0REFBTztBQUNsQjtBQUNBLGVBQWUsME1BQW1CO0FBQzNCO0FBQ1AsV0FBVyw2Q0FBZ0I7QUFDM0IsZUFBZSwyREFBSTtBQUNuQixLQUFLO0FBQ0wsQ0FBQztBQUNNLGVBQWUsMERBQU87QUFDdEIsY0FBYyx5REFBTTtBQUNwQiwyQkFBMkIsdUVBQW1CO0FBQzlDLDBCQUEwQixzRUFBa0I7QUFDNUMsMEJBQTBCLHNFQUFrQjtBQUM1Qyx5QkFBeUIscUVBQWlCO0FBQzFDLHFCQUFxQixpRUFBYTtBQUNsQyxjQUFjLHlEQUFNO0FBQ3BCLGVBQWUsMkRBQU87QUFDb0M7QUFDZDtBQUNuRCwrREFBZSxHQUFHLEVBQUM7QUFDbkI7QUFDK0I7QUFDVztBQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2V4cG9ydHMtbWFwYm94LmpzP2JjM2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBfTWFwIH0gZnJvbSAnLi9jb21wb25lbnRzL21hcCc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIF9NYXJrZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvbWFya2VyJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgX1BvcHVwIH0gZnJvbSAnLi9jb21wb25lbnRzL3BvcHVwJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgX0F0dHJpYnV0aW9uQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9hdHRyaWJ1dGlvbi1jb250cm9sJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgX0Z1bGxzY3JlZW5Db250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL2Z1bGxzY3JlZW4tY29udHJvbCc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIF9HZW9sb2NhdGVDb250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL2dlb2xvY2F0ZS1jb250cm9sJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgX05hdmlnYXRpb25Db250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL25hdmlnYXRpb24tY29udHJvbCc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIF9TY2FsZUNvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvc2NhbGUtY29udHJvbCc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIF9MYXllciB9IGZyb20gJy4vY29tcG9uZW50cy9sYXllcic7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIF9Tb3VyY2UgfSBmcm9tICcuL2NvbXBvbmVudHMvc291cmNlJztcbmltcG9ydCB7IHVzZU1hcCBhcyBfdXNlTWFwIH0gZnJvbSAnLi9jb21wb25lbnRzL3VzZS1tYXAnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcCgpIHtcbiAgICByZXR1cm4gX3VzZU1hcCgpO1xufVxuY29uc3QgbWFwTGliID0gaW1wb3J0KCdtYXBib3gtZ2wnKTtcbmV4cG9ydCBjb25zdCBNYXAgPSAoKCkgPT4ge1xuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE1hcChwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiBfTWFwKHByb3BzLCByZWYsIG1hcExpYik7XG4gICAgfSk7XG59KSgpO1xuZXhwb3J0IGNvbnN0IE1hcmtlciA9IF9NYXJrZXI7XG5leHBvcnQgY29uc3QgUG9wdXAgPSBfUG9wdXA7XG5leHBvcnQgY29uc3QgQXR0cmlidXRpb25Db250cm9sID0gX0F0dHJpYnV0aW9uQ29udHJvbDtcbmV4cG9ydCBjb25zdCBGdWxsc2NyZWVuQ29udHJvbCA9IF9GdWxsc2NyZWVuQ29udHJvbDtcbmV4cG9ydCBjb25zdCBOYXZpZ2F0aW9uQ29udHJvbCA9IF9OYXZpZ2F0aW9uQ29udHJvbDtcbmV4cG9ydCBjb25zdCBHZW9sb2NhdGVDb250cm9sID0gX0dlb2xvY2F0ZUNvbnRyb2w7XG5leHBvcnQgY29uc3QgU2NhbGVDb250cm9sID0gX1NjYWxlQ29udHJvbDtcbmV4cG9ydCBjb25zdCBMYXllciA9IF9MYXllcjtcbmV4cG9ydCBjb25zdCBTb3VyY2UgPSBfU291cmNlO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VDb250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL3VzZS1jb250cm9sJztcbmV4cG9ydCB7IE1hcFByb3ZpZGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL3VzZS1tYXAnO1xuZXhwb3J0IGRlZmF1bHQgTWFwO1xuLy8gVHlwZXNcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMvcHVibGljJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMvc3R5bGUtc3BlYy1tYXBib3gnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwb3J0cy1tYXBib3guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/exports-mapbox.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _exports_mapbox__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _exports_mapbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exports-mapbox */ \"./node_modules/react-map-gl/dist/esm/exports-mapbox.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _exports_mapbox__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _exports_mapbox__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlDO0FBQ3FCO0FBQ3REIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vaW5kZXguanM/NTgyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2V4cG9ydHMtbWFwYm94JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdCB9IGZyb20gJy4vZXhwb3J0cy1tYXBib3gnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/mapbox/create-ref.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/mapbox/create-ref.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createRef; }\n/* harmony export */ });\n/** These methods may break the react binding if called directly */\nconst skipMethods = [\n    'setMaxBounds',\n    'setMinZoom',\n    'setMaxZoom',\n    'setMinPitch',\n    'setMaxPitch',\n    'setRenderWorldCopies',\n    'setProjection',\n    'setStyle',\n    'addSource',\n    'removeSource',\n    'addLayer',\n    'removeLayer',\n    'setLayerZoomRange',\n    'setFilter',\n    'setPaintProperty',\n    'setLayoutProperty',\n    'setLight',\n    'setTerrain',\n    'setFog',\n    'remove'\n];\nfunction createRef(mapInstance) {\n    if (!mapInstance) {\n        return null;\n    }\n    const map = mapInstance.map;\n    const result = {\n        getMap: () => map,\n        // Overwrite getters to use our shadow transform\n        getCenter: () => mapInstance.transform.center,\n        getZoom: () => mapInstance.transform.zoom,\n        getBearing: () => mapInstance.transform.bearing,\n        getPitch: () => mapInstance.transform.pitch,\n        getPadding: () => mapInstance.transform.padding,\n        getBounds: () => mapInstance.transform.getBounds(),\n        project: (lnglat) => {\n            const tr = map.transform;\n            map.transform = mapInstance.transform;\n            const result = map.project(lnglat);\n            map.transform = tr;\n            return result;\n        },\n        unproject: (point) => {\n            const tr = map.transform;\n            map.transform = mapInstance.transform;\n            const result = map.unproject(point);\n            map.transform = tr;\n            return result;\n        },\n        // options diverge between mapbox and maplibre\n        queryTerrainElevation: (lnglat, options) => {\n            const tr = map.transform;\n            map.transform = mapInstance.transform;\n            const result = map.queryTerrainElevation(lnglat, options);\n            map.transform = tr;\n            return result;\n        },\n        queryRenderedFeatures: (geometry, options) => {\n            const tr = map.transform;\n            map.transform = mapInstance.transform;\n            const result = map.queryRenderedFeatures(geometry, options);\n            map.transform = tr;\n            return result;\n        }\n    };\n    for (const key of getMethodNames(map)) {\n        // @ts-expect-error\n        if (!(key in result) && !skipMethods.includes(key)) {\n            result[key] = map[key].bind(map);\n        }\n    }\n    return result;\n}\nfunction getMethodNames(obj) {\n    const result = new Set();\n    let proto = obj;\n    while (proto) {\n        for (const key of Object.getOwnPropertyNames(proto)) {\n            if (key[0] !== '_' &&\n                typeof obj[key] === 'function' &&\n                key !== 'fire' &&\n                key !== 'setEventedParent') {\n                result.add(key);\n            }\n        }\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Array.from(result);\n}\n//# sourceMappingURL=create-ref.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL21hcGJveC9jcmVhdGUtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vbWFwYm94L2NyZWF0ZS1yZWYuanM/Y2Y3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogVGhlc2UgbWV0aG9kcyBtYXkgYnJlYWsgdGhlIHJlYWN0IGJpbmRpbmcgaWYgY2FsbGVkIGRpcmVjdGx5ICovXG5jb25zdCBza2lwTWV0aG9kcyA9IFtcbiAgICAnc2V0TWF4Qm91bmRzJyxcbiAgICAnc2V0TWluWm9vbScsXG4gICAgJ3NldE1heFpvb20nLFxuICAgICdzZXRNaW5QaXRjaCcsXG4gICAgJ3NldE1heFBpdGNoJyxcbiAgICAnc2V0UmVuZGVyV29ybGRDb3BpZXMnLFxuICAgICdzZXRQcm9qZWN0aW9uJyxcbiAgICAnc2V0U3R5bGUnLFxuICAgICdhZGRTb3VyY2UnLFxuICAgICdyZW1vdmVTb3VyY2UnLFxuICAgICdhZGRMYXllcicsXG4gICAgJ3JlbW92ZUxheWVyJyxcbiAgICAnc2V0TGF5ZXJab29tUmFuZ2UnLFxuICAgICdzZXRGaWx0ZXInLFxuICAgICdzZXRQYWludFByb3BlcnR5JyxcbiAgICAnc2V0TGF5b3V0UHJvcGVydHknLFxuICAgICdzZXRMaWdodCcsXG4gICAgJ3NldFRlcnJhaW4nLFxuICAgICdzZXRGb2cnLFxuICAgICdyZW1vdmUnXG5dO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUmVmKG1hcEluc3RhbmNlKSB7XG4gICAgaWYgKCFtYXBJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbWFwSW5zdGFuY2UubWFwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgZ2V0TWFwOiAoKSA9PiBtYXAsXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBnZXR0ZXJzIHRvIHVzZSBvdXIgc2hhZG93IHRyYW5zZm9ybVxuICAgICAgICBnZXRDZW50ZXI6ICgpID0+IG1hcEluc3RhbmNlLnRyYW5zZm9ybS5jZW50ZXIsXG4gICAgICAgIGdldFpvb206ICgpID0+IG1hcEluc3RhbmNlLnRyYW5zZm9ybS56b29tLFxuICAgICAgICBnZXRCZWFyaW5nOiAoKSA9PiBtYXBJbnN0YW5jZS50cmFuc2Zvcm0uYmVhcmluZyxcbiAgICAgICAgZ2V0UGl0Y2g6ICgpID0+IG1hcEluc3RhbmNlLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgZ2V0UGFkZGluZzogKCkgPT4gbWFwSW5zdGFuY2UudHJhbnNmb3JtLnBhZGRpbmcsXG4gICAgICAgIGdldEJvdW5kczogKCkgPT4gbWFwSW5zdGFuY2UudHJhbnNmb3JtLmdldEJvdW5kcygpLFxuICAgICAgICBwcm9qZWN0OiAobG5nbGF0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ciA9IG1hcC50cmFuc2Zvcm07XG4gICAgICAgICAgICBtYXAudHJhbnNmb3JtID0gbWFwSW5zdGFuY2UudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWFwLnByb2plY3QobG5nbGF0KTtcbiAgICAgICAgICAgIG1hcC50cmFuc2Zvcm0gPSB0cjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVucHJvamVjdDogKHBvaW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ciA9IG1hcC50cmFuc2Zvcm07XG4gICAgICAgICAgICBtYXAudHJhbnNmb3JtID0gbWFwSW5zdGFuY2UudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWFwLnVucHJvamVjdChwb2ludCk7XG4gICAgICAgICAgICBtYXAudHJhbnNmb3JtID0gdHI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICAvLyBvcHRpb25zIGRpdmVyZ2UgYmV0d2VlbiBtYXBib3ggYW5kIG1hcGxpYnJlXG4gICAgICAgIHF1ZXJ5VGVycmFpbkVsZXZhdGlvbjogKGxuZ2xhdCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHIgPSBtYXAudHJhbnNmb3JtO1xuICAgICAgICAgICAgbWFwLnRyYW5zZm9ybSA9IG1hcEluc3RhbmNlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hcC5xdWVyeVRlcnJhaW5FbGV2YXRpb24obG5nbGF0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIG1hcC50cmFuc2Zvcm0gPSB0cjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlczogKGdlb21ldHJ5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ciA9IG1hcC50cmFuc2Zvcm07XG4gICAgICAgICAgICBtYXAudHJhbnNmb3JtID0gbWFwSW5zdGFuY2UudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhnZW9tZXRyeSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBtYXAudHJhbnNmb3JtID0gdHI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBnZXRNZXRob2ROYW1lcyhtYXApKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlc3VsdCkgJiYgIXNraXBNZXRob2RzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbWFwW2tleV0uYmluZChtYXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRNZXRob2ROYW1lcyhvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHByb3RvID0gb2JqO1xuICAgIHdoaWxlIChwcm90bykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykpIHtcbiAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICdfJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ2ZpcmUnICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSAnc2V0RXZlbnRlZFBhcmVudCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLXJlZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/mapbox/create-ref.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Mapbox; }\n/* harmony export */ });\n/* harmony import */ var _utils_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/transform */ \"./node_modules/react-map-gl/dist/esm/utils/transform.js\");\n/* harmony import */ var _utils_style_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/style-utils */ \"./node_modules/react-map-gl/dist/esm/utils/style-utils.js\");\n/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/deep-equal */ \"./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nconst DEFAULT_STYLE = { version: 8, sources: {}, layers: [] };\nconst pointerEvents = {\n    mousedown: 'onMouseDown',\n    mouseup: 'onMouseUp',\n    mouseover: 'onMouseOver',\n    mousemove: 'onMouseMove',\n    click: 'onClick',\n    dblclick: 'onDblClick',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    mouseout: 'onMouseOut',\n    contextmenu: 'onContextMenu',\n    touchstart: 'onTouchStart',\n    touchend: 'onTouchEnd',\n    touchmove: 'onTouchMove',\n    touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n    movestart: 'onMoveStart',\n    move: 'onMove',\n    moveend: 'onMoveEnd',\n    dragstart: 'onDragStart',\n    drag: 'onDrag',\n    dragend: 'onDragEnd',\n    zoomstart: 'onZoomStart',\n    zoom: 'onZoom',\n    zoomend: 'onZoomEnd',\n    rotatestart: 'onRotateStart',\n    rotate: 'onRotate',\n    rotateend: 'onRotateEnd',\n    pitchstart: 'onPitchStart',\n    pitch: 'onPitch',\n    pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n    wheel: 'onWheel',\n    boxzoomstart: 'onBoxZoomStart',\n    boxzoomend: 'onBoxZoomEnd',\n    boxzoomcancel: 'onBoxZoomCancel',\n    resize: 'onResize',\n    load: 'onLoad',\n    render: 'onRender',\n    idle: 'onIdle',\n    remove: 'onRemove',\n    data: 'onData',\n    styledata: 'onStyleData',\n    sourcedata: 'onSourceData',\n    error: 'onError'\n};\nconst settingNames = [\n    'minZoom',\n    'maxZoom',\n    'minPitch',\n    'maxPitch',\n    'maxBounds',\n    'projection',\n    'renderWorldCopies'\n];\nconst handlerNames = [\n    'scrollZoom',\n    'boxZoom',\n    'dragRotate',\n    'dragPan',\n    'keyboard',\n    'doubleClickZoom',\n    'touchZoomRotate',\n    'touchPitch'\n];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nclass Mapbox {\n    constructor(MapClass, props, container) {\n        // mapboxgl.Map instance\n        this._map = null;\n        // Internal states\n        this._internalUpdate = false;\n        this._inRender = false;\n        this._hoveredFeatures = null;\n        this._deferredEvents = {\n            move: false,\n            zoom: false,\n            pitch: false,\n            rotate: false\n        };\n        this._onEvent = (e) => {\n            // @ts-ignore\n            const cb = this.props[otherEvents[e.type]];\n            if (cb) {\n                cb(e);\n            }\n            else if (e.type === 'error') {\n                console.error(e.error); // eslint-disable-line\n            }\n        };\n        this._onPointerEvent = (e) => {\n            if (e.type === 'mousemove' || e.type === 'mouseout') {\n                this._updateHover(e);\n            }\n            // @ts-ignore\n            const cb = this.props[pointerEvents[e.type]];\n            if (cb) {\n                if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n                    e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);\n                }\n                cb(e);\n                delete e.features;\n            }\n        };\n        this._onCameraEvent = (e) => {\n            if (!this._internalUpdate) {\n                // @ts-ignore\n                const cb = this.props[cameraEvents[e.type]];\n                if (cb) {\n                    cb(e);\n                }\n            }\n            if (e.type in this._deferredEvents) {\n                this._deferredEvents[e.type] = false;\n            }\n        };\n        this._MapClass = MapClass;\n        this.props = props;\n        this._initialize(container);\n    }\n    get map() {\n        return this._map;\n    }\n    get transform() {\n        return this._renderTransform;\n    }\n    setProps(props) {\n        const oldProps = this.props;\n        this.props = props;\n        const settingsChanged = this._updateSettings(props, oldProps);\n        if (settingsChanged) {\n            this._createShadowTransform(this._map);\n        }\n        const sizeChanged = this._updateSize(props);\n        const viewStateChanged = this._updateViewState(props, true);\n        this._updateStyle(props, oldProps);\n        this._updateStyleComponents(props, oldProps);\n        this._updateHandlers(props, oldProps);\n        // If 1) view state has changed to match props and\n        //    2) the props change is not triggered by map events,\n        // it's driven by an external state change. Redraw immediately\n        if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n            this.redraw();\n        }\n    }\n    static reuse(props, container) {\n        const that = Mapbox.savedMaps.pop();\n        if (!that) {\n            return null;\n        }\n        const map = that.map;\n        // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n        // intoto the new container from the props.\n        // Step 1: reparenting child nodes from old container to new container\n        const oldContainer = map.getContainer();\n        container.className = oldContainer.className;\n        while (oldContainer.childNodes.length > 0) {\n            container.appendChild(oldContainer.childNodes[0]);\n        }\n        // Step 2: replace the internal container with new container from the react component\n        // @ts-ignore\n        map._container = container;\n        // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n        // When reusing the saved map, we need to disconnect the observer and observe the new container.\n        // Step 3: telling the ResizeObserver to disconnect and observe the new container\n        // @ts-ignore\n        const resizeObserver = map._resizeObserver;\n        if (resizeObserver) {\n            resizeObserver.disconnect();\n            resizeObserver.observe(container);\n        }\n        // Step 4: apply new props\n        that.setProps({ ...props, styleDiffing: false });\n        map.resize();\n        const { initialViewState } = props;\n        if (initialViewState) {\n            if (initialViewState.bounds) {\n                map.fitBounds(initialViewState.bounds, { ...initialViewState.fitBoundsOptions, duration: 0 });\n            }\n            else {\n                that._updateViewState(initialViewState, false);\n            }\n        }\n        // Simulate load event\n        if (map.isStyleLoaded()) {\n            map.fire('load');\n        }\n        else {\n            map.once('styledata', () => map.fire('load'));\n        }\n        // Force reload\n        // @ts-ignore\n        map._update();\n        return that;\n    }\n    /* eslint-disable complexity,max-statements */\n    _initialize(container) {\n        const { props } = this;\n        const { mapStyle = DEFAULT_STYLE } = props;\n        const mapOptions = {\n            ...props,\n            ...props.initialViewState,\n            accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n            container,\n            style: (0,_utils_style_utils__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(mapStyle)\n        };\n        const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n        Object.assign(mapOptions, {\n            center: [viewState.longitude || 0, viewState.latitude || 0],\n            zoom: viewState.zoom || 0,\n            pitch: viewState.pitch || 0,\n            bearing: viewState.bearing || 0\n        });\n        if (props.gl) {\n            // eslint-disable-next-line\n            const getContext = HTMLCanvasElement.prototype.getContext;\n            // Hijack canvas.getContext to return our own WebGLContext\n            // This will be called inside the mapboxgl.Map constructor\n            // @ts-expect-error\n            HTMLCanvasElement.prototype.getContext = () => {\n                // Unhijack immediately\n                HTMLCanvasElement.prototype.getContext = getContext;\n                return props.gl;\n            };\n        }\n        const map = new this._MapClass(mapOptions);\n        // Props that are not part of constructor options\n        if (viewState.padding) {\n            map.setPadding(viewState.padding);\n        }\n        if (props.cursor) {\n            map.getCanvas().style.cursor = props.cursor;\n        }\n        this._createShadowTransform(map);\n        // Hack\n        // Insert code into map's render cycle\n        const renderMap = map._render;\n        map._render = (arg) => {\n            this._inRender = true;\n            renderMap.call(map, arg);\n            this._inRender = false;\n        };\n        const runRenderTaskQueue = map._renderTaskQueue.run;\n        map._renderTaskQueue.run = (arg) => {\n            runRenderTaskQueue.call(map._renderTaskQueue, arg);\n            this._onBeforeRepaint();\n        };\n        map.on('render', () => this._onAfterRepaint());\n        // Insert code into map's event pipeline\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        const fireEvent = map.fire;\n        map.fire = this._fireEvent.bind(this, fireEvent);\n        // add listeners\n        map.on('resize', () => {\n            this._renderTransform.resize(map.transform.width, map.transform.height);\n        });\n        map.on('styledata', () => {\n            this._updateStyleComponents(this.props, {});\n            // Projection can be set in stylesheet\n            (0,_utils_transform__WEBPACK_IMPORTED_MODULE_0__.syncProjection)(map.transform, this._renderTransform);\n        });\n        map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n        for (const eventName in pointerEvents) {\n            map.on(eventName, this._onPointerEvent);\n        }\n        for (const eventName in cameraEvents) {\n            map.on(eventName, this._onCameraEvent);\n        }\n        for (const eventName in otherEvents) {\n            map.on(eventName, this._onEvent);\n        }\n        this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n    recycle() {\n        // Clean up unnecessary elements before storing for reuse.\n        const container = this.map.getContainer();\n        const children = container.querySelector('[mapboxgl-children]');\n        children === null || children === void 0 ? void 0 : children.remove();\n        Mapbox.savedMaps.push(this);\n    }\n    destroy() {\n        this._map.remove();\n    }\n    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n    redraw() {\n        const map = this._map;\n        // map._render will throw error if style does not exist\n        // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n        //   /src/ui/map.js#L1834\n        if (!this._inRender && map.style) {\n            // cancel the scheduled update\n            if (map._frame) {\n                map._frame.cancel();\n                map._frame = null;\n            }\n            // the order is important - render() may schedule another update\n            map._render();\n        }\n    }\n    _createShadowTransform(map) {\n        const renderTransform = (0,_utils_transform__WEBPACK_IMPORTED_MODULE_0__.cloneTransform)(map.transform);\n        map.painter.transform = renderTransform;\n        this._renderTransform = renderTransform;\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n    _updateSize(nextProps) {\n        // Check if size is controlled\n        const { viewState } = nextProps;\n        if (viewState) {\n            const map = this._map;\n            if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n                map.resize();\n                return true;\n            }\n        }\n        return false;\n    }\n    // Adapted from map.jumpTo\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n    _updateViewState(nextProps, triggerEvents) {\n        if (this._internalUpdate) {\n            return false;\n        }\n        const map = this._map;\n        const tr = this._renderTransform;\n        // Take a snapshot of the transform before mutation\n        const { zoom, pitch, bearing } = tr;\n        const isMoving = map.isMoving();\n        if (isMoving) {\n            // All movement of the camera is done relative to the sea level\n            tr.cameraElevationReference = 'sea';\n        }\n        const changed = (0,_utils_transform__WEBPACK_IMPORTED_MODULE_0__.applyViewStateToTransform)(tr, {\n            ...(0,_utils_transform__WEBPACK_IMPORTED_MODULE_0__.transformToViewState)(map.transform),\n            ...nextProps\n        });\n        if (isMoving) {\n            // Reset camera reference\n            tr.cameraElevationReference = 'ground';\n        }\n        if (changed && triggerEvents) {\n            const deferredEvents = this._deferredEvents;\n            // Delay DOM control updates to the next render cycle\n            deferredEvents.move = true;\n            deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n            deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n            deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n        }\n        // Avoid manipulating the real transform when interaction/animation is ongoing\n        // as it would interfere with Mapbox's handlers\n        if (!isMoving) {\n            (0,_utils_transform__WEBPACK_IMPORTED_MODULE_0__.applyViewStateToTransform)(map.transform, nextProps);\n        }\n        return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateSettings(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of settingNames) {\n            if (propName in nextProps && !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(nextProps[propName], currProps[propName])) {\n                changed = true;\n                const setter = map[`set${propName[0].toUpperCase()}${propName.slice(1)}`];\n                setter === null || setter === void 0 ? void 0 : setter.call(map, nextProps[propName]);\n            }\n        }\n        return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n    _updateStyle(nextProps, currProps) {\n        if (nextProps.cursor !== currProps.cursor) {\n            this._map.getCanvas().style.cursor = nextProps.cursor || '';\n        }\n        if (nextProps.mapStyle !== currProps.mapStyle) {\n            const { mapStyle = DEFAULT_STYLE, styleDiffing = true } = nextProps;\n            const options = {\n                diff: styleDiffing\n            };\n            if ('localIdeographFontFamily' in nextProps) {\n                // @ts-ignore Mapbox specific prop\n                options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n            }\n            this._map.setStyle((0,_utils_style_utils__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(mapStyle), options);\n            return true;\n        }\n        return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateStyleComponents(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        if (map.isStyleLoaded()) {\n            if ('light' in nextProps && map.setLight && !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(nextProps.light, currProps.light)) {\n                changed = true;\n                map.setLight(nextProps.light);\n            }\n            if ('fog' in nextProps && map.setFog && !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(nextProps.fog, currProps.fog)) {\n                changed = true;\n                map.setFog(nextProps.fog);\n            }\n            if ('terrain' in nextProps &&\n                map.setTerrain &&\n                !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(nextProps.terrain, currProps.terrain)) {\n                if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n                    changed = true;\n                    map.setTerrain(nextProps.terrain);\n                }\n            }\n        }\n        return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateHandlers(nextProps, currProps) {\n        var _a, _b;\n        const map = this._map;\n        let changed = false;\n        for (const propName of handlerNames) {\n            const newValue = (_a = nextProps[propName]) !== null && _a !== void 0 ? _a : true;\n            const oldValue = (_b = currProps[propName]) !== null && _b !== void 0 ? _b : true;\n            if (!(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(newValue, oldValue)) {\n                changed = true;\n                if (newValue) {\n                    map[propName].enable(newValue);\n                }\n                else {\n                    map[propName].disable();\n                }\n            }\n        }\n        return changed;\n    }\n    _queryRenderedFeatures(point) {\n        const map = this._map;\n        const tr = map.transform;\n        const { interactiveLayerIds = [] } = this.props;\n        try {\n            map.transform = this._renderTransform;\n            return map.queryRenderedFeatures(point, {\n                layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n            });\n        }\n        catch (_a) {\n            // May fail if style is not loaded\n            return [];\n        }\n        finally {\n            map.transform = tr;\n        }\n    }\n    _updateHover(e) {\n        var _a;\n        const { props } = this;\n        const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n        if (shouldTrackHoveredFeatures) {\n            const eventType = e.type;\n            const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n            const features = this._queryRenderedFeatures(e.point);\n            const isHovering = features.length > 0;\n            if (!isHovering && wasHovering) {\n                e.type = 'mouseleave';\n                this._onPointerEvent(e);\n            }\n            this._hoveredFeatures = features;\n            if (isHovering && !wasHovering) {\n                e.type = 'mouseenter';\n                this._onPointerEvent(e);\n            }\n            e.type = eventType;\n        }\n        else {\n            this._hoveredFeatures = null;\n        }\n    }\n    _fireEvent(baseFire, event, properties) {\n        const map = this._map;\n        const tr = map.transform;\n        const eventType = typeof event === 'string' ? event : event.type;\n        if (eventType === 'move') {\n            this._updateViewState(this.props, false);\n        }\n        if (eventType in cameraEvents) {\n            if (typeof event === 'object') {\n                event.viewState = (0,_utils_transform__WEBPACK_IMPORTED_MODULE_0__.transformToViewState)(tr);\n            }\n            if (this._map.isMoving()) {\n                // Replace map.transform with ours during the callbacks\n                map.transform = this._renderTransform;\n                baseFire.call(map, event, properties);\n                map.transform = tr;\n                return map;\n            }\n        }\n        baseFire.call(map, event, properties);\n        return map;\n    }\n    // All camera manipulations are complete, ready to repaint\n    _onBeforeRepaint() {\n        const map = this._map;\n        // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n        this._internalUpdate = true;\n        for (const eventType in this._deferredEvents) {\n            if (this._deferredEvents[eventType]) {\n                map.fire(eventType);\n            }\n        }\n        this._internalUpdate = false;\n        const tr = this._map.transform;\n        // Make sure camera matches the current props\n        map.transform = this._renderTransform;\n        this._onAfterRepaint = () => {\n            // Mapbox transitions between non-mercator projection and mercator during render time\n            // Copy it back to the other\n            (0,_utils_transform__WEBPACK_IMPORTED_MODULE_0__.syncProjection)(this._renderTransform, tr);\n            // Restores camera state before render/load events are fired\n            map.transform = tr;\n        };\n    }\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv() {\n    let accessToken = null;\n    /* global location, process */\n    if (typeof location !== 'undefined') {\n        const match = /access_token=([^&\\/]*)/.exec(location.search);\n        accessToken = match && match[1];\n    }\n    // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n    try {\n        accessToken = accessToken || process.env.MapboxAccessToken;\n    }\n    catch (_a) {\n        // ignore\n    }\n    try {\n        accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n    }\n    catch (_b) {\n        // ignore\n    }\n    return accessToken;\n}\n//# sourceMappingURL=mapbox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL21hcGJveC9tYXBib3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUg7QUFDL0Q7QUFDTjtBQUNoRCx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQSx5REFBeUQsbURBQW1EO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLFlBQVksZ0VBQWM7QUFDMUIsU0FBUztBQUNULDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkVBQXlCO0FBQ2pELGVBQWUsc0VBQW9CO0FBQ25DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDREQUFTO0FBQ25EO0FBQ0EseUNBQXlDLDBCQUEwQixFQUFFLGtCQUFrQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnREFBZ0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0VBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw0REFBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNERBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzRUFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL21hcGJveC9tYXBib3guanM/Njk5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0cmFuc2Zvcm1Ub1ZpZXdTdGF0ZSwgYXBwbHlWaWV3U3RhdGVUb1RyYW5zZm9ybSwgY2xvbmVUcmFuc2Zvcm0sIHN5bmNQcm9qZWN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHJhbnNmb3JtJztcbmltcG9ydCB7IG5vcm1hbGl6ZVN0eWxlIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtdXRpbHMnO1xuaW1wb3J0IHsgZGVlcEVxdWFsIH0gZnJvbSAnLi4vdXRpbHMvZGVlcC1lcXVhbCc7XG5jb25zdCBERUZBVUxUX1NUWUxFID0geyB2ZXJzaW9uOiA4LCBzb3VyY2VzOiB7fSwgbGF5ZXJzOiBbXSB9O1xuY29uc3QgcG9pbnRlckV2ZW50cyA9IHtcbiAgICBtb3VzZWRvd246ICdvbk1vdXNlRG93bicsXG4gICAgbW91c2V1cDogJ29uTW91c2VVcCcsXG4gICAgbW91c2VvdmVyOiAnb25Nb3VzZU92ZXInLFxuICAgIG1vdXNlbW92ZTogJ29uTW91c2VNb3ZlJyxcbiAgICBjbGljazogJ29uQ2xpY2snLFxuICAgIGRibGNsaWNrOiAnb25EYmxDbGljaycsXG4gICAgbW91c2VlbnRlcjogJ29uTW91c2VFbnRlcicsXG4gICAgbW91c2VsZWF2ZTogJ29uTW91c2VMZWF2ZScsXG4gICAgbW91c2VvdXQ6ICdvbk1vdXNlT3V0JyxcbiAgICBjb250ZXh0bWVudTogJ29uQ29udGV4dE1lbnUnLFxuICAgIHRvdWNoc3RhcnQ6ICdvblRvdWNoU3RhcnQnLFxuICAgIHRvdWNoZW5kOiAnb25Ub3VjaEVuZCcsXG4gICAgdG91Y2htb3ZlOiAnb25Ub3VjaE1vdmUnLFxuICAgIHRvdWNoY2FuY2VsOiAnb25Ub3VjaENhbmNlbCdcbn07XG5jb25zdCBjYW1lcmFFdmVudHMgPSB7XG4gICAgbW92ZXN0YXJ0OiAnb25Nb3ZlU3RhcnQnLFxuICAgIG1vdmU6ICdvbk1vdmUnLFxuICAgIG1vdmVlbmQ6ICdvbk1vdmVFbmQnLFxuICAgIGRyYWdzdGFydDogJ29uRHJhZ1N0YXJ0JyxcbiAgICBkcmFnOiAnb25EcmFnJyxcbiAgICBkcmFnZW5kOiAnb25EcmFnRW5kJyxcbiAgICB6b29tc3RhcnQ6ICdvblpvb21TdGFydCcsXG4gICAgem9vbTogJ29uWm9vbScsXG4gICAgem9vbWVuZDogJ29uWm9vbUVuZCcsXG4gICAgcm90YXRlc3RhcnQ6ICdvblJvdGF0ZVN0YXJ0JyxcbiAgICByb3RhdGU6ICdvblJvdGF0ZScsXG4gICAgcm90YXRlZW5kOiAnb25Sb3RhdGVFbmQnLFxuICAgIHBpdGNoc3RhcnQ6ICdvblBpdGNoU3RhcnQnLFxuICAgIHBpdGNoOiAnb25QaXRjaCcsXG4gICAgcGl0Y2hlbmQ6ICdvblBpdGNoRW5kJ1xufTtcbmNvbnN0IG90aGVyRXZlbnRzID0ge1xuICAgIHdoZWVsOiAnb25XaGVlbCcsXG4gICAgYm94em9vbXN0YXJ0OiAnb25Cb3hab29tU3RhcnQnLFxuICAgIGJveHpvb21lbmQ6ICdvbkJveFpvb21FbmQnLFxuICAgIGJveHpvb21jYW5jZWw6ICdvbkJveFpvb21DYW5jZWwnLFxuICAgIHJlc2l6ZTogJ29uUmVzaXplJyxcbiAgICBsb2FkOiAnb25Mb2FkJyxcbiAgICByZW5kZXI6ICdvblJlbmRlcicsXG4gICAgaWRsZTogJ29uSWRsZScsXG4gICAgcmVtb3ZlOiAnb25SZW1vdmUnLFxuICAgIGRhdGE6ICdvbkRhdGEnLFxuICAgIHN0eWxlZGF0YTogJ29uU3R5bGVEYXRhJyxcbiAgICBzb3VyY2VkYXRhOiAnb25Tb3VyY2VEYXRhJyxcbiAgICBlcnJvcjogJ29uRXJyb3InXG59O1xuY29uc3Qgc2V0dGluZ05hbWVzID0gW1xuICAgICdtaW5ab29tJyxcbiAgICAnbWF4Wm9vbScsXG4gICAgJ21pblBpdGNoJyxcbiAgICAnbWF4UGl0Y2gnLFxuICAgICdtYXhCb3VuZHMnLFxuICAgICdwcm9qZWN0aW9uJyxcbiAgICAncmVuZGVyV29ybGRDb3BpZXMnXG5dO1xuY29uc3QgaGFuZGxlck5hbWVzID0gW1xuICAgICdzY3JvbGxab29tJyxcbiAgICAnYm94Wm9vbScsXG4gICAgJ2RyYWdSb3RhdGUnLFxuICAgICdkcmFnUGFuJyxcbiAgICAna2V5Ym9hcmQnLFxuICAgICdkb3VibGVDbGlja1pvb20nLFxuICAgICd0b3VjaFpvb21Sb3RhdGUnLFxuICAgICd0b3VjaFBpdGNoJ1xuXTtcbi8qKlxuICogQSB3cmFwcGVyIGZvciBtYXBib3gtZ2wncyBNYXAgY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwYm94IHtcbiAgICBjb25zdHJ1Y3RvcihNYXBDbGFzcywgcHJvcHMsIGNvbnRhaW5lcikge1xuICAgICAgICAvLyBtYXBib3hnbC5NYXAgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICAgICAgLy8gSW50ZXJuYWwgc3RhdGVzXG4gICAgICAgIHRoaXMuX2ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luUmVuZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRGZWF0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkRXZlbnRzID0ge1xuICAgICAgICAgICAgbW92ZTogZmFsc2UsXG4gICAgICAgICAgICB6b29tOiBmYWxzZSxcbiAgICAgICAgICAgIHBpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIHJvdGF0ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25FdmVudCA9IChlKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBjYiA9IHRoaXMucHJvcHNbb3RoZXJFdmVudHNbZS50eXBlXV07XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5lcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25Qb2ludGVyRXZlbnQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSG92ZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBjYiA9IHRoaXMucHJvcHNbcG9pbnRlckV2ZW50c1tlLnR5cGVdXTtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHMgJiYgZS50eXBlICE9PSAnbW91c2VvdmVyJyAmJiBlLnR5cGUgIT09ICdtb3VzZW91dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5mZWF0dXJlcyA9IHRoaXMuX2hvdmVyZWRGZWF0dXJlcyB8fCB0aGlzLl9xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZS5wb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiKGUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlLmZlYXR1cmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vbkNhbWVyYUV2ZW50ID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW50ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSB0aGlzLnByb3BzW2NhbWVyYUV2ZW50c1tlLnR5cGVdXTtcbiAgICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUudHlwZSBpbiB0aGlzLl9kZWZlcnJlZEV2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmVycmVkRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fTWFwQ2xhc3MgPSBNYXBDbGFzcztcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIGdldCBtYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfVxuICAgIGdldCB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUcmFuc2Zvcm07XG4gICAgfVxuICAgIHNldFByb3BzKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IG9sZFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICBjb25zdCBzZXR0aW5nc0NoYW5nZWQgPSB0aGlzLl91cGRhdGVTZXR0aW5ncyhwcm9wcywgb2xkUHJvcHMpO1xuICAgICAgICBpZiAoc2V0dGluZ3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTaGFkb3dUcmFuc2Zvcm0odGhpcy5fbWFwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplQ2hhbmdlZCA9IHRoaXMuX3VwZGF0ZVNpemUocHJvcHMpO1xuICAgICAgICBjb25zdCB2aWV3U3RhdGVDaGFuZ2VkID0gdGhpcy5fdXBkYXRlVmlld1N0YXRlKHByb3BzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGUocHJvcHMsIG9sZFByb3BzKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGVDb21wb25lbnRzKHByb3BzLCBvbGRQcm9wcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUhhbmRsZXJzKHByb3BzLCBvbGRQcm9wcyk7XG4gICAgICAgIC8vIElmIDEpIHZpZXcgc3RhdGUgaGFzIGNoYW5nZWQgdG8gbWF0Y2ggcHJvcHMgYW5kXG4gICAgICAgIC8vICAgIDIpIHRoZSBwcm9wcyBjaGFuZ2UgaXMgbm90IHRyaWdnZXJlZCBieSBtYXAgZXZlbnRzLFxuICAgICAgICAvLyBpdCdzIGRyaXZlbiBieSBhbiBleHRlcm5hbCBzdGF0ZSBjaGFuZ2UuIFJlZHJhdyBpbW1lZGlhdGVseVxuICAgICAgICBpZiAoc2V0dGluZ3NDaGFuZ2VkIHx8IHNpemVDaGFuZ2VkIHx8ICh2aWV3U3RhdGVDaGFuZ2VkICYmICF0aGlzLl9tYXAuaXNNb3ZpbmcoKSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJldXNlKHByb3BzLCBjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgdGhhdCA9IE1hcGJveC5zYXZlZE1hcHMucG9wKCk7XG4gICAgICAgIGlmICghdGhhdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwID0gdGhhdC5tYXA7XG4gICAgICAgIC8vIFdoZW4gcmV1c2luZyB0aGUgc2F2ZWQgbWFwLCB3ZSBuZWVkIHRvIHJlcGFyZW50IHRoZSBtYXAoY2FudmFzKSBhbmQgb3RoZXIgY2hpbGQgbm9kZXNcbiAgICAgICAgLy8gaW50b3RvIHRoZSBuZXcgY29udGFpbmVyIGZyb20gdGhlIHByb3BzLlxuICAgICAgICAvLyBTdGVwIDE6IHJlcGFyZW50aW5nIGNoaWxkIG5vZGVzIGZyb20gb2xkIGNvbnRhaW5lciB0byBuZXcgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IG9sZENvbnRhaW5lciA9IG1hcC5nZXRDb250YWluZXIoKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IG9sZENvbnRhaW5lci5jbGFzc05hbWU7XG4gICAgICAgIHdoaWxlIChvbGRDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQob2xkQ29udGFpbmVyLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMjogcmVwbGFjZSB0aGUgaW50ZXJuYWwgY29udGFpbmVyIHdpdGggbmV3IGNvbnRhaW5lciBmcm9tIHRoZSByZWFjdCBjb21wb25lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBtYXAuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgLy8gV2l0aCBtYXBsaWJyZS1nbCBhcyBtYXBMaWIsIG1hcCB1c2VzIFJlc2l6ZU9ic2VydmVyIHRvIG9ic2VydmUgd2hlbiBpdHMgY29udGFpbmVyIHJlc2l6ZXMuXG4gICAgICAgIC8vIFdoZW4gcmV1c2luZyB0aGUgc2F2ZWQgbWFwLCB3ZSBuZWVkIHRvIGRpc2Nvbm5lY3QgdGhlIG9ic2VydmVyIGFuZCBvYnNlcnZlIHRoZSBuZXcgY29udGFpbmVyLlxuICAgICAgICAvLyBTdGVwIDM6IHRlbGxpbmcgdGhlIFJlc2l6ZU9ic2VydmVyIHRvIGRpc2Nvbm5lY3QgYW5kIG9ic2VydmUgdGhlIG5ldyBjb250YWluZXJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG1hcC5fcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIGlmIChyZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgNDogYXBwbHkgbmV3IHByb3BzXG4gICAgICAgIHRoYXQuc2V0UHJvcHMoeyAuLi5wcm9wcywgc3R5bGVEaWZmaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgbWFwLnJlc2l6ZSgpO1xuICAgICAgICBjb25zdCB7IGluaXRpYWxWaWV3U3RhdGUgfSA9IHByb3BzO1xuICAgICAgICBpZiAoaW5pdGlhbFZpZXdTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxWaWV3U3RhdGUuYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhpbml0aWFsVmlld1N0YXRlLmJvdW5kcywgeyAuLi5pbml0aWFsVmlld1N0YXRlLmZpdEJvdW5kc09wdGlvbnMsIGR1cmF0aW9uOiAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlVmlld1N0YXRlKGluaXRpYWxWaWV3U3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTaW11bGF0ZSBsb2FkIGV2ZW50XG4gICAgICAgIGlmIChtYXAuaXNTdHlsZUxvYWRlZCgpKSB7XG4gICAgICAgICAgICBtYXAuZmlyZSgnbG9hZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFwLm9uY2UoJ3N0eWxlZGF0YScsICgpID0+IG1hcC5maXJlKCdsb2FkJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcmNlIHJlbG9hZFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG1hcC5fdXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LG1heC1zdGF0ZW1lbnRzICovXG4gICAgX2luaXRpYWxpemUoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbWFwU3R5bGUgPSBERUZBVUxUX1NUWUxFIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbWFwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgLi4ucHJvcHMuaW5pdGlhbFZpZXdTdGF0ZSxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBwcm9wcy5tYXBib3hBY2Nlc3NUb2tlbiB8fCBnZXRBY2Nlc3NUb2tlbkZyb21FbnYoKSB8fCBudWxsLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgc3R5bGU6IG5vcm1hbGl6ZVN0eWxlKG1hcFN0eWxlKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2aWV3U3RhdGUgPSBtYXBPcHRpb25zLmluaXRpYWxWaWV3U3RhdGUgfHwgbWFwT3B0aW9ucy52aWV3U3RhdGUgfHwgbWFwT3B0aW9ucztcbiAgICAgICAgT2JqZWN0LmFzc2lnbihtYXBPcHRpb25zLCB7XG4gICAgICAgICAgICBjZW50ZXI6IFt2aWV3U3RhdGUubG9uZ2l0dWRlIHx8IDAsIHZpZXdTdGF0ZS5sYXRpdHVkZSB8fCAwXSxcbiAgICAgICAgICAgIHpvb206IHZpZXdTdGF0ZS56b29tIHx8IDAsXG4gICAgICAgICAgICBwaXRjaDogdmlld1N0YXRlLnBpdGNoIHx8IDAsXG4gICAgICAgICAgICBiZWFyaW5nOiB2aWV3U3RhdGUuYmVhcmluZyB8fCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvcHMuZ2wpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgY29uc3QgZ2V0Q29udGV4dCA9IEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0O1xuICAgICAgICAgICAgLy8gSGlqYWNrIGNhbnZhcy5nZXRDb250ZXh0IHRvIHJldHVybiBvdXIgb3duIFdlYkdMQ29udGV4dFxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBpbnNpZGUgdGhlIG1hcGJveGdsLk1hcCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVW5oaWphY2sgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmdsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXAgPSBuZXcgdGhpcy5fTWFwQ2xhc3MobWFwT3B0aW9ucyk7XG4gICAgICAgIC8vIFByb3BzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgICAgaWYgKHZpZXdTdGF0ZS5wYWRkaW5nKSB7XG4gICAgICAgICAgICBtYXAuc2V0UGFkZGluZyh2aWV3U3RhdGUucGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmN1cnNvcikge1xuICAgICAgICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9IHByb3BzLmN1cnNvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jcmVhdGVTaGFkb3dUcmFuc2Zvcm0obWFwKTtcbiAgICAgICAgLy8gSGFja1xuICAgICAgICAvLyBJbnNlcnQgY29kZSBpbnRvIG1hcCdzIHJlbmRlciBjeWNsZVxuICAgICAgICBjb25zdCByZW5kZXJNYXAgPSBtYXAuX3JlbmRlcjtcbiAgICAgICAgbWFwLl9yZW5kZXIgPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9pblJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICByZW5kZXJNYXAuY2FsbChtYXAsIGFyZyk7XG4gICAgICAgICAgICB0aGlzLl9pblJlbmRlciA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5SZW5kZXJUYXNrUXVldWUgPSBtYXAuX3JlbmRlclRhc2tRdWV1ZS5ydW47XG4gICAgICAgIG1hcC5fcmVuZGVyVGFza1F1ZXVlLnJ1biA9IChhcmcpID0+IHtcbiAgICAgICAgICAgIHJ1blJlbmRlclRhc2tRdWV1ZS5jYWxsKG1hcC5fcmVuZGVyVGFza1F1ZXVlLCBhcmcpO1xuICAgICAgICAgICAgdGhpcy5fb25CZWZvcmVSZXBhaW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIG1hcC5vbigncmVuZGVyJywgKCkgPT4gdGhpcy5fb25BZnRlclJlcGFpbnQoKSk7XG4gICAgICAgIC8vIEluc2VydCBjb2RlIGludG8gbWFwJ3MgZXZlbnQgcGlwZWxpbmVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICBjb25zdCBmaXJlRXZlbnQgPSBtYXAuZmlyZTtcbiAgICAgICAgbWFwLmZpcmUgPSB0aGlzLl9maXJlRXZlbnQuYmluZCh0aGlzLCBmaXJlRXZlbnQpO1xuICAgICAgICAvLyBhZGQgbGlzdGVuZXJzXG4gICAgICAgIG1hcC5vbigncmVzaXplJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVHJhbnNmb3JtLnJlc2l6ZShtYXAudHJhbnNmb3JtLndpZHRoLCBtYXAudHJhbnNmb3JtLmhlaWdodCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtYXAub24oJ3N0eWxlZGF0YScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlQ29tcG9uZW50cyh0aGlzLnByb3BzLCB7fSk7XG4gICAgICAgICAgICAvLyBQcm9qZWN0aW9uIGNhbiBiZSBzZXQgaW4gc3R5bGVzaGVldFxuICAgICAgICAgICAgc3luY1Byb2plY3Rpb24obWFwLnRyYW5zZm9ybSwgdGhpcy5fcmVuZGVyVHJhbnNmb3JtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcC5vbignc291cmNlZGF0YScsICgpID0+IHRoaXMuX3VwZGF0ZVN0eWxlQ29tcG9uZW50cyh0aGlzLnByb3BzLCB7fSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBwb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICBtYXAub24oZXZlbnROYW1lLCB0aGlzLl9vblBvaW50ZXJFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gY2FtZXJhRXZlbnRzKSB7XG4gICAgICAgICAgICBtYXAub24oZXZlbnROYW1lLCB0aGlzLl9vbkNhbWVyYUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBvdGhlckV2ZW50cykge1xuICAgICAgICAgICAgbWFwLm9uKGV2ZW50TmFtZSwgdGhpcy5fb25FdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksbWF4LXN0YXRlbWVudHMgKi9cbiAgICByZWN5Y2xlKCkge1xuICAgICAgICAvLyBDbGVhbiB1cCB1bm5lY2Vzc2FyeSBlbGVtZW50cyBiZWZvcmUgc3RvcmluZyBmb3IgcmV1c2UuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMubWFwLmdldENvbnRhaW5lcigpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdbbWFwYm94Z2wtY2hpbGRyZW5dJyk7XG4gICAgICAgIGNoaWxkcmVuID09PSBudWxsIHx8IGNoaWxkcmVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZHJlbi5yZW1vdmUoKTtcbiAgICAgICAgTWFwYm94LnNhdmVkTWFwcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlKCk7XG4gICAgfVxuICAgIC8vIEZvcmNlIHJlZHJhdyB0aGUgbWFwIG5vdy4gVHlwaWNhbGx5IHJlc2l6ZSgpIGFuZCBqdW1wVG8oKSBpcyByZWZsZWN0ZWQgaW4gdGhlIG5leHRcbiAgICAvLyByZW5kZXIgY3ljbGUsIHdoaWNoIGlzIG1hbmFnZWQgYnkgTWFwYm94J3MgYW5pbWF0aW9uIGxvb3AuXG4gICAgLy8gVGhpcyByZW1vdmVzIHRoZSBzeW5jaHJvbml6YXRpb24gaXNzdWUgY2F1c2VkIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZS5cbiAgICByZWRyYXcoKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgLy8gbWFwLl9yZW5kZXIgd2lsbCB0aHJvdyBlcnJvciBpZiBzdHlsZSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9ibG9iL2ZiOWZjMzE2ZGExNGU5OWZmNDM2OGYzZTRmYWEzODg4ZmI0M2M1MTNcbiAgICAgICAgLy8gICAvc3JjL3VpL21hcC5qcyNMMTgzNFxuICAgICAgICBpZiAoIXRoaXMuX2luUmVuZGVyICYmIG1hcC5zdHlsZSkge1xuICAgICAgICAgICAgLy8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgdXBkYXRlXG4gICAgICAgICAgICBpZiAobWFwLl9mcmFtZSkge1xuICAgICAgICAgICAgICAgIG1hcC5fZnJhbWUuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgbWFwLl9mcmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgaXMgaW1wb3J0YW50IC0gcmVuZGVyKCkgbWF5IHNjaGVkdWxlIGFub3RoZXIgdXBkYXRlXG4gICAgICAgICAgICBtYXAuX3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jcmVhdGVTaGFkb3dUcmFuc2Zvcm0obWFwKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlclRyYW5zZm9ybSA9IGNsb25lVHJhbnNmb3JtKG1hcC50cmFuc2Zvcm0pO1xuICAgICAgICBtYXAucGFpbnRlci50cmFuc2Zvcm0gPSByZW5kZXJUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX3JlbmRlclRyYW5zZm9ybSA9IHJlbmRlclRyYW5zZm9ybTtcbiAgICB9XG4gICAgLyogVHJpZ2dlciBtYXAgcmVzaXplIGlmIHNpemUgaXMgY29udHJvbGxlZFxuICAgICAgIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBpZiBzaXplIGhhcyBjaGFuZ2VkXG4gICAgICovXG4gICAgX3VwZGF0ZVNpemUobmV4dFByb3BzKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHNpemUgaXMgY29udHJvbGxlZFxuICAgICAgICBjb25zdCB7IHZpZXdTdGF0ZSB9ID0gbmV4dFByb3BzO1xuICAgICAgICBpZiAodmlld1N0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgICAgICBpZiAodmlld1N0YXRlLndpZHRoICE9PSBtYXAudHJhbnNmb3JtLndpZHRoIHx8IHZpZXdTdGF0ZS5oZWlnaHQgIT09IG1hcC50cmFuc2Zvcm0uaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbWFwLnJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWRhcHRlZCBmcm9tIG1hcC5qdW1wVG9cbiAgICAvKiBVcGRhdGUgY2FtZXJhIHRvIG1hdGNoIHByb3BzXG4gICAgICAgQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAgIEBwYXJhbSB7Ym9vbH0gdHJpZ2dlckV2ZW50cyAtIHNob3VsZCBmaXJlIGNhbWVyYSBldmVudHNcbiAgICAgICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBpZiBhbnl0aGluZyBpcyBjaGFuZ2VkXG4gICAgICovXG4gICAgX3VwZGF0ZVZpZXdTdGF0ZShuZXh0UHJvcHMsIHRyaWdnZXJFdmVudHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsVXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBjb25zdCB0ciA9IHRoaXMuX3JlbmRlclRyYW5zZm9ybTtcbiAgICAgICAgLy8gVGFrZSBhIHNuYXBzaG90IG9mIHRoZSB0cmFuc2Zvcm0gYmVmb3JlIG11dGF0aW9uXG4gICAgICAgIGNvbnN0IHsgem9vbSwgcGl0Y2gsIGJlYXJpbmcgfSA9IHRyO1xuICAgICAgICBjb25zdCBpc01vdmluZyA9IG1hcC5pc01vdmluZygpO1xuICAgICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgIC8vIEFsbCBtb3ZlbWVudCBvZiB0aGUgY2FtZXJhIGlzIGRvbmUgcmVsYXRpdmUgdG8gdGhlIHNlYSBsZXZlbFxuICAgICAgICAgICAgdHIuY2FtZXJhRWxldmF0aW9uUmVmZXJlbmNlID0gJ3NlYSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IGFwcGx5Vmlld1N0YXRlVG9UcmFuc2Zvcm0odHIsIHtcbiAgICAgICAgICAgIC4uLnRyYW5zZm9ybVRvVmlld1N0YXRlKG1hcC50cmFuc2Zvcm0pLFxuICAgICAgICAgICAgLi4ubmV4dFByb3BzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGNhbWVyYSByZWZlcmVuY2VcbiAgICAgICAgICAgIHRyLmNhbWVyYUVsZXZhdGlvblJlZmVyZW5jZSA9ICdncm91bmQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkICYmIHRyaWdnZXJFdmVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkRXZlbnRzID0gdGhpcy5fZGVmZXJyZWRFdmVudHM7XG4gICAgICAgICAgICAvLyBEZWxheSBET00gY29udHJvbCB1cGRhdGVzIHRvIHRoZSBuZXh0IHJlbmRlciBjeWNsZVxuICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMubW92ZSA9IHRydWU7XG4gICAgICAgICAgICBkZWZlcnJlZEV2ZW50cy56b29tIHx8IChkZWZlcnJlZEV2ZW50cy56b29tID0gem9vbSAhPT0gdHIuem9vbSk7XG4gICAgICAgICAgICBkZWZlcnJlZEV2ZW50cy5yb3RhdGUgfHwgKGRlZmVycmVkRXZlbnRzLnJvdGF0ZSA9IGJlYXJpbmcgIT09IHRyLmJlYXJpbmcpO1xuICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMucGl0Y2ggfHwgKGRlZmVycmVkRXZlbnRzLnBpdGNoID0gcGl0Y2ggIT09IHRyLnBpdGNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCBtYW5pcHVsYXRpbmcgdGhlIHJlYWwgdHJhbnNmb3JtIHdoZW4gaW50ZXJhY3Rpb24vYW5pbWF0aW9uIGlzIG9uZ29pbmdcbiAgICAgICAgLy8gYXMgaXQgd291bGQgaW50ZXJmZXJlIHdpdGggTWFwYm94J3MgaGFuZGxlcnNcbiAgICAgICAgaWYgKCFpc01vdmluZykge1xuICAgICAgICAgICAgYXBwbHlWaWV3U3RhdGVUb1RyYW5zZm9ybShtYXAudHJhbnNmb3JtLCBuZXh0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICAvKiBVcGRhdGUgY2FtZXJhIGNvbnN0cmFpbnRzIGFuZCBwcm9qZWN0aW9uIHNldHRpbmdzIHRvIG1hdGNoIHByb3BzXG4gICAgICAgQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAgIEBwYXJhbSB7b2JqZWN0fSBjdXJyUHJvcHNcbiAgICAgICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBpZiBhbnl0aGluZyBpcyBjaGFuZ2VkXG4gICAgICovXG4gICAgX3VwZGF0ZVNldHRpbmdzKG5leHRQcm9wcywgY3VyclByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBzZXR0aW5nTmFtZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wTmFtZSBpbiBuZXh0UHJvcHMgJiYgIWRlZXBFcXVhbChuZXh0UHJvcHNbcHJvcE5hbWVdLCBjdXJyUHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRlciA9IG1hcFtgc2V0JHtwcm9wTmFtZVswXS50b1VwcGVyQ2FzZSgpfSR7cHJvcE5hbWUuc2xpY2UoMSl9YF07XG4gICAgICAgICAgICAgICAgc2V0dGVyID09PSBudWxsIHx8IHNldHRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGVyLmNhbGwobWFwLCBuZXh0UHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgLyogVXBkYXRlIG1hcCBzdHlsZSB0byBtYXRjaCBwcm9wc1xuICAgICAgIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgICBAcGFyYW0ge29iamVjdH0gY3VyclByb3BzXG4gICAgICAgQHJldHVybnMge2Jvb2x9IHRydWUgaWYgc3R5bGUgaXMgY2hhbmdlZFxuICAgICAqL1xuICAgIF91cGRhdGVTdHlsZShuZXh0UHJvcHMsIGN1cnJQcm9wcykge1xuICAgICAgICBpZiAobmV4dFByb3BzLmN1cnNvciAhPT0gY3VyclByb3BzLmN1cnNvcikge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9IG5leHRQcm9wcy5jdXJzb3IgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRQcm9wcy5tYXBTdHlsZSAhPT0gY3VyclByb3BzLm1hcFN0eWxlKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1hcFN0eWxlID0gREVGQVVMVF9TVFlMRSwgc3R5bGVEaWZmaW5nID0gdHJ1ZSB9ID0gbmV4dFByb3BzO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBkaWZmOiBzdHlsZURpZmZpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoJ2xvY2FsSWRlb2dyYXBoRm9udEZhbWlseScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBNYXBib3ggc3BlY2lmaWMgcHJvcFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5ID0gbmV4dFByb3BzLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXRTdHlsZShub3JtYWxpemVTdHlsZShtYXBTdHlsZSksIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiBVcGRhdGUgZm9nLCBsaWdodCBhbmQgdGVycmFpbiB0byBtYXRjaCBwcm9wc1xuICAgICAgIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgICBAcGFyYW0ge29iamVjdH0gY3VyclByb3BzXG4gICAgICAgQHJldHVybnMge2Jvb2x9IHRydWUgaWYgYW55dGhpbmcgaXMgY2hhbmdlZFxuICAgICAqL1xuICAgIF91cGRhdGVTdHlsZUNvbXBvbmVudHMobmV4dFByb3BzLCBjdXJyUHJvcHMpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobWFwLmlzU3R5bGVMb2FkZWQoKSkge1xuICAgICAgICAgICAgaWYgKCdsaWdodCcgaW4gbmV4dFByb3BzICYmIG1hcC5zZXRMaWdodCAmJiAhZGVlcEVxdWFsKG5leHRQcm9wcy5saWdodCwgY3VyclByb3BzLmxpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcC5zZXRMaWdodChuZXh0UHJvcHMubGlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdmb2cnIGluIG5leHRQcm9wcyAmJiBtYXAuc2V0Rm9nICYmICFkZWVwRXF1YWwobmV4dFByb3BzLmZvZywgY3VyclByb3BzLmZvZykpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0Rm9nKG5leHRQcm9wcy5mb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd0ZXJyYWluJyBpbiBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAgICAgICBtYXAuc2V0VGVycmFpbiAmJlxuICAgICAgICAgICAgICAgICFkZWVwRXF1YWwobmV4dFByb3BzLnRlcnJhaW4sIGN1cnJQcm9wcy50ZXJyYWluKSkge1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFByb3BzLnRlcnJhaW4gfHwgbWFwLmdldFNvdXJjZShuZXh0UHJvcHMudGVycmFpbi5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0VGVycmFpbihuZXh0UHJvcHMudGVycmFpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICAvKiBVcGRhdGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdG8gbWF0Y2ggcHJvcHNcbiAgICAgICBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICAgQHBhcmFtIHtvYmplY3R9IGN1cnJQcm9wc1xuICAgICAgIEByZXR1cm5zIHtib29sfSB0cnVlIGlmIGFueXRoaW5nIGlzIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlSGFuZGxlcnMobmV4dFByb3BzLCBjdXJyUHJvcHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIGhhbmRsZXJOYW1lcykge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSAoX2EgPSBuZXh0UHJvcHNbcHJvcE5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSAoX2IgPSBjdXJyUHJvcHNbcHJvcE5hbWVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbcHJvcE5hbWVdLmVuYWJsZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXBbcHJvcE5hbWVdLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIF9xdWVyeVJlbmRlcmVkRmVhdHVyZXMocG9pbnQpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBjb25zdCB0ciA9IG1hcC50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IHsgaW50ZXJhY3RpdmVMYXllcklkcyA9IFtdIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWFwLnRyYW5zZm9ybSA9IHRoaXMuX3JlbmRlclRyYW5zZm9ybTtcbiAgICAgICAgICAgIHJldHVybiBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHBvaW50LCB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzOiBpbnRlcmFjdGl2ZUxheWVySWRzLmZpbHRlcihtYXAuZ2V0TGF5ZXIuYmluZChtYXApKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBNYXkgZmFpbCBpZiBzdHlsZSBpcyBub3QgbG9hZGVkXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBtYXAudHJhbnNmb3JtID0gdHI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3VwZGF0ZUhvdmVyKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzaG91bGRUcmFja0hvdmVyZWRGZWF0dXJlcyA9IHByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHMgJiYgKHByb3BzLm9uTW91c2VNb3ZlIHx8IHByb3BzLm9uTW91c2VFbnRlciB8fCBwcm9wcy5vbk1vdXNlTGVhdmUpO1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tIb3ZlcmVkRmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHdhc0hvdmVyaW5nID0gKChfYSA9IHRoaXMuX2hvdmVyZWRGZWF0dXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwO1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSB0aGlzLl9xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZS5wb2ludCk7XG4gICAgICAgICAgICBjb25zdCBpc0hvdmVyaW5nID0gZmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGlmICghaXNIb3ZlcmluZyAmJiB3YXNIb3ZlcmluZykge1xuICAgICAgICAgICAgICAgIGUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICAgICAgICAgICAgICB0aGlzLl9vblBvaW50ZXJFdmVudChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRGZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgICAgICAgICAgaWYgKGlzSG92ZXJpbmcgJiYgIXdhc0hvdmVyaW5nKSB7XG4gICAgICAgICAgICAgICAgZS50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uUG9pbnRlckV2ZW50KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS50eXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faG92ZXJlZEZlYXR1cmVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmlyZUV2ZW50KGJhc2VGaXJlLCBldmVudCwgcHJvcGVydGllcykge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIGNvbnN0IHRyID0gbWFwLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJyA/IGV2ZW50IDogZXZlbnQudHlwZTtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21vdmUnKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWaWV3U3RhdGUodGhpcy5wcm9wcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFR5cGUgaW4gY2FtZXJhRXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnZpZXdTdGF0ZSA9IHRyYW5zZm9ybVRvVmlld1N0YXRlKHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXAuaXNNb3ZpbmcoKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgbWFwLnRyYW5zZm9ybSB3aXRoIG91cnMgZHVyaW5nIHRoZSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBtYXAudHJhbnNmb3JtID0gdGhpcy5fcmVuZGVyVHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGJhc2VGaXJlLmNhbGwobWFwLCBldmVudCwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgbWFwLnRyYW5zZm9ybSA9IHRyO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmFzZUZpcmUuY2FsbChtYXAsIGV2ZW50LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgLy8gQWxsIGNhbWVyYSBtYW5pcHVsYXRpb25zIGFyZSBjb21wbGV0ZSwgcmVhZHkgdG8gcmVwYWludFxuICAgIF9vbkJlZm9yZVJlcGFpbnQoKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNhbWVyYSBjaGFuZ2VzIGRyaXZlbiBieSBwcm9wcywgaW52b2tlIGNhbWVyYSBldmVudHMgc28gdGhhdCBET00gY29udHJvbHMgYXJlIHN5bmNlZFxuICAgICAgICB0aGlzLl9pbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRUeXBlIGluIHRoaXMuX2RlZmVycmVkRXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRFdmVudHNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIG1hcC5maXJlKGV2ZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHIgPSB0aGlzLl9tYXAudHJhbnNmb3JtO1xuICAgICAgICAvLyBNYWtlIHN1cmUgY2FtZXJhIG1hdGNoZXMgdGhlIGN1cnJlbnQgcHJvcHNcbiAgICAgICAgbWFwLnRyYW5zZm9ybSA9IHRoaXMuX3JlbmRlclRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5fb25BZnRlclJlcGFpbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBNYXBib3ggdHJhbnNpdGlvbnMgYmV0d2VlbiBub24tbWVyY2F0b3IgcHJvamVjdGlvbiBhbmQgbWVyY2F0b3IgZHVyaW5nIHJlbmRlciB0aW1lXG4gICAgICAgICAgICAvLyBDb3B5IGl0IGJhY2sgdG8gdGhlIG90aGVyXG4gICAgICAgICAgICBzeW5jUHJvamVjdGlvbih0aGlzLl9yZW5kZXJUcmFuc2Zvcm0sIHRyKTtcbiAgICAgICAgICAgIC8vIFJlc3RvcmVzIGNhbWVyYSBzdGF0ZSBiZWZvcmUgcmVuZGVyL2xvYWQgZXZlbnRzIGFyZSBmaXJlZFxuICAgICAgICAgICAgbWFwLnRyYW5zZm9ybSA9IHRyO1xuICAgICAgICB9O1xuICAgIH1cbn1cbk1hcGJveC5zYXZlZE1hcHMgPSBbXTtcbi8qKlxuICogQWNjZXNzIHRva2VuIGNhbiBiZSBwcm92aWRlZCB2aWEgb25lIG9mOlxuICogICBtYXBib3hBY2Nlc3NUb2tlbiBwcm9wXG4gKiAgIGFjY2Vzc190b2tlbiBxdWVyeSBwYXJhbWV0ZXJcbiAqICAgTWFwYm94QWNjZXNzVG9rZW4gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqICAgUkVBQ1RfQVBQX01BUEJPWF9BQ0NFU1NfVE9LRU4gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIEByZXR1cm5zIGFjY2VzcyB0b2tlblxuICovXG5mdW5jdGlvbiBnZXRBY2Nlc3NUb2tlbkZyb21FbnYoKSB7XG4gICAgbGV0IGFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAvKiBnbG9iYWwgbG9jYXRpb24sIHByb2Nlc3MgKi9cbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9hY2Nlc3NfdG9rZW49KFteJlxcL10qKS8uZXhlYyhsb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICBhY2Nlc3NUb2tlbiA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cbiAgICAvLyBOb3RlOiBUaGlzIGRlcGVuZHMgb24gYnVuZGxlciBwbHVnaW5zIChlLmcuIHdlYnBhY2spIGltcG9ydGluZyBlbnZpcm9ubWVudCBjb3JyZWN0bHlcbiAgICB0cnkge1xuICAgICAgICBhY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IHByb2Nlc3MuZW52Lk1hcGJveEFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX01BUEJPWF9BQ0NFU1NfVE9LRU47XG4gICAgfVxuICAgIGNhdGNoIChfYikge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgcmV0dXJuIGFjY2Vzc1Rva2VuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwYm94LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/types/public.js":
/*!************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/types/public.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3R5cGVzL3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3R5cGVzL3B1YmxpYy5qcz9iOGYwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1YmxpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/types/public.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/types/style-spec-mapbox.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/types/style-spec-mapbox.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=style-spec-mapbox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3R5cGVzL3N0eWxlLXNwZWMtbWFwYm94LmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdHlwZXMvc3R5bGUtc3BlYy1tYXBib3guanM/NzIyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZS1zcGVjLW1hcGJveC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/types/style-spec-mapbox.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyReactStyle: function() { return /* binding */ applyReactStyle; }\n/* harmony export */ });\n// This is a simplified version of\n// https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSPropertyOperations.js#L62\nconst unitlessNumber = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;\nfunction applyReactStyle(element, styles) {\n    if (!element || !styles) {\n        return;\n    }\n    const style = element.style;\n    for (const key in styles) {\n        const value = styles[key];\n        if (Number.isFinite(value) && !unitlessNumber.test(key)) {\n            style[key] = `${value}px`;\n        }\n        else {\n            style[key] = value;\n        }\n    }\n}\n//# sourceMappingURL=apply-react-style.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL2FwcGx5LXJlYWN0LXN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9hcHBseS1yZWFjdC1zdHlsZS5qcz80Njk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2Zcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzQxMzFhZjNlNGJmNTJmM2EwMDM1MzdlYzk1YTE2NTUxNDdjODEyNzAvc3JjL3JlbmRlcmVycy9kb20vc2hhcmVkL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyNMNjJcbmNvbnN0IHVuaXRsZXNzTnVtYmVyID0gL2JveHxmbGV4fGdyaWR8Y29sdW1ufGxpbmVIZWlnaHR8Zm9udFdlaWdodHxvcGFjaXR5fG9yZGVyfHRhYlNpemV8ekluZGV4LztcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlYWN0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsdWUpICYmICF1bml0bGVzc051bWJlci50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHN0eWxlW2tleV0gPSBgJHt2YWx1ZX1weGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseS1yZWFjdC1zdHlsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/utils/apply-react-style.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/utils/assert.js":
/*!************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/utils/assert.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ assert; }\n/* harmony export */ });\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvYXNzZXJ0LmpzPzY5N2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/utils/assert.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/utils/deep-equal.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/utils/deep-equal.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arePointsEqual: function() { return /* binding */ arePointsEqual; },\n/* harmony export */   deepEqual: function() { return /* binding */ deepEqual; }\n/* harmony export */ });\n/**\n * Compare two points\n * @param a\n * @param b\n * @returns true if the points are equal\n */\nfunction arePointsEqual(a, b) {\n    const ax = Array.isArray(a) ? a[0] : a ? a.x : 0;\n    const ay = Array.isArray(a) ? a[1] : a ? a.y : 0;\n    const bx = Array.isArray(b) ? b[0] : b ? b.x : 0;\n    const by = Array.isArray(b) ? b[1] : b ? b.y : 0;\n    return ax === bx && ay === by;\n}\n/* eslint-disable complexity */\n/**\n * Compare any two objects\n * @param a\n * @param b\n * @returns true if the objects are deep equal\n */\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (!a || !b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b) || a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!deepEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (Array.isArray(b)) {\n        return false;\n    }\n    if (typeof a === 'object' && typeof b === 'object') {\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        for (const key of aKeys) {\n            if (!b.hasOwnProperty(key)) {\n                return false;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=deep-equal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL2RlZXAtZXF1YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZGVlcC1lcXVhbC5qcz9mNDIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tcGFyZSB0d28gcG9pbnRzXG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50cyBhcmUgZXF1YWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZVBvaW50c0VxdWFsKGEsIGIpIHtcbiAgICBjb25zdCBheCA9IEFycmF5LmlzQXJyYXkoYSkgPyBhWzBdIDogYSA/IGEueCA6IDA7XG4gICAgY29uc3QgYXkgPSBBcnJheS5pc0FycmF5KGEpID8gYVsxXSA6IGEgPyBhLnkgOiAwO1xuICAgIGNvbnN0IGJ4ID0gQXJyYXkuaXNBcnJheShiKSA/IGJbMF0gOiBiID8gYi54IDogMDtcbiAgICBjb25zdCBieSA9IEFycmF5LmlzQXJyYXkoYikgPyBiWzFdIDogYiA/IGIueSA6IDA7XG4gICAgcmV0dXJuIGF4ID09PSBieCAmJiBheSA9PT0gYnk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4vKipcbiAqIENvbXBhcmUgYW55IHR3byBvYmplY3RzXG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdHMgYXJlIGRlZXAgZXF1YWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYUtleXMpIHtcbiAgICAgICAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWVwLWVxdWFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/utils/set-globals.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/utils/set-globals.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ setGlobals; }\n/* harmony export */ });\nconst globalSettings = [\n    'baseApiUrl',\n    'maxParallelImageRequests',\n    'workerClass',\n    'workerCount',\n    'workerUrl'\n];\nfunction setGlobals(mapLib, props) {\n    for (const key of globalSettings) {\n        if (key in props) {\n            mapLib[key] = props[key];\n        }\n    }\n    const { RTLTextPlugin = 'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js' } = props;\n    if (RTLTextPlugin &&\n        mapLib.getRTLTextPluginStatus &&\n        mapLib.getRTLTextPluginStatus() === 'unavailable') {\n        mapLib.setRTLTextPlugin(RTLTextPlugin, (error) => {\n            if (error) {\n                // eslint-disable-next-line\n                console.error(error);\n            }\n        }, true);\n    }\n}\n//# sourceMappingURL=set-globals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3NldC1nbG9iYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0hBQWdIO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvc2V0LWdsb2JhbHMuanM/MjU5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBnbG9iYWxTZXR0aW5ncyA9IFtcbiAgICAnYmFzZUFwaVVybCcsXG4gICAgJ21heFBhcmFsbGVsSW1hZ2VSZXF1ZXN0cycsXG4gICAgJ3dvcmtlckNsYXNzJyxcbiAgICAnd29ya2VyQ291bnQnLFxuICAgICd3b3JrZXJVcmwnXG5dO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0R2xvYmFscyhtYXBMaWIsIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsU2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgbWFwTGliW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgUlRMVGV4dFBsdWdpbiA9ICdodHRwczovL2FwaS5tYXBib3guY29tL21hcGJveC1nbC1qcy9wbHVnaW5zL21hcGJveC1nbC1ydGwtdGV4dC92MC4yLjMvbWFwYm94LWdsLXJ0bC10ZXh0LmpzJyB9ID0gcHJvcHM7XG4gICAgaWYgKFJUTFRleHRQbHVnaW4gJiZcbiAgICAgICAgbWFwTGliLmdldFJUTFRleHRQbHVnaW5TdGF0dXMgJiZcbiAgICAgICAgbWFwTGliLmdldFJUTFRleHRQbHVnaW5TdGF0dXMoKSA9PT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICBtYXBMaWIuc2V0UlRMVGV4dFBsdWdpbihSVExUZXh0UGx1Z2luLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQtZ2xvYmFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/utils/set-globals.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/utils/style-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/utils/style-utils.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeStyle: function() { return /* binding */ normalizeStyle; }\n/* harmony export */ });\nconst refProps = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n// Prepare a map style object for diffing\n// If immutable - convert to plain object\n// Work around some issues in older styles that would fail Mapbox's diffing\nfunction normalizeStyle(style) {\n    if (!style) {\n        return null;\n    }\n    if (typeof style === 'string') {\n        return style;\n    }\n    if ('toJS' in style) {\n        style = style.toJS();\n    }\n    if (!style.layers) {\n        return style;\n    }\n    const layerIndex = {};\n    for (const layer of style.layers) {\n        layerIndex[layer.id] = layer;\n    }\n    const layers = style.layers.map(layer => {\n        let normalizedLayer = null;\n        if ('interactive' in layer) {\n            normalizedLayer = Object.assign({}, layer);\n            // Breaks style diffing :(\n            // @ts-ignore legacy field not typed\n            delete normalizedLayer.interactive;\n        }\n        // Style diffing doesn't work with refs so expand them out manually before diffing.\n        // @ts-ignore legacy field not typed\n        const layerRef = layerIndex[layer.ref];\n        if (layerRef) {\n            normalizedLayer = normalizedLayer || Object.assign({}, layer);\n            // @ts-ignore\n            delete normalizedLayer.ref;\n            // https://github.com/mapbox/mapbox-gl-js/blob/master/src/style-spec/deref.js\n            for (const propName of refProps) {\n                if (propName in layerRef) {\n                    normalizedLayer[propName] = layerRef[propName];\n                }\n            }\n        }\n        return normalizedLayer || layer;\n    });\n    // Do not mutate the style object provided by the user\n    return { ...style, layers };\n}\n//# sourceMappingURL=style-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3N0eWxlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvc3R5bGUtdXRpbHMuanM/ZmZhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZWZQcm9wcyA9IFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJywgJ21pbnpvb20nLCAnbWF4em9vbScsICdmaWx0ZXInLCAnbGF5b3V0J107XG4vLyBQcmVwYXJlIGEgbWFwIHN0eWxlIG9iamVjdCBmb3IgZGlmZmluZ1xuLy8gSWYgaW1tdXRhYmxlIC0gY29udmVydCB0byBwbGFpbiBvYmplY3Rcbi8vIFdvcmsgYXJvdW5kIHNvbWUgaXNzdWVzIGluIG9sZGVyIHN0eWxlcyB0aGF0IHdvdWxkIGZhaWwgTWFwYm94J3MgZGlmZmluZ1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKSB7XG4gICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgICBpZiAoJ3RvSlMnIGluIHN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gc3R5bGUudG9KUygpO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlLmxheWVycykge1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICAgIGNvbnN0IGxheWVySW5kZXggPSB7fTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHN0eWxlLmxheWVycykge1xuICAgICAgICBsYXllckluZGV4W2xheWVyLmlkXSA9IGxheWVyO1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSBzdHlsZS5sYXllcnMubWFwKGxheWVyID0+IHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRMYXllciA9IG51bGw7XG4gICAgICAgIGlmICgnaW50ZXJhY3RpdmUnIGluIGxheWVyKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkTGF5ZXIgPSBPYmplY3QuYXNzaWduKHt9LCBsYXllcik7XG4gICAgICAgICAgICAvLyBCcmVha3Mgc3R5bGUgZGlmZmluZyA6KFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBsZWdhY3kgZmllbGQgbm90IHR5cGVkXG4gICAgICAgICAgICBkZWxldGUgbm9ybWFsaXplZExheWVyLmludGVyYWN0aXZlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0eWxlIGRpZmZpbmcgZG9lc24ndCB3b3JrIHdpdGggcmVmcyBzbyBleHBhbmQgdGhlbSBvdXQgbWFudWFsbHkgYmVmb3JlIGRpZmZpbmcuXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgbGVnYWN5IGZpZWxkIG5vdCB0eXBlZFxuICAgICAgICBjb25zdCBsYXllclJlZiA9IGxheWVySW5kZXhbbGF5ZXIucmVmXTtcbiAgICAgICAgaWYgKGxheWVyUmVmKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkTGF5ZXIgPSBub3JtYWxpemVkTGF5ZXIgfHwgT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXIpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZGVsZXRlIG5vcm1hbGl6ZWRMYXllci5yZWY7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9ibG9iL21hc3Rlci9zcmMvc3R5bGUtc3BlYy9kZXJlZi5qc1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiByZWZQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSBpbiBsYXllclJlZikge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkTGF5ZXJbcHJvcE5hbWVdID0gbGF5ZXJSZWZbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZExheWVyIHx8IGxheWVyO1xuICAgIH0pO1xuICAgIC8vIERvIG5vdCBtdXRhdGUgdGhlIHN0eWxlIG9iamVjdCBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgIHJldHVybiB7IC4uLnN0eWxlLCBsYXllcnMgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlLXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/utils/style-utils.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/utils/transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/utils/transform.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyViewStateToTransform: function() { return /* binding */ applyViewStateToTransform; },\n/* harmony export */   cloneTransform: function() { return /* binding */ cloneTransform; },\n/* harmony export */   syncProjection: function() { return /* binding */ syncProjection; },\n/* harmony export */   transformToViewState: function() { return /* binding */ transformToViewState; }\n/* harmony export */ });\n/* harmony import */ var _deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deep-equal */ \"./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\");\n\n/**\n * Make a copy of a transform\n * @param tr\n */\nfunction cloneTransform(tr) {\n    const newTransform = tr.clone();\n    // Work around mapbox bug - this value is not assigned in clone(), only in resize()\n    newTransform.pixelsToGLUnits = tr.pixelsToGLUnits;\n    return newTransform;\n}\n/**\n * Copy projection from one transform to another. This only applies to mapbox-gl transforms\n * @param src the transform to copy projection settings from\n * @param dest to transform to copy projection settings to\n */\nfunction syncProjection(src, dest) {\n    if (!src.getProjection) {\n        return;\n    }\n    const srcProjection = src.getProjection();\n    const destProjection = dest.getProjection();\n    if (!(0,_deep_equal__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(srcProjection, destProjection)) {\n        dest.setProjection(srcProjection);\n    }\n}\n/**\n * Capture a transform's current state\n * @param transform\n * @returns descriptor of the view state\n */\nfunction transformToViewState(tr) {\n    return {\n        longitude: tr.center.lng,\n        latitude: tr.center.lat,\n        zoom: tr.zoom,\n        pitch: tr.pitch,\n        bearing: tr.bearing,\n        padding: tr.padding\n    };\n}\n/* eslint-disable complexity */\n/**\n * Mutate a transform to match the given view state\n * @param transform\n * @param viewState\n * @returns true if the transform has changed\n */\nfunction applyViewStateToTransform(tr, props) {\n    const v = props.viewState || props;\n    let changed = false;\n    if ('longitude' in v && 'latitude' in v) {\n        const center = tr.center;\n        // @ts-ignore\n        tr.center = new center.constructor(v.longitude, v.latitude);\n        changed = changed || center !== tr.center;\n    }\n    if ('zoom' in v) {\n        const zoom = tr.zoom;\n        tr.zoom = v.zoom;\n        changed = changed || zoom !== tr.zoom;\n    }\n    if ('bearing' in v) {\n        const bearing = tr.bearing;\n        tr.bearing = v.bearing;\n        changed = changed || bearing !== tr.bearing;\n    }\n    if ('pitch' in v) {\n        const pitch = tr.pitch;\n        tr.pitch = v.pitch;\n        changed = changed || pitch !== tr.pitch;\n    }\n    if (v.padding && !tr.isPaddingEqual(v.padding)) {\n        changed = true;\n        tr.padding = v.padding;\n    }\n    return changed;\n}\n//# sourceMappingURL=transform.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2Zvcm0uanM/Y2ZhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWVwRXF1YWwgfSBmcm9tICcuL2RlZXAtZXF1YWwnO1xuLyoqXG4gKiBNYWtlIGEgY29weSBvZiBhIHRyYW5zZm9ybVxuICogQHBhcmFtIHRyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVRyYW5zZm9ybSh0cikge1xuICAgIGNvbnN0IG5ld1RyYW5zZm9ybSA9IHRyLmNsb25lKCk7XG4gICAgLy8gV29yayBhcm91bmQgbWFwYm94IGJ1ZyAtIHRoaXMgdmFsdWUgaXMgbm90IGFzc2lnbmVkIGluIGNsb25lKCksIG9ubHkgaW4gcmVzaXplKClcbiAgICBuZXdUcmFuc2Zvcm0ucGl4ZWxzVG9HTFVuaXRzID0gdHIucGl4ZWxzVG9HTFVuaXRzO1xuICAgIHJldHVybiBuZXdUcmFuc2Zvcm07XG59XG4vKipcbiAqIENvcHkgcHJvamVjdGlvbiBmcm9tIG9uZSB0cmFuc2Zvcm0gdG8gYW5vdGhlci4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gbWFwYm94LWdsIHRyYW5zZm9ybXNcbiAqIEBwYXJhbSBzcmMgdGhlIHRyYW5zZm9ybSB0byBjb3B5IHByb2plY3Rpb24gc2V0dGluZ3MgZnJvbVxuICogQHBhcmFtIGRlc3QgdG8gdHJhbnNmb3JtIHRvIGNvcHkgcHJvamVjdGlvbiBzZXR0aW5ncyB0b1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3luY1Byb2plY3Rpb24oc3JjLCBkZXN0KSB7XG4gICAgaWYgKCFzcmMuZ2V0UHJvamVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNyY1Byb2plY3Rpb24gPSBzcmMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IGRlc3RQcm9qZWN0aW9uID0gZGVzdC5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKCFkZWVwRXF1YWwoc3JjUHJvamVjdGlvbiwgZGVzdFByb2plY3Rpb24pKSB7XG4gICAgICAgIGRlc3Quc2V0UHJvamVjdGlvbihzcmNQcm9qZWN0aW9uKTtcbiAgICB9XG59XG4vKipcbiAqIENhcHR1cmUgYSB0cmFuc2Zvcm0ncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0gdHJhbnNmb3JtXG4gKiBAcmV0dXJucyBkZXNjcmlwdG9yIG9mIHRoZSB2aWV3IHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Ub1ZpZXdTdGF0ZSh0cikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvbmdpdHVkZTogdHIuY2VudGVyLmxuZyxcbiAgICAgICAgbGF0aXR1ZGU6IHRyLmNlbnRlci5sYXQsXG4gICAgICAgIHpvb206IHRyLnpvb20sXG4gICAgICAgIHBpdGNoOiB0ci5waXRjaCxcbiAgICAgICAgYmVhcmluZzogdHIuYmVhcmluZyxcbiAgICAgICAgcGFkZGluZzogdHIucGFkZGluZ1xuICAgIH07XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4vKipcbiAqIE11dGF0ZSBhIHRyYW5zZm9ybSB0byBtYXRjaCB0aGUgZ2l2ZW4gdmlldyBzdGF0ZVxuICogQHBhcmFtIHRyYW5zZm9ybVxuICogQHBhcmFtIHZpZXdTdGF0ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNmb3JtIGhhcyBjaGFuZ2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVZpZXdTdGF0ZVRvVHJhbnNmb3JtKHRyLCBwcm9wcykge1xuICAgIGNvbnN0IHYgPSBwcm9wcy52aWV3U3RhdGUgfHwgcHJvcHM7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoJ2xvbmdpdHVkZScgaW4gdiAmJiAnbGF0aXR1ZGUnIGluIHYpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdHIuY2VudGVyO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRyLmNlbnRlciA9IG5ldyBjZW50ZXIuY29uc3RydWN0b3Iodi5sb25naXR1ZGUsIHYubGF0aXR1ZGUpO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBjZW50ZXIgIT09IHRyLmNlbnRlcjtcbiAgICB9XG4gICAgaWYgKCd6b29tJyBpbiB2KSB7XG4gICAgICAgIGNvbnN0IHpvb20gPSB0ci56b29tO1xuICAgICAgICB0ci56b29tID0gdi56b29tO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCB6b29tICE9PSB0ci56b29tO1xuICAgIH1cbiAgICBpZiAoJ2JlYXJpbmcnIGluIHYpIHtcbiAgICAgICAgY29uc3QgYmVhcmluZyA9IHRyLmJlYXJpbmc7XG4gICAgICAgIHRyLmJlYXJpbmcgPSB2LmJlYXJpbmc7XG4gICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGJlYXJpbmcgIT09IHRyLmJlYXJpbmc7XG4gICAgfVxuICAgIGlmICgncGl0Y2gnIGluIHYpIHtcbiAgICAgICAgY29uc3QgcGl0Y2ggPSB0ci5waXRjaDtcbiAgICAgICAgdHIucGl0Y2ggPSB2LnBpdGNoO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBwaXRjaCAhPT0gdHIucGl0Y2g7XG4gICAgfVxuICAgIGlmICh2LnBhZGRpbmcgJiYgIXRyLmlzUGFkZGluZ0VxdWFsKHYucGFkZGluZykpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRyLnBhZGRpbmcgPSB2LnBhZGRpbmc7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/utils/transform.js\n"));

/***/ }),

/***/ "./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// From https://github.com/streamich/react-use/blob/master/src/useIsomorphicLayoutEffect.ts\n// useLayoutEffect but does not trigger warning in server-side rendering\n\nconst useIsomorphicLayoutEffect = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/* harmony default export */ __webpack_exports__[\"default\"] = (useIsomorphicLayoutEffect);\n//# sourceMappingURL=use-isomorphic-layout-effect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNtRDtBQUNuRCxvRUFBb0Usa0RBQWUsR0FBRyw0Q0FBUztBQUMvRiwrREFBZSx5QkFBeUIsRUFBQztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QuanM/NTY0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zdHJlYW1pY2gvcmVhY3QtdXNlL2Jsb2IvbWFzdGVyL3NyYy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXG4vLyB1c2VMYXlvdXRFZmZlY3QgYnV0IGRvZXMgbm90IHRyaWdnZXIgd2FybmluZyBpbiBzZXJ2ZXItc2lkZSByZW5kZXJpbmdcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5leHBvcnQgZGVmYXVsdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js\n"));

/***/ }),

/***/ "./node_modules/subtag/subtag.js":
/*!***************************************!*\
  !*** ./node_modules/subtag/subtag.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(root, name, make) {\r\n  if ( true && module.exports) module.exports = make()\r\n  else root[name] = make()\r\n}(this, 'subtag', function() {\r\n\r\n  var empty = ''\r\n  var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/\r\n\r\n  function match(tag) {\r\n    return tag.match(pattern) || []\r\n  }\r\n\r\n  function split(tag) {\r\n    return match(tag).filter(function(v, i) { return v && i })\r\n  }\r\n\r\n  function api(tag) {\r\n    tag = match(tag)\r\n    return {\r\n      language: tag[1] || empty,\r\n      extlang: tag[2] || empty,\r\n      script: tag[3] || empty,\r\n      region: tag[4] || empty\r\n    }\r\n  }\r\n\r\n  function expose(target, key, value) {\r\n    Object.defineProperty(target, key, {\r\n      value: value,\r\n      enumerable: true\r\n    })\r\n  }\r\n\r\n  function part(position, pattern, type) {\r\n    function method(tag) {\r\n      return match(tag)[position] || empty\r\n    }\r\n    expose(method, 'pattern', pattern)\r\n    expose(api, type, method)\r\n  }\r\n\r\n  part(1, /^[a-zA-Z]{2,3}$/, 'language')\r\n  part(2, /^[a-zA-Z]{3}$/, 'extlang')\r\n  part(3, /^[a-zA-Z]{4}$/, 'script')\r\n  part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, 'region')\r\n\r\n  expose(api, 'split', split)\r\n\r\n  return api\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3VidGFnL3N1YnRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU0sS0FBNEI7QUFDbEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDRCQUE0QixJQUFJLG1CQUFtQixFQUFFLGdDQUFnQyxFQUFFLGdDQUFnQyxFQUFFLE9BQU8sRUFBRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLHFCQUFxQixFQUFFO0FBQ3ZCLHFCQUFxQixFQUFFO0FBQ3ZCLHFCQUFxQixFQUFFLFNBQVMsRUFBRTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N1YnRhZy9zdWJ0YWcuanM/OWIyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24ocm9vdCwgbmFtZSwgbWFrZSkge1xyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoKVxyXG4gIGVsc2Ugcm9vdFtuYW1lXSA9IG1ha2UoKVxyXG59KHRoaXMsICdzdWJ0YWcnLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgdmFyIGVtcHR5ID0gJydcclxuICB2YXIgcGF0dGVybiA9IC9eKFthLXpBLVpdezIsM30pKD86W18tXSsoW2EtekEtWl17M30pKD89JHxbXy1dKykpPyg/OltfLV0rKFthLXpBLVpdezR9KSg/PSR8W18tXSspKT8oPzpbXy1dKyhbYS16QS1aXXsyfXxbMC05XXszfSkoPz0kfFtfLV0rKSk/L1xyXG5cclxuICBmdW5jdGlvbiBtYXRjaCh0YWcpIHtcclxuICAgIHJldHVybiB0YWcubWF0Y2gocGF0dGVybikgfHwgW11cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNwbGl0KHRhZykge1xyXG4gICAgcmV0dXJuIG1hdGNoKHRhZykuZmlsdGVyKGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIHYgJiYgaSB9KVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXBpKHRhZykge1xyXG4gICAgdGFnID0gbWF0Y2godGFnKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGFuZ3VhZ2U6IHRhZ1sxXSB8fCBlbXB0eSxcclxuICAgICAgZXh0bGFuZzogdGFnWzJdIHx8IGVtcHR5LFxyXG4gICAgICBzY3JpcHQ6IHRhZ1szXSB8fCBlbXB0eSxcclxuICAgICAgcmVnaW9uOiB0YWdbNF0gfHwgZW1wdHlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4cG9zZSh0YXJnZXQsIGtleSwgdmFsdWUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJ0KHBvc2l0aW9uLCBwYXR0ZXJuLCB0eXBlKSB7XHJcbiAgICBmdW5jdGlvbiBtZXRob2QodGFnKSB7XHJcbiAgICAgIHJldHVybiBtYXRjaCh0YWcpW3Bvc2l0aW9uXSB8fCBlbXB0eVxyXG4gICAgfVxyXG4gICAgZXhwb3NlKG1ldGhvZCwgJ3BhdHRlcm4nLCBwYXR0ZXJuKVxyXG4gICAgZXhwb3NlKGFwaSwgdHlwZSwgbWV0aG9kKVxyXG4gIH1cclxuXHJcbiAgcGFydCgxLCAvXlthLXpBLVpdezIsM30kLywgJ2xhbmd1YWdlJylcclxuICBwYXJ0KDIsIC9eW2EtekEtWl17M30kLywgJ2V4dGxhbmcnKVxyXG4gIHBhcnQoMywgL15bYS16QS1aXXs0fSQvLCAnc2NyaXB0JylcclxuICBwYXJ0KDQsIC9eW2EtekEtWl17Mn0kfF5bMC05XXszfSQvLCAncmVnaW9uJylcclxuXHJcbiAgZXhwb3NlKGFwaSwgJ3NwbGl0Jywgc3BsaXQpXHJcblxyXG4gIHJldHVybiBhcGlcclxufSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/subtag/subtag.js\n"));

/***/ }),

/***/ "./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: function() { return /* binding */ arrow; },\n/* harmony export */   autoPlacement: function() { return /* binding */ autoPlacement; },\n/* harmony export */   computePosition: function() { return /* binding */ computePosition; },\n/* harmony export */   detectOverflow: function() { return /* binding */ detectOverflow; },\n/* harmony export */   flip: function() { return /* binding */ flip; },\n/* harmony export */   hide: function() { return /* binding */ hide; },\n/* harmony export */   inline: function() { return /* binding */ inline; },\n/* harmony export */   limitShift: function() { return /* binding */ limitShift; },\n/* harmony export */   offset: function() { return /* binding */ offset; },\n/* harmony export */   rectToClientRect: function() { return /* binding */ rectToClientRect; },\n/* harmony export */   shift: function() { return /* binding */ shift; },\n/* harmony export */   size: function() { return /* binding */ size; }\n/* harmony export */ });\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      const prevDimensions = await platform.getDimensions(elements.floating);\n      apply == null ? void 0 : apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtd2ViL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUuYnJvd3Nlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkhBQTJIOztBQUVuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsT0FBTztBQUNQLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1Qix5QkFBeUIsS0FBSztBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRXdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWFwYm94L3NlYXJjaC1qcy13ZWIvbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5icm93c2VyLm1qcz85OWNmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldFNpZGUocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5cbmZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneCcgOiAneSc7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aEZyb21BeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0TGVuZ3RoRnJvbUF4aXMobWFpbkF4aXMpO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVtsZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2xlbmd0aF0gLyAyO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gbWFpbkF4aXMgPT09ICd4JztcbiAgbGV0IGNvb3JkcztcblxuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGZsb2F0aW5nLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBmbG9hdGluZy53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1ttYWluQXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW21haW5BeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIHBvc2l0aW9uaW5nIHN0cmF0ZWd5LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cblxuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gYXN5bmMgKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZykgPT4ge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG5cbiAge1xuICAgIGlmIChwbGF0Zm9ybSA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnRmxvYXRpbmcgVUk6IGBwbGF0Zm9ybWAgcHJvcGVydHkgd2FzIG5vdCBwYXNzZWQgdG8gY29uZmlnLiBJZiB5b3UnLCAnd2FudCB0byB1c2UgRmxvYXRpbmcgVUkgb24gdGhlIHdlYiwgaW5zdGFsbCBAZmxvYXRpbmctdWkvZG9tJywgJ2luc3RlYWQgb2YgdGhlIC9jb3JlIHBhY2thZ2UuIE90aGVyd2lzZSwgeW91IGNhbiBjcmVhdGUgeW91ciBvd24nLCAnYHBsYXRmb3JtYDogaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9wbGF0Zm9ybSddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgaWYgKG1pZGRsZXdhcmUuZmlsdGVyKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gJ2F1dG9QbGFjZW1lbnQnIHx8IG5hbWUgPT09ICdmbGlwJztcbiAgICB9KS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoWydGbG9hdGluZyBVSTogZHVwbGljYXRlIGBmbGlwYCBhbmQvb3IgYGF1dG9QbGFjZW1lbnRgJywgJ21pZGRsZXdhcmUgZGV0ZWN0ZWQuIFRoaXMgd2lsbCBsZWFkIHRvIGFuIGluZmluaXRlIGxvb3AuIEVuc3VyZSBvbmx5JywgJ29uZSBvZiBlaXRoZXIgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSBgbWlkZGxld2FyZWAgYXJyYXkuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9KTtcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCk7XG4gIGxldCBzdGF0ZWZ1bFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgbGV0IG1pZGRsZXdhcmVEYXRhID0ge307XG4gIGxldCByZXNldENvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1pZGRsZXdhcmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gbWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0geyAuLi5taWRkbGV3YXJlRGF0YSxcbiAgICAgIFtuYW1lXTogeyAuLi5taWRkbGV3YXJlRGF0YVtuYW1lXSxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfVxuICAgIH07XG5cbiAgICB7XG4gICAgICBpZiAocmVzZXRDb3VudCA+IDUwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBUaGUgbWlkZGxld2FyZSBsaWZlY3ljbGUgYXBwZWFycyB0byBiZSBydW5uaW5nIGluIGFuJywgJ2luZmluaXRlIGxvb3AuIFRoaXMgaXMgdXN1YWxseSBjYXVzZWQgYnkgYSBgcmVzZXRgIGNvbnRpbnVhbGx5JywgJ2JlaW5nIHJldHVybmVkIHdpdGhvdXQgYSBicmVhayBjb25kaXRpb24uJ10uam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuXG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzZXQucmVjdHMpIHtcbiAgICAgICAgICByZWN0cyA9IHJlc2V0LnJlY3RzID09PSB0cnVlID8gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG5cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG5cbiAgICAgIGkgPSAtMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNpZGVPYmplY3RGcm9tUGFkZGluZyhwYWRkaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIDoge1xuICAgIHRvcDogcGFkZGluZyxcbiAgICByaWdodDogcGFkZGluZyxcbiAgICBib3R0b206IHBhZGRpbmcsXG4gICAgbGVmdDogcGFkZGluZ1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIHsgLi4ucmVjdCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG5cbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFNpZGVPYmplY3RGcm9tUGFkZGluZyhwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICByZWN0OiBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHsgLi4ucmVjdHMuZmxvYXRpbmcsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gOiByZWN0cy5yZWZlcmVuY2UsXG4gICAgb2Zmc2V0UGFyZW50OiBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKSxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3RzW2VsZW1lbnRDb250ZXh0XSk7XG4gIHJldHVybiB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbn1cblxuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcblxuZnVuY3Rpb24gd2l0aGluKG1pbiQxLCB2YWx1ZSwgbWF4JDEpIHtcbiAgcmV0dXJuIG1heChtaW4kMSwgbWluKHZhbHVlLCBtYXgkMSkpO1xufVxuXG4vKipcbiAqIFBvc2l0aW9ucyBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBpdCBpcyBjZW50ZXJlZFxuICogdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuXG4gIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZVxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtXG4gICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmxvYXRpbmcgVUk6IE5vIGBlbGVtZW50YCB3YXMgcGFzc2VkIHRvIHRoZSBgYXJyb3dgIG1pZGRsZXdhcmUuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0TGVuZ3RoRnJvbUF4aXMoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG5cbiAgICBpZiAoY2xpZW50U2l6ZSA9PT0gMCkge1xuICAgICAgY2xpZW50U2l6ZSA9IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kc1xuXG4gICAgY29uc3QgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBNYWtlIHN1cmUgdGhhdCBhcnJvdyBwb2ludHMgYXQgdGhlIHJlZmVyZW5jZVxuXG4gICAgY29uc3QgYWxpZ25tZW50UGFkZGluZyA9IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/IHBhZGRpbmdPYmplY3RbbWluUHJvcF0gOiBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICAgIGNvbnN0IHNob3VsZEFkZE9mZnNldCA9IGFsaWdubWVudFBhZGRpbmcgPiAwICYmIGNlbnRlciAhPT0gb2Zmc2V0ICYmIHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdIDw9IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3QgYWxpZ25tZW50T2Zmc2V0ID0gc2hvdWxkQWRkT2Zmc2V0ID8gY2VudGVyIDwgbWluID8gbWluIC0gY2VudGVyIDogbWF4IC0gY2VudGVyIDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gLSBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldFxuICAgICAgfVxuICAgIH07XG4gIH1cblxufSk7XG5cbmNvbnN0IGhhc2gkMSA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBtYXRjaGVkID0+IGhhc2gkMVttYXRjaGVkXSk7XG59XG5cbmZ1bmN0aW9uIGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCkge1xuICBpZiAocnRsID09PSB2b2lkIDApIHtcbiAgICBydGwgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhtYWluQXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG5cbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYWluOiBtYWluQWxpZ25tZW50U2lkZSxcbiAgICBjcm9zczogZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXG4gIH07XG59XG5cbmNvbnN0IGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIG1hdGNoZWQgPT4gaGFzaFttYXRjaGVkXSk7XG59XG5cbmNvbnN0IHNpZGVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmNvbnN0IGFsbFBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLXN0YXJ0XCIsIHNpZGUgKyBcIi1lbmRcIiksIFtdKTtcblxuZnVuY3Rpb24gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSB7XG4gIGNvbnN0IGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQgPSBhbGlnbm1lbnQgPyBbLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50KSwgLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPT0gYWxpZ25tZW50KV0gOiBhbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldFNpZGUocGxhY2VtZW50KSA9PT0gcGxhY2VtZW50KTtcbiAgcmV0dXJuIGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQuZmlsdGVyKHBsYWNlbWVudCA9PiB7XG4gICAgaWYgKGFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQgfHwgKGF1dG9BbGlnbm1lbnQgPyBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpICE9PSBwbGFjZW1lbnQgOiBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgY2hvb3NlcyB0aGUgYHBsYWNlbWVudGAgd2hpY2ggaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDMsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDQsIF9wbGFjZW1lbnRzU29ydGVkQnlMZTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxpZ25tZW50ID0gbnVsbCxcbiAgICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBhbGxQbGFjZW1lbnRzLFxuICAgICAgICBhdXRvQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKF9taWRkbGV3YXJlRGF0YSRhdXRvUCA9IChfbWlkZGxld2FyZURhdGEkYXV0b1AyID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDIuaW5kZXgpICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkYXV0b1AgOiAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHNbY3VycmVudEluZGV4XTtcblxuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbixcbiAgICAgICAgY3Jvc3NcbiAgICAgIH0gPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTsgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2VcblxuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gY3VycmVudFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1ttYWluXSwgb3ZlcmZsb3dbY3Jvc3NdXTtcbiAgICAgIGNvbnN0IGFsbE92ZXJmbG93cyA9IFsuLi4oKF9taWRkbGV3YXJlRGF0YSRhdXRvUDMgPSAoX21pZGRsZXdhcmVEYXRhJGF1dG9QNCA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1A0Lm92ZXJmbG93cykgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRhdXRvUDMgOiBbXSksIHtcbiAgICAgICAgcGxhY2VtZW50OiBjdXJyZW50UGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3M6IGN1cnJlbnRPdmVyZmxvd3NcbiAgICAgIH1dO1xuICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbY3VycmVudEluZGV4ICsgMV07IC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2tcblxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlMZWFzdE92ZXJmbG93ID0gYWxsT3ZlcmZsb3dzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMF0gLSBiLm92ZXJmbG93c1swXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRUaGF0Rml0c09uQWxsU2lkZXMgPSAoX3BsYWNlbWVudHNTb3J0ZWRCeUxlID0gcGxhY2VtZW50c1NvcnRlZEJ5TGVhc3RPdmVyZmxvdy5maW5kKF9yZWYgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIG92ZXJmbG93c1xuICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIG92ZXJmbG93cy5ldmVyeShvdmVyZmxvdyA9PiBvdmVyZmxvdyA8PSAwKTtcbiAgICAgIH0pKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNTb3J0ZWRCeUxlLnBsYWNlbWVudDtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50VGhhdEZpdHNPbkFsbFNpZGVzICE9IG51bGwgPyBwbGFjZW1lbnRUaGF0Rml0c09uQWxsU2lkZXMgOiBwbGFjZW1lbnRzU29ydGVkQnlMZWFzdE92ZXJmbG93WzBdLnBsYWNlbWVudDtcblxuICAgICAgaWYgKHJlc2V0UGxhY2VtZW50ICE9PSBwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgcGxhY2VtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHRvIG9uZSB0aGF0IHdpbGwgZml0IGlmIHRoZVxuICogaW5pdGlhbGx5IHNwZWNpZmllZCBgcGxhY2VtZW50YCBkb2VzIG5vdC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZmxpcCcsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IHNpZGUgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IFtpbml0aWFsUGxhY2VtZW50LCAuLi5mYWxsYmFja1BsYWNlbWVudHNdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcblxuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1haW4sXG4gICAgICAgICAgY3Jvc3NcbiAgICAgICAgfSA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W21haW5dLCBvdmVyZmxvd1tjcm9zc10pO1xuICAgICAgfVxuXG4gICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3NcbiAgICAgIH1dOyAvLyBPbmUgb3IgbW9yZSBzaWRlcyBpcyBvdmVyZmxvd2luZ1xuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwJCwgX21pZGRsZXdhcmVEYXRhJGZsaXAyO1xuXG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAkID0gKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkZmxpcCQgOiAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG5cbiAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAvLyBUcnkgbmV4dCBwbGFjZW1lbnQgYW5kIHJlLXJ1biB0aGUgbGlmZWN5Y2xlXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9ICdib3R0b20nO1xuXG4gICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgIGNhc2UgJ2Jlc3RGaXQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkbWFwJHNvO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRtYXAkc28gPSBvdmVyZmxvd3NEYXRhLm1hcChkID0+IFtkLCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJG1hcCRzb1swXS5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAoX3RlbXApIHtcbiAgbGV0IHtcbiAgICBzdHJhdGVneSA9ICdyZWZlcmVuY2VIaWRkZW4nLFxuICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0c1xuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG5cbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIHsgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZXNjYXBlZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCB7IC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvQ29vcmRzKG1pZGRsZXdhcmVBcmd1bWVudHMsIHZhbHVlKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHNcbiAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gJ3gnO1xuICBjb25zdCBtYWluQXhpc011bHRpID0gWydsZWZ0JywgJ3RvcCddLmluY2x1ZGVzKHNpZGUpID8gLTEgOiAxO1xuICBjb25zdCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxO1xuICBjb25zdCByYXdWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKG1pZGRsZXdhcmVBcmd1bWVudHMpIDogdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcblxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsLFxuICAgIC4uLnJhd1ZhbHVlXG4gIH07XG5cbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuXG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuLyoqXG4gKiBEaXNwbGFjZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgZnJvbSBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cblxuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgdmFsdWUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zOiB2YWx1ZSxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMobWlkZGxld2FyZUFyZ3VtZW50cywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIGRpZmZDb29yZHMueCxcbiAgICAgICAgeTogeSArIGRpZmZDb29yZHMueSxcbiAgICAgICAgZGF0YTogZGlmZkNvb3Jkc1xuICAgICAgfTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldENyb3NzQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5cbi8qKlxuICogU2hpZnRzIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIGEgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0Q3Jvc3NBeGlzKG1haW5BeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuXG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gbWFpbkF4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBtYWluQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIG1haW5BeGlzQ29vcmQgPSB3aXRoaW4obWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gY3Jvc3NBeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gY3Jvc3NBeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSB3aXRoaW4obWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGltaXRlZENvb3JkcyA9IGxpbWl0ZXIuZm4oeyAuLi5taWRkbGV3YXJlQXJndW1lbnRzLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG5cbiAgICBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0Q3Jvc3NBeGlzKG1haW5BeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgY29uc3QgcmF3T2Zmc2V0ID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldCh7IC4uLnJlY3RzLFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0pIDogb2Zmc2V0O1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG5cbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gLSBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcblxuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMiwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMywgX21pZGRsZXdhcmVEYXRhJG9mZnNlNDtcblxuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBpc09yaWdpblNpZGUgPSBbJ3RvcCcsICdsZWZ0J10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSAhPSBudWxsID8gX21pZGRsZXdhcmVEYXRhJG9mZnNlIDogMCA6IDApICsgKGlzT3JpZ2luU2lkZSA/IDAgOiBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMpO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gMCA6IChfbWlkZGxld2FyZURhdGEkb2Zmc2UzID0gKF9taWRkbGV3YXJlRGF0YSRvZmZzZTQgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2U0W2Nyb3NzQXhpc10pICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkb2Zmc2UzIDogMCkgLSAoaXNPcmlnaW5TaWRlID8gY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzIDogMCk7XG5cbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuIEZvciBpbnN0YW5jZSxcbiAqIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyBpdHMgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlIHdpZHRoIG9mIHRoZVxuICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwcGx5LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuXG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IHNpZGU7XG4gICAgICAgIHdpZHRoU2lkZSA9IGFsaWdubWVudCA9PT0gKChhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpID8gJ3N0YXJ0JyA6ICdlbmQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aFNpZGUgPSBzaWRlO1xuICAgICAgICBoZWlnaHRTaWRlID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgIGNvbnN0IHlNaW4gPSBtYXgob3ZlcmZsb3cudG9wLCAwKTtcbiAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgICAgIGF2YWlsYWJsZUhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0IC0gKFsnbGVmdCcsICdyaWdodCddLmluY2x1ZGVzKHBsYWNlbWVudCkgPyAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSkgOiBvdmVyZmxvd1toZWlnaHRTaWRlXSksXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCAtIChbJ3RvcCcsICdib3R0b20nXS5pbmNsdWRlcyhwbGFjZW1lbnQpID8gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpIDogb3ZlcmZsb3dbd2lkdGhTaWRlXSlcbiAgICAgIH07XG4gICAgICBjb25zdCBwcmV2RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgYXBwbHkgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGx5KHsgLi4ubWlkZGxld2FyZUFyZ3VtZW50cyxcbiAgICAgICAgLi4uZGltZW5zaW9uc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuXG4gICAgICBpZiAocHJldkRpbWVuc2lvbnMud2lkdGggIT09IG5leHREaW1lbnNpb25zLndpZHRoIHx8IHByZXZEaW1lbnNpb25zLmhlaWdodCAhPT0gbmV4dERpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRnZXRDbDtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50czsgLy8gQSBNb3VzZUV2ZW50J3MgY2xpZW50e1gsWX0gY29vcmRzIGNhbiBiZSB1cCB0byAyIHBpeGVscyBvZmYgYVxuICAgICAgLy8gQ2xpZW50UmVjdCdzIGJvdW5kcywgZGVzcGl0ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYmVpbmcgdHJpZ2dlcmVkLiBBXG4gICAgICAvLyBwYWRkaW5nIG9mIDIgc2VlbXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuXG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgICAgICByZWN0OiByZWN0cy5yZWZlcmVuY2UsXG4gICAgICAgIG9mZnNldFBhcmVudDogYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnRzLmZsb2F0aW5nKSksXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KSA6IHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IChfYXdhaXQkcGxhdGZvcm0kZ2V0Q2wgPSBhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGdldENsIDogW107XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZFxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbGllbnRSZWN0cyRmaW5kO1xuXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlXG4gICAgICAgICAgcmV0dXJuIChfY2xpZW50UmVjdHMkZmluZCA9IGNsaWVudFJlY3RzLmZpbmQocmVjdCA9PiB4ID4gcmVjdC5sZWZ0IC0gcGFkZGluZ09iamVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCAmJiB5ID4gcmVjdC50b3AgLSBwYWRkaW5nT2JqZWN0LnRvcCAmJiB5IDwgcmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkpICE9IG51bGwgPyBfY2xpZW50UmVjdHMkZmluZCA6IGZhbGxiYWNrO1xuICAgICAgICB9IC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzXG5cblxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkgPT09ICd4Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHJlY3RUb0NsaWVudFJlY3QsIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs\n"));

/***/ }),

/***/ "./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow; },\n/* harmony export */   autoPlacement: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement; },\n/* harmony export */   autoUpdate: function() { return /* binding */ autoUpdate; },\n/* harmony export */   computePosition: function() { return /* binding */ computePosition; },\n/* harmony export */   detectOverflow: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow; },\n/* harmony export */   flip: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip; },\n/* harmony export */   getOverflowAncestors: function() { return /* binding */ getOverflowAncestors; },\n/* harmony export */   hide: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide; },\n/* harmony export */   inline: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline; },\n/* harmony export */   limitShift: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift; },\n/* harmony export */   offset: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset; },\n/* harmony export */   shift: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift; },\n/* harmony export */   size: function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size; }\n/* harmony export */ });\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs\");\n\n\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  //  Always-visible scrollbar or not\n  //  Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n  platform,\n  ...options\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtd2ViL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLmJyb3dzZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJGO0FBQ21DOztBQUU5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtRUFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUVBQWdCO0FBQ3pCLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxrRUFBaUI7QUFDM0U7QUFDQTtBQUNBLENBQUM7O0FBRTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWFwYm94L3NlYXJjaC1qcy13ZWIvbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20uYnJvd3Nlci5tanM/ZmQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcblxuZnVuY3Rpb24gaXNXaW5kb3codmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLmRvY3VtZW50ICYmIHZhbHVlLmxvY2F0aW9uICYmIHZhbHVlLmFsZXJ0ICYmIHZhbHVlLnNldEludGVydmFsO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAoIWlzV2luZG93KG5vZGUpKSB7XG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICByZXR1cm4gaXNXaW5kb3cobm9kZSkgPyAnJyA6IG5vZGUgPyAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoaXRlbSA9PiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb24pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuTm9kZTtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgYFNoYWRvd1Jvb3RgIHN1cHBvcnRcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZXG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufVxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgLy8gVE9ETzogVHJ5IGFuZCB1c2UgZmVhdHVyZSBkZXRlY3Rpb24gaGVyZSBpbnN0ZWFkXG4gIGNvbnN0IGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICByZXR1cm4gY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IC8vIEB0cy1pZ25vcmUgKFRTIDQuMSBjb21wYXQpXG4gIGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5jbHVkZXMoY3NzLndpbGxDaGFuZ2UpIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgLy8gTm90IFNhZmFyaVxuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7IC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciB0aGlzIGZhaWxzIGluIHZhcmlvdXMgd2F5c1xuICAvLyDigKIgQWx3YXlzLXZpc2libGUgc2Nyb2xsYmFyIG9yIG5vdFxuICAvLyDigKIgV2lkdGggb2YgPGh0bWw+LCBldGMuXG4gIC8vIGNvbnN0IHZWID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICAvLyByZXR1cm4gdlYgPyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZWLnNjYWxlIC0gdlYud2lkdGgpIDwgMC41IDogdHJ1ZTtcbn1cblxuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcbmNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZDtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5KSB7XG4gIHZhciBfd2luJHZpc3VhbFZpZXdwb3J0JG8sIF93aW4kdmlzdWFsVmlld3BvcnQsIF93aW4kdmlzdWFsVmlld3BvcnQkbzIsIF93aW4kdmlzdWFsVmlld3BvcnQyO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cblxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IHNjYWxlWCA9IDE7XG4gIGxldCBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgY29uc3Qgd2luID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93O1xuICBjb25zdCBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG4gIGNvbnN0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgPyAoX3dpbiR2aXN1YWxWaWV3cG9ydCRvID0gKF93aW4kdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luJHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQpICE9IG51bGwgPyBfd2luJHZpc3VhbFZpZXdwb3J0JG8gOiAwIDogMCkpIC8gc2NhbGVYO1xuICBjb25zdCB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgPyAoX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiA9IChfd2luJHZpc3VhbFZpZXdwb3J0MiA9IHdpbi52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW4kdmlzdWFsVmlld3BvcnQyLm9mZnNldFRvcCkgIT0gbnVsbCA/IF93aW4kdmlzdWFsVmlld3BvcnQkbzIgOiAwIDogMCkpIC8gc2NhbGVZO1xuICBjb25zdCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gIGNvbnN0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgbGVmdDogeCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgcmV0dXJuICgoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnBhZ2VYT2Zmc2V0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5wYWdlWU9mZnNldFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2NhbGVkKGVsZW1lbnQpIHtcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmV0dXJuIHJvdW5kKHJlY3Qud2lkdGgpICE9PSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IHJvdW5kKHJlY3QuaGVpZ2h0KSAhPT0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIC8vIEB0cy1pZ25vcmUgLSBjaGVja2VkIGFib3ZlIChUUyA0LjEgY29tcGF0KVxuICBpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiBpc1NjYWxlZChvZmZzZXRQYXJlbnQpLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSAnZml4ZWQnKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbm9kZS5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBub2RlLnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChub2RlKSA/IG5vZGUuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkgLy8gZmFsbGJhY2tcblxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhWydodG1sJywgJ2JvZHknXS5pbmNsdWRlcyhnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcblxuICBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSAnZml4ZWQnKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gLy8gVGhpcyBkb2Vzbid0IGFwcGVhciB0byBiZSBuZWVkIHRvIGJlIG5lZ2F0ZWQuXG4gICAgLy8gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgLy8gICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgLy8gfVxuXG4gIH1cblxuICByZXR1cm4geyAuLi5yZWN0LFxuICAgIHg6IHJlY3QueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICsgb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QueSAtIHNjcm9sbC5zY3JvbGxUb3AgKyBvZmZzZXRzLnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgY29uc3QgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICBjb25zdCB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSQxKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuXG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShwYXJlbnROb2RlKSkpIHtcbiAgICAvLyBAdHMtaWdub3JlIGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRPdmVyZmxvd0FuY2VzdG9ycyhub2RlLCBsaXN0KSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmJvZHkpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsYWJsZUFuY2VzdG9yKTtcbiAgY29uc3QgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNPdmVyZmxvd0VsZW1lbnQoc2Nyb2xsYWJsZUFuY2VzdG9yKSA/IHNjcm9sbGFibGVBbmNlc3RvciA6IFtdKSA6IHNjcm9sbGFibGVBbmNlc3RvcjtcbiAgY29uc3QgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyBAdHMtaWdub3JlOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQoZ2V0T3ZlcmZsb3dBbmNlc3RvcnModGFyZ2V0KSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgY29uc3Qgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgIGxldCBuZXh0ID0gY2hpbGQ7XG5cbiAgICBkbyB7XG4gICAgICAvLyB1c2UgYD09PWAgcmVwbGFjZSBub2RlLmlzU2FtZU5vZGUoKVxuICAgICAgaWYgKG5leHQgJiYgcGFyZW50ID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBAdHMtaWdub3JlOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH0gd2hpbGUgKG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3AsXG4gICAgcmlnaHQ6IGxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoLFxuICAgIGJvdHRvbTogdG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgd2lkdGg6IGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBlbGVtZW50LmNsaWVudEhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGlmIChjbGlwcGluZ1BhcmVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJldHVybiByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpO1xuICB9XG5cbiAgaWYgKGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkpIHtcbiAgICByZXR1cm4gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgfVxuXG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0FuY2VzdG9ycyhlbGVtZW50KSB7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCk7XG4gIGNvbnN0IGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluY2x1ZGVzKGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5wb3NpdGlvbik7XG4gIGNvbnN0IGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vIEB0cy1pZ25vcmUgaXNFbGVtZW50IGNoZWNrIGVuc3VyZXMgd2UgcmV0dXJuIEFycmF5PEVsZW1lbnQ+XG5cblxuICByZXR1cm4gY2xpcHBpbmdBbmNlc3RvcnMuZmlsdGVyKGNsaXBwaW5nQW5jZXN0b3JzID0+IGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9ycykgJiYgY29udGFpbnMoY2xpcHBpbmdBbmNlc3RvcnMsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ0FuY2VzdG9ycykgIT09ICdib2R5Jyk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIGFuY2VzdG9yc1xuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudCxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG1haW5DbGlwcGluZ0FuY2VzdG9ycyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdBbmNlc3RvcnMnID8gZ2V0Q2xpcHBpbmdBbmNlc3RvcnMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5tYWluQ2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGdldENsaXBwaW5nUmVjdCxcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QsXG4gIGlzRWxlbWVudCxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldEVsZW1lbnRSZWN0czogX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nLFxuICAgICAgc3RyYXRlZ3lcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChmbG9hdGluZyksIHN0cmF0ZWd5KSxcbiAgICAgIGZsb2F0aW5nOiB7IC4uLmdldERpbWVuc2lvbnMoZmxvYXRpbmcpLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0Q2xpZW50UmVjdHM6IGVsZW1lbnQgPT4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpLFxuICBpc1JUTDogZWxlbWVudCA9PiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJ1xufTtcblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbDogX2FuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZTogX2FuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHJ1ZSxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBhbmNlc3RvclNjcm9sbCA9IF9hbmNlc3RvclNjcm9sbCAmJiAhYW5pbWF0aW9uRnJhbWU7XG4gIGNvbnN0IGFuY2VzdG9yUmVzaXplID0gX2FuY2VzdG9yUmVzaXplICYmICFhbmltYXRpb25GcmFtZTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4uKGlzRWxlbWVudChyZWZlcmVuY2UpID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGxldCBvYnNlcnZlciA9IG51bGw7XG5cbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICBsZXQgaW5pdGlhbFVwZGF0ZSA9IHRydWU7XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgaWYgKCFpbml0aWFsVXBkYXRlKSB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsVXBkYXRlID0gZmFsc2U7XG4gICAgfSk7XG4gICAgaXNFbGVtZW50KHJlZmVyZW5jZSkgJiYgIWFuaW1hdGlvbkZyYW1lICYmIG9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuXG4gIGxldCBmcmFtZUlkO1xuICBsZXQgcHJldlJlZlJlY3QgPSBhbmltYXRpb25GcmFtZSA/IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpIDogbnVsbDtcblxuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuXG4gICAgaWYgKHByZXZSZWZSZWN0ICYmIChuZXh0UmVmUmVjdC54ICE9PSBwcmV2UmVmUmVjdC54IHx8IG5leHRSZWZSZWN0LnkgIT09IHByZXZSZWZSZWN0LnkgfHwgbmV4dFJlZlJlY3Qud2lkdGggIT09IHByZXZSZWZSZWN0LndpZHRoIHx8IG5leHRSZWZSZWN0LmhlaWdodCAhPT0gcHJldlJlZlJlY3QuaGVpZ2h0KSkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cblxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX29ic2VydmVyO1xuXG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgKF9vYnNlcnZlciA9IG9ic2VydmVyKSA9PSBudWxsID8gdm9pZCAwIDogX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBvYnNlcnZlciA9IG51bGw7XG5cbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgcmVmZXJlbmNlIGVsZW1lbnQgd2hlbiBpdCBpcyBnaXZlbiBhIGNlcnRhaW4gQ1NTIHBvc2l0aW9uaW5nXG4gKiBzdHJhdGVneS5cbiAqL1xuXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICBwbGF0Zm9ybSxcbiAgLi4ub3B0aW9uc1xufSk7XG5cbmV4cG9ydCB7IGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-web/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs\n"));

/***/ })

}]);